<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
   
   <meta name="description" content="Modern Fortran Edition of DIVA">
    
    <meta name="author" content="Jacob Williams" >
    <link rel="icon" href="../favicon.png">

    <title>DIVA &ndash; diva</title>

    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/pygments.css" rel="stylesheet">
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/local.css" rel="stylesheet">
    
    <link  href="../tipuesearch/tipuesearch.css" rel="stylesheet">
    
    

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <script src="../js/jquery-2.1.3.min.js"></script>
    <script src="../js/svg-pan-zoom.min.js"></script>

  </head>

  <body>

    <!-- Fixed navbar -->
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../index.html">diva </a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
        
            <li class="dropdown hidden-xs visible-sm visible-md hidden-lg">
              <a href="#" class="dropdown-toggle"
              data-toggle="dropdown" role="button"
              aria-haspopup="true"
     aria-expanded="false">Contents <span class="caret"></span></a>
        <ul class="dropdown-menu">
          
              
            <li><a href="../lists/files.html">Source Files</a></li>
        
        
        
            
                                
            <li><a href="../lists/procedures.html">Procedures</a></li>
        
               
        
            <li><a href="../lists/programs.html">Programs</a></li>
        
            </ul>
            </li>


<li class="visible-xs hidden-sm visible-lg"><a href="../lists/files.html">Source Files</a></li>





<li class="visible-xs hidden-sm visible-lg"><a href="../lists/procedures.html">Procedures</a></li>

                             

<li class="visible-xs hidden-sm visible-lg"><a href="../lists/programs.html">Programs</a></li>

          </ul>
        
        <form action="../search.html" class="navbar-form navbar-right" role="search">
        <div class="form-group">
          <input type="text" class="form-control" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
        </div>
<!--
        <button type="submit" class="btn btn-default">Submit</button>
-->
        </form>
        
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
    
  
  <div class="row">
    <h1>DIVA
      <small>Subroutine</small>
    
    </h1>
    
<div class="row">
  <div class="col-lg-12">
<div class="well well-sm">
  <ul class="list-inline" style="margin-bottom:0px;display:inline">
     
     
     
     
    
    
     <li><i class="fa fa-list-ol"></i>
       <a data-toggle="tooltip"
    data-placement="bottom" data-html="true"
    title=" 7.7% of total for procedures.">315 statements</a>
     </li> 
     
     
     
    <li><i class="fa fa-code"></i><a href="../src/diva.f"> Source File</a></li>
     
     
  </ul>
  <ol class="breadcrumb in-well text-right">
  
    
     <li><a href='../sourcefile/diva.f.html'>diva.f</a></li>
    
  
     <li class="active">DIVA</li>
  </ol>
</div>
</div>
</div>
<script>
  $(function () {
  $('[data-toggle="tooltip"]').tooltip()
  })
</script>

  </div>
  
  <div class="row">
    <div class="col-md-3 hidden-xs hidden-sm visible-md visible-lg">
    
<div id="sidebar">
  
<h3>Contents</h3>
 


<div class="panel panel-primary">
  <div class="panel-heading
  text-left"><h3 class="panel-title"><a data-toggle="collapse"
  href="#common-0">Common Blocks</a></h3></div>
  <div id="common-0" class="panel-collapse collapse">
    <div class="list-group">
      
      <a class="list-group-item" href="../proc/diva.html#common-divaev~3">DIVAEV</a>
      
      <a class="list-group-item" href="../proc/diva.html#common-divasc~3">DIVASC</a>
      
      <a class="list-group-item" href="../proc/diva.html#common-divamc~3">DIVAMC</a>
      
    </div>
  </div>
</div>






















</div>

    </div>
    
    <div class="col-md-9" id='text'>
    <h2>
subroutine DIVA(TSPECS, Y, F, KORD, NEQ, DIVAF, DIVAO, IDIMT, IDIMY, IDIMF, IDIMK, IOPT)
    
    
   
</h2>
    
  


    

    <h3>Arguments</h3>
    
      
<table class="table table-striped varlist">
<thead><tr><th>Type</th>
<th>Intent</th><th>Optional</th>
<th>Attributes</th><th></th><th>Name</th><th></th></thead>



<tbody>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-tspecs~3"></span>double precision</td>
  <td></td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>TSPECS</strong>(*)</td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-y~3"></span>double precision</td>
  <td></td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>Y</strong>(*)</td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-f~3"></span>double precision</td>
  <td></td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>F</strong>(*)</td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-kord~3"></span>integer</td>
  <td></td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>KORD</strong>(*)</td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-neq"></span>integer</td>
  <td></td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>NEQ</strong></td><td><blockquote>
<p>2015-03-15 DIVA  Krogh  Removed extra call divabu after noise test
2015-03-15 DIVA  Krogh  Forced restart needs more reduction in h.
2010-02-20 DIVA  Krogh  Fixed calling DIVAOP with array other than F.
2009-11-03 DIVA  Krogh  Added option 11, more variables initialized.
2009-10-30 DIVA  Krogh  Gave KSSTRT and ROBND initial values.
2009-10-30 DIVA  Krogh  Fixed reference to undefined location in F.
2009-10-21 DIVA  Krogh  Got rid of NaN in diag. print when LSC=3.
2009-10-15 DIVA  Krogh  A few changes on how noise is handled.
2002-11-12 DIVA  Krogh  Fixed problem integrating to final output pt
2002-08-29 DIVA  Krogh  Added test for invalid HMIN/HMAX.
2002-07-26 DIVA  Krogh  Added KOUTKO to fully support Option 10.
2002-05-14 DIVA  Krogh  Fix starting prob. for Option 18.
2002-05-13 DIVA  Krogh  Put exponent letter in  numbers missing them
2002-05-12 DIVA  Krogh  Added error message for bad option 5 usage.
2001-09-07 DIVA  Krogh  Changes to allow user tol on G-Stops.
2001-05-25 DIVA  Krogh  Minor change for making .f90 version.
2001-05-18 DIVA  Krogh  Less computing with no error test
2001-05-17 DIVA  Krogh  Fixed so with no error test can't start dump
2001-04-24 DIVA  Krogh  Inserted comments from ivacom.
2000-12-01 DIVA  Krogh  Removed (some of) unused C1, MAXSTF, METEXT.
1999-12-28 DIVA  Krogh  Saved S in DIVACR for output consistency.
1999-08-19 DIVA  Krogh  Removed superfluous test above label 3520.
1997-04-22 DIVA  Krogh  Got rid of assigned go to's. F=0 if diag.
1996-08-26 DIVA  Krogh  Initialize F to 0 if dumping solution.
1996-08-23 DIVA  Krogh  Print TN not TSPECS(1) in error messages.
1996-05-30 DIVA  Krogh  Changed DERIVS/OUTPUT to  DIVAF/DIVAO.
1996-04-27 DIVA  Krogh  Changes to use .C. and C%%.
1996-03-30 DIVA  Krogh  Added external statement.
1996-03-25 DIVA  Krogh  Introduced TEXT1 to comply with F77.
1996-02-27 DIVA  Krogh  Fixed so DUMP not affected by ignored eqs.
1995-12-18 DIVA  Krogh  Fixed so no solution dump on 0 length integ.
1995-11-09 DIVA  Krogh  Fixed so char. data at col. 72 is not ' '.
1995-06-19 DIVA  Krogh  Fixed prob. with discon. just after restart.
1995-05-09 DIVA  Krogh  Fixed G-Stop/discontinuity code interaction
1995-04-26 DIVA  Krogh  Use KQMAXS instead of KQMAXI when LDIS&gt;1000.
1995-04-26 DIVA  Krogh  Keep current KQL on discontinutiy.
1994-12-16 DIVA  Krogh  Fixed option 12 with K12 &lt; 0.
1994-11-11 DIVA  Krogh  Declared all vars.
1994-11-02 DIVA  Krogh  Changes to use M77CON
1994-09-08 DIVA  Krogh  Added CHGTYP code.
1994-07-11 DIVA  Krogh  Fix to get same state with/without var. eqs.
1994-03-07 DIVA  Krogh  Allow larger order in single precision.
1994-01-14 DIVA  Krogh  Minor change to allow changing TFINAL.
1993-04-27 DIVA  Krogh  Additions for Conversion to C.
1993-04-12 DIVA  Krogh  Converted to use slightly altered MESS.
1993-04-12 DIVA  Krogh  Fixed LSC so sol. saved when HMAX is small.
1992-10-13 DIVA  Krogh  Fixed G-Stop/discontinuity code interaction.
1992-09-21 DIVA  Krogh  Fixed bug in discontinuity code.
1992-09-09 DIVA  Krogh  Fixed bug - Var. Eqs. with discontinuities.
1992-08-07 DIVA  Krogh  Storage map printed only if option 10 .ne. 0
1992-07-16 DIVA  Krogh  Restored correct discontinuity code.
1992-06-16 DIVA  Krogh  Eliminate reuse of storage for option 12.
1992-04-08 DIVA  Krogh  Removed unused labels, 1020, 2120.
1992-03-30 DIVA  Krogh  Fixed bug in DIVAOP error message.
1992-03-12 DIVA  Krogh  Simplified DIVABU, more digits in B's.
1992-01-16 DIVA  Krogh  Fixed minor bug in error messages.
1991-12-03 DIVA  Krogh  Major change for improved error checks.
1991-06-17 DIVA  Krogh  Fixed bug in checking storage allocation.
1991-04-11 DIVA  Krogh  Fixed minor bug re. option 12 in DIVAOP.
1991-03-28 DIVA  Krogh  Removed check at label 650 for KORD2I&lt;0.
1991-02-08 DIVA  Krogh  Changed some floats to generics
1990-11-08 DIVA  Krogh  Fixed bug on TSPECS on discon.
1990-09-14 DIVA  Krogh  Fixed bug when discon. and sol. save.
1990-09-13 DIVA  Krogh  Increased dimension of BETA by 1.
1990-09-13 DIVA  Krogh  Added one more poss. on rel. error test.
1990-09-11 DIVA  Krogh  Recent change messed up getting dump output.
1990-06-05 DIVA  Krogh  Fixed bug in noise test, comments in IVACOM.
1990-05-08 DIVA  Krogh  Fixed new bug when TMARK hit in DIVAG.
1990-04-17 DIVA  Krogh  Fixed minor problem in DIVAIN error msg.
1990-04-10 DIVA  Krogh  Fixed interaction between discon. &amp; dump.
1990-03-23 DIVA  Krogh  Fixed bug on option "-2", see 1989-12-07.
1990-03-20 DIVA  Krogh  Fixed rarely occuring loop.
1990-01-29 DIVA  Krogh  Removed unneeded labels.
1989-12-14 DIVA  Krogh  Saved common block DIVAEV.
1989-12-07 DIVA  Krogh  Added option "2" to DIVAOP.
1989-11-09 DIVA  Krogh  Made GG a save var. in DIVAHC
1989-08-21 DIVA  Krogh  Fix out of bounds ref. to V in DIVABU
1989-07-26 DIVA  Krogh  Fix bug in initial dim. check
1989-07-21 DIVA  Krogh  Code for integrating discontinuities
1987-12-07 DIVA  Krogh  Initial code.</p>
</blockquote>
<p>--D replaces "?": ?IVA,?IVAA,?IVABU,?IVACO,?IVACR,?IVAEV,?IVAF,?IVAHC,
-- &amp; ?IVAG,?IVAIN,?IVAMC,?IVAO,?IVAOP,?IVAPR,?IVASC,?IVACE,?IVAIE,
-- &amp; ?IVAPE,?MESS</p>
<p>Note a "*" at the start of a name is used to indicate "D" for the
 double precision version and "S" for the single precision version.</p>
<p>When converting between precisions, don't forget to change the value
 of KDIM set in parameter statements in a variety of routines, and to
 adjust comments for the data statements associated with EIBND in
 <em>IVACR, and B in </em>IVAHC.</p>
<p>Entries
  <em>IVA    Main entry for starting the package.
  </em>IVAA   Main program inside the package, calls the other routines,
          and does checks for output, and noise.  Called by the user
          if reverse communication is used.
  <em>IVABU  Back ups the solution to the current base time, if a step
          that has been started must be taken over for some reason.
  </em>IVACO  Called by user to get certain information from the common
          blocks.
  <em>IVACR  Corrects the solution, estimates errors, and selects order.
  </em>IVADB  Subroutine to assist in debugging codes.  Called by user to
          get a formatted list of all the variables used in the
          integration.  Not required in usual case.
  <em>IVADE  Needed only for delay differential equations.  This is called
          by the user from the derivative subprogram.
  </em>IVAG   Required only if the user has G-Stops, i.e. places to call
          his output subroutine where certain functions have zeroes.
  <em>IVAHC  Compute coefficients that depend on the step size history.
  </em>IVAIN  Used to interpolate to arbitrary points.
  <em>IVAOP  Used to process user option requests.
  </em>IVAPR  Used to update the differences and to predict the solution
          at the end of the current step.</p>
<p>External Routines
  <em>1MACH  Not used in the Fortran 95 version.  ("</em>" is "D" for double
          and "R" for single precision.) This returns constants that
          depend on the floating point arithmetic.  Input arguments of
          1 to 4 give respectively:  underflow limit, overflow limit,
          smallest relative difference between two floating point
          numbers, and the largest relative difference between two
          floating point numbers.
 DERIVS (formal) Name of subroutine to be called for computing
  OPTCHK  Used in checking storage allocation.
  <em>MESS   Used to output error messages and diaganostic messages.
          (Just MESS if no floating point is output.)
  </em>ZERO   Called only if *IVAG is used.  Iterates to find zeros of
          arbitrary (continuous) functions.</p>
<p>Common blocks -- As a left over from the distant past, some variables
   are in common so that they would be saved.
  <em>IVAEV  Holds variables that depend on the environment.
  </em>IVAMC  The main common block for the package.
  *IVASC  The secondary common block for the package.  This contains
          variables that are required for doing interpolation and is
          separate to simplify saving the variables that are required
          when the solution is being dumped (saved).</p>
<p>Common variables and local variables
 ALPHA  (<em>IVAMC) Array with I-th entry = (current step size) / XI(I).
   Used in computing integration coefficients.
 B      (</em>IVAHC) Array used to get started on computing integration
   coefficients.  B(K) = 1. / (K<em>(K+1))
 BAKMIN (</em>IVADE) The largest delay at the initial point.
 BETA   (<em>IVAMC) Array with I-th entry = product (K=1,I-1) of
   (current (XI(K)) / XI(K) from previous step),  BETA(1)=1.  Used in
    updating the difference tables.
 C      (</em>IVAIN) Array used to hold integration/interpolation coeffs.
 C0     Parameter = 0. (in <em>IVAA,DE,CR,A,G,HC,IN,OP,PR)
 C1     Parameter = 1. (in </em>IVA,A,CR,DA,HC,IN,OP)
 C10    Parameter = 10. (in <em>IVAA,CR,OP)
 C1000  Parameter = 1000. (in </em>IVACR)
 C16    Parameter = 16. (in <em>IVAA,OP)
 C1M3   Parameter = .001 (in </em>IVAA)
 C1M5   Parameter = .00001 (in <em>IVAA)
 C1P125 Parameter = 1.125 (in </em>IVAA,HC,OP)
 C1P3   Parameter = 1.3 (in <em>IVAA)
 C1P4   Parameter = 1.4 (in </em>IVACR)
 C2     Parameter = 2. (in <em>IVAA,DE,BU,CR,IN,OP)
 C20    Parameter = 20. (in </em>IVACR)
 C2P5M3 Parameter = .0025 (in <em>IVAA)
 C4     Parameter = 4. (in </em>IVACR,OP)
 C40    Parameter = 40. (in <em>IVACR)
 C4096  Parameter = 4096. (in </em>IVAA)
 C6     Parameter = 6. (in <em>IVAA)
 C8M3   Parameter = .008 (in </em>IVAA)
 CM2    Parameter = -2. (in <em>IVACR)
 CM8    Parameter = -8. (in </em>IVACR)
 CMP5   Parameter = -.5 (in <em>IVACR)
 CMP75  Parameter = -.75 (in </em>IVAOP)
 CP0625 Parameter = .0625 (in <em>IVAA)
 CP1    Parameter = .1 (in </em>IVAA,CR,DA,HC)
 CP125  Parameter = .125 (in <em>IVACR)
 CP25   Parameter = .25 (in </em>IVAA,CR,DE,OP)
 CP3    Parameter = .3 (in <em>IVAA,OP)
 CP4    Parameter = .4 (in </em>IVAA)
 CP5    Parameter = .5 (in <em>IVAA,CR,DA,DE,HC,OP)
 CP5625 Parameter = .5625 (in </em>IVAHC)
 CP625  Parameter = .625 (in <em>IVAOP)
 CP75   Parameter = .75 (in </em>IVACR,OP)
 CP8    Parameter = .8 (in <em>IVACR)
 CP875  Parameter = .875 (in </em>IVAA, OP)
 CP9    Parameter = .9 (in <em>IVAOP)
 CP9375 Parameter = .9375 (in </em>IVACR)
 CQ3125 Parameter = .03125 (in <em>IVACR)
 CRBQI  Parameter = .421875 (in </em>IVAHC)  Initial val for computing RBQ.
 CSUM   (<em>IVAIN) Array used to contain partial sums of the integration
   coefficients.  This is used to corrrect for a difference table that
   has not yet been updated.
 D      (</em>IVAMC) Array to be used later to store coefficients for
   integrating stiff equations.
   derivatives.  Not used if option 13 is set.
 DISADJ (<em>IVAA) Value of stepsize when discontinuity is indicated.
 DNOISE (</em>IVAMC) Used in determining if noise is limiting the
   precision.  It is usually |highest difference used in correcting|
   of the equation with the largest error estimate.
 DS     (<em>IVAMC) Array to be used later to store coefficients for
   estimating errors when integrating stiff equations.
 DVC2   (</em>IVADB) Array used for output of variables HC to TOUT in
   common block <em>IVAMC.
 E      (</em>IVACR) (Estimated error) / (Requested accuracy)
 EAVE   (<em>IVAMC) This is a weighted average of past values of EIMAX.
   It is adjusted to account for expected changes due to step changes.
 EEPS10 (</em>IVAEV) = 10. * (machine epsilon).
 EEPS16 (<em>IVAEV) = 16. * (machine epsilon).
 EEPS2  (</em>IVAEV) =  2. * (machine epsilon).
 EEPT75 (<em>IVAEV) = (machine epsilon) </em><em> (.75)
 EI     (</em>IVACR) Estimate for what E would be if step size increased.
 EIBND  (<em>IVACR) Array containing limits on the estimated error with
   the stepsize increased.  This array tends to make the code a little
   more conservative on step size increases at low order.
 EIMAX  (</em>IVAMC) Estimate of (error estimate / error requested) if the
   step size should be increased.
 EIMIN  (<em>IVAMC) An error estimate is small enough to allow a step
   increase if the estimate of ((error with the step size increased) /
   (error requested)) is less than EIMIN.
 EIMINO (</em>IVAA) Set to C8M3 and never changed.  When step size is being
   reduced if EIMIN .le. EIMINO then the reduction factor is set to
   CP875.  This variable could be a parameter.
 EMAX   (<em>IVAMC) Largest value computed for (error estimate) / (error
   requested).
 EOVEP2 (</em>IVAEV) = EEPS2 * (largest floating point number).
 EPS    (<em>IVACR) Current absolute error tolerance.  Also used for
   temporary storage when computing the desired value of EPS.
 ERCOEF (</em>IVACR) (Error coefficient from formula) / EPS
 EREP   (<em>IVAMC) If EMAX &gt; EREP, a step is repeated.  Ordinarily
   this has the value .3.  This is set &lt; 0 if the error tolerance is
   specified improperly, and is set to a large value if the user
   requests complete control over the step size.  EREP is also set
   &lt; 0 after a user specified discontinuity.
 EROV10 (</em>IVAEV) = 10. / (largest floating point number).
 ETA    (<em>IVAIN) Array used in computing integration/interp. coeffs.
 EVC    (</em>IVADB) Array used for output of variables EEPS2 to EROV10 in
   common block <em>IVAEV.
 EXR    (</em>IVAA) Set to CP1 and never changed.  If it is estimated the
   the (error estimate) / (error requested) on the next step will be
   .ge. EXR then the step size is reduced.  Could be a parameter.
 F      (formal) Array used to store derivative values, the difference
   tables, error tolerance requests, and values used by some other
   options. (in <em>IVA,A,BU,CR,DA,DB,G,IN,PR)
 FDAT  (</em>IVAMC) Used to store data for error messages.  (Local array in
   <em>IVAIN.)
 FOPT  (formal) in </em>IVAOP.  Passed as place to save floating point data
   for options.  This package passes F in for FOPT when calling <em>IVAOP.
 G      (</em>IVAMC) Integration coefficients used for predicting solution.
   G(I, J) gives the I-th coefficient for integrating a J-th order
   differential equation.  G(1, 1) is equal to the step size.
 GAMMA  (<em>IVAIN) Array used in computing integration/interp. coeffs.
 GG     (</em>IVAHC) Array of length = max. differential equation order
   allowed by code - 1.  GG(K) = (HH<strong>(K+1)) / K!
 GNEW   (formal) in <em>IVAG.  Current value for vector function g, whose
   zeroes are to be found.
 GOINT  (</em>IVACR) Used for assigned go to used in computing integration
   coefficients.
 GOLD   (<em>IVAG) Previous value for element of G whose zero search is
   active.
 GS     (</em>IVAMC) Integration coefficients used in estimating errors.
 GT     (formal) in <em>IVAG.  Previous value of GNEW.
 HC     (</em>IVAMC) Ratio of (new step size) / (old step size)
 HDEC   (<em>IVAMC) Default value to use for HC when reducing the step
   size.  (Values closer to 1 may be used some of the time.)
 HH     Equivalenced to G(1,1) = current step size in </em>IVAA,CR,DA,G,HC.
 HI     (<em>IVAIN) Step length from the base value of the independent
   variable for the interpolation.
 HINC   (</em>IVAMC) Default value to use for HC when increasing the step
   size.  (Values closer to 1 may be used some of the time.)
 HINCC  (<em>IVAMC) Actual value used for default value of HC when
   increasing the step size.  Set to HINC after start is considered
   complete.  During the start HINCC is set to 1.125.
 HMAX   (</em>IVAMC) Largest value allowed for abs(step size).  Default
   value is a very large number.
 HMAXP9 (<em>IVAMC) .9 * HMAX.
 HMIN   (</em>IVAMC) Smallest value allowed for abs(step size).  Default
   value is 0.
 HNEW   (<em>IVADE) Value of step size when iterating at initial point
   for delay differential equations.
 I      Used for temporary storage. (</em>IVAA,BU,CR,DA,DE,G,IN,OP,PR)
 IA     (<em>IVAOP) absolute value of first integer stored for an option.
 ICF    (</em>IVAMC) Final index for current loop in <em>IVACR.  Required by
   option 18.
 ICI    (</em>IVAIN) Temporary index, = 0 for interpolation, 1 or 0 for
   differentiation, and d-1, d-2, ... 0 for integration, where d is the
   order of the differential equation.  Index of first location
   in C() used is ICI + an offset.
 ICS    (<em>IVAMC) Starting index for current loop in </em>IVACR.
 ID     (formal) Array use to contain integer data from common.  Values
   are returned in locations 1 to 5 as follows.
   1    KEMAX = Index of equation with largest error estimate
   2    KSTEP = Current step number
   3    NUMDT = Number of differences used for each equation
   4            Reserved for future use
   5            Reserved for future use
 IDAT   (<em>IVAMC) Used to store integer for error messages.  (Also used
   in </em>IVAA for temporary storage of KORD(2).  (Local array in <em>IVAIN.)
 IDE    (</em>IVADE - formal) Array used to contain past information so
   that delays can stretch back indefinitely.  If the first location is
   0, then any interpolations requested must be in the range of the
   current difference tables.  At present, only the value 0 is allowed
   in IDE(1).  This array is intended for the support of saving long
   past histories.  IDE(2) must contain the declared dimension of WDE.
 IDEF   (<em>IVADE -- formal) Flag giving indicaion of what is going on.
   = 0  User should compute derivatives and return to the main
        integrator.
   = 1  Code is computing additional values in order to get past data
        necessary for starting.  User should compute derivatives and
        call </em>IVADE.
   &lt; 0  Indicates an error condition.  If <em>IVADE is called without
        changing the value of IDEF, the integration is stopped and an
        error message printed.  Possible error flags are:
    -1  Difference tables do not span back far enough to compute the
        past values of Y needed.
    -2  There is not enough space in WDE to get the required starting
        values.
 IDIMF  (formal) Declared dimension of F().
 IDIMK  (formal) Declared dimension of KORD().
 IDIMT  (formal) Declared dimension of TSPECS().
 IDIMY  (formal) Declared dimension of Y().
 IDT    (</em>IVAIN) Used as a base index into the difference table.
 IFLAG  (formal in <em>IVAG) Used for communication with user.
   = 1  Continue as if </em>IVAG was not called.
   = 2  Check KORD(1) as one would do at start of OUTPUT if no G-Stops
        were present. (Exit if in DERIVS.)
   = 3  Return to the integrator.
   = 4  Compute G and return to <em>IVAG.
   = 5  A G-Stop has been found, and NSTOP gives its index.  (If NSTOP
        &lt; 0, the stop was an extrapolating stop.)
   = 6  Same as 5, but requested accuracy was not met.
   = 7  Same as 5, but there is a probable error in computing G.
   = 8  Fatal error of some type.  (An error message has been printed.)
 IG     (</em>IVAG)  IG = KORD(2) on the initial entry (0 for extrapolating
   G-Stops, and 1 for interpolating).
 IGFLG  (<em>IVAMC) Used primarily in </em>ivag, but also used in <em>iva to keep
   track of the state of GSTOP calculations.
   = -2 Extrapolatory G's initialized, but not the interpolatory.
   = -1 Interpolatory G's initialized, but not the extrapolatory.
   =  0 Set when integration is started or restarted, or option setting
        GSTOP is set.
   =  1 Iterating to find a GSTOP.
   =  2 User told that a GSTOP was found.
   =  3 Checking G's at point where a GSTOP was located.
   =  4 Checking G's at a T output point.
   =  5 Usual case, no sign change detected.
 IGSTOP (</em>IVAMC) IGSTOP(k) is set in <em>ivag to the index of the last G
   with a 0, where k is one for an interpolatory G-Stop, and k is two
   for an extrapolatory G-Stop.
 IGTYPE (</em>IVAMC) Array with two elements as for IGSTOP, but this saves
   a flag giving the nature of convergence to the stop.
   = 0  All known G-stops completely processed.
   = 4  Need to compute next value while iterating.
   = 5  Got good convergence.
   = 6  Got convergence, but not to desired accuracy.
   = 7  Problem in getting convergence.
   = 8  A fatal error of some type.
 IHI    (<em>IVA) Last location used by the current option.
 ILGREP (</em>IVAMC) Used when correction to keep track of equations that
   are to use a certain error tolerance.
 ILGROR (<em>IVACR) Index of last equation in the current group of
   equations grouped for selecting integration order.
 ILOW   (</em>IVA) First location used by the current option.
 INCOM  (<em>IVADE) Array equivalenced to LDT in the common block </em>IVASC.
   Used to simplify saving information in the common block.
 INCOP  (<em>IVAOP) Array containing data giving the amount of space in
   IOPT used for each of the options.
 INGS   Current index for G-stop being examined in DIVAG.
 INICAS (</em>IVADE) Used to track the initialization for a delay equation.
   = 1  Very beginning.
   = 2  Getting derivative at the very beginning.
   = 3  Getting derivatives at points prior to the initial point.
   = 4  Getting derivative at initial point after iteration is started.
 INTCHK (<em>IVA) Array passed to OPTCHK containing information on storage
   allocation.  See comments in OPTCHK for details.
 INTEG  (</em>IVAIN) Number of integrations being done. (&lt;0 for
   differentiations and =0 for interpolation.)  Also used as counter
   when computing integration coefficients.
        (<em>IVAPR) Number of integrations being done.
 INTEGS (</em>IVAPR) = -1 for equations that are not stiff, 0 for those
   that are stiff.
 INTEGZ (<em>IVAIN) min(INTEG, 0)
 INTERP (</em>IVAIN) added to the usual integration order to get the order
   to be used when interpolating: 3-KQMAXI, if HI=0; 1, if
   |HI| &gt; |XI(1)| and HI * XI(1) &lt; 0; 0, otherwise -- the usual case.
 IOP10  (<em>IVAMC) Number of times diagnostic output is to be given when
   leaving </em>ivacr (the corrector).
 IOP11  (<em>IVAMC) Gives current step number of the method.  Tells how
   many of certain coefficients must be computed. (Has nothing to do
   with options.) = min(max integ order + 1, KDIM).  Also set when
   starting to flag that certain memory locations must be set to 0.
 IOP12  (</em>IVAMC) Points to location in F() where user supplied values
   of HINC, HDEC, HMIN, and HMAX.  (0 if option 12 not used.)
 IOP13  (<em>IVAMC) If not zero, reverse communication will be used for
   getting the values of derivatives.  Associated with option 13.
 IOP14  (</em>IVAMC) If not zero, reverse communication will be used in
   place of calls to the output routine.  Associated with option 14.
 IOP15  (<em>IVAMC) If not zero, a return will be made to the user after
   the initialization.  Associated with option 15.  This might be used
   to overlay </em>iva, some of the user's code, and perhaps <em>ivaop.
 IOP16  (</em>IVAMC) Points to location in KORD() where information for
   specifying the error tolerance is specified.  See option 16.
 IOP17  (<em>IVAMC) Used in initialization for option 17, afterwards this
   cell is used by KEXIT which is equivalenced to IOP17.
 IOP18  (</em>IVAMC) Points to location in KORD() where information for
   specifying a grouping of equations for derivative evaluation is
   stored.  See option 18.
 IOP19  (<em>IVAMC) Points to location in KORD() where information for
   specifying a grouping of equations for integration order control
   is stored.  See option 19.
 IOP20  (</em>IVAMC) Used for option 20, gives first location in F where
   estimated errors are to be stored.  Expected to be useful in a
   program for solving boundary value problems using multiple shooting.
 IOP21  (<em>IVAMC) Was used for stiff equations option (never completely
   coded).  The optional code still uses this (don't activate it!).
   Now used to flag the location if F where the user has stored the
    tolerance to use in finding G-Stops.
 IOP21S (</em>IVAMC) Was used for stiff equations see above.
 IOP22  (<em>IVAMC) Set aside for possible option for stiff equations.
 IOP3   (</em>IVAMC) Value set by option 3.
   =  0 Interpolate to final point. (The default)
   =  1 Integrate to final point.
   = -1 Extrapolate to final point.
 IOP4   (<em>IVAMC) Value set by option 4.  The output routine is called
   with KORD(1) = 4, every IOP4 steps.  (Default value for IOP4 is a
   very large number.
 IOP5   (</em>IVAMC) Value provided by option 5, used to specify extra
   output points.
 IOP6   (<em>IVAMC) Value provided by option 6.  If nonzero, the output
   routine is called at the end of every step.  If &gt; 0, there are
   IOP6 interpolating G-Stops.
 IOP7   (</em>IVAMC) Value provided by option 7.  If &gt; 0, there are K7
   extrapolating G-Stops.
 IOP8   (<em>IVAMC) Value provided by option 8.  If nonzero, the output
   routine is called with KORD(1)=8 whenever the step size is changed.
 IOP9   (</em>IVAMC) Value provided by option 9.  Used to specify that the
   user wishes to save the solution.
 IOPIVA (<em>IVA) Used to save length of IOPT vector for error messages.
 IOPST  (</em>IVASC) Intended for possible use in stiff equations.
 IOPT   (formal <em>IVA and IVAOP) Used to specify options.
 IOPTC  (</em>IVAOP) In <em>IVAOP equivalenced so that IOPTC(3) is equivalent
   to IOP3.
 IOPTS  (</em>IVAOP) Array containing the current default values to be
   stored into IOPTC.
 IORD   (<em>IVACR) Index of first equation in the current group of
   equations grouped for selecting integration order.
 IOUTKO (</em>IVADC) Used in <em>IVADI to point to KORD to keep track of
   equation grouping for diagnostic output.
 ISVCOM (</em>IVADE) Used to save info. in the common block <em>IVASC.
 ITERS  (</em>IVADE) Counts iterations in starting delay differential
   equations.  Max. value for this is arbitrarily 100.
 ITOLEP (<em>IVAMC) Used for temporary storage, and for the index of a
   tolerance relative to the start of tolerances.
 IVC1   (</em>IVADB) Array used for output of variables IOPST to NUMDT in
   common block <em>IVASC.
 IVC2   (</em>IVADB) Array used for output of variables ICF to NY in
   common block <em>IVAMC.
 IWB    (</em>IVADE) Current base index for saving F values in WDE when
   starting delay differential equations.
 IY     (<em>IVAMC) Used for the current index to the Y() array.  (Local
   variable in </em>IVAIN used in computing IYI.)  Equivalenced to
   IZFLAG in <em>IVAG.
 IYI    (</em>IVAIN) Y(IYI) is currently being computed.
 IYN    (<em>IVAIN) Y(IYN) is base Y() corresponding to Y(IYI).
 IYNI   (</em>IVAIN) Used as base index for computing IYN as IY is for INI.
 IYO    (<em>IVADE) Points to first base value of Y for current
   interpolation when getting values for a delay differential equation.
 IZFLAG (</em>IVAG)  Equivalenced to IY.  Set to 0 initially, and later
   set to the value returned by <em>ZERO.
    = 0  Value set on entry at start of search.
    = 1  Compute next g again.
    = 2  Normal terminiation.
    = 3  Normal termination -- error criterion not satisfied.
    = 4  Apparent discontinuity -- no zero found.
    = 5  Couldn't find a sign change.
    = 6  </em>ZERO was called with a bad value in IZFLAG.
 J      For temporary storage. (In <em>IVA,A,BU,CR,DA,DB,DE,HC,IN,OP,PR)
 J1     (</em>IVAA &amp; DA) Used for temporary storage.
 J2     (<em>IVAA) Used for temporary storage.
 JL     (</em>IVA) Used for checking storage.
 JLGREP (<em>IVACR) Contents of first location of KORD (called LGROUP in
   </em>IVACR) for the current error tolerance rule.
 JLGROR (<em>IVACR) Contents of first location of KORD for the current
   integration order control.
 JLIM   (</em>IVA) Used for checking second item in KORD list for options
   16 and 19.
 K      For temporary storage.  (In <em>IVA,A,BU,CR,DA,DB,DE,HC,IN,OP,PR)
 KDIM   Parameter giving the largest number of differences supported.
        Used in all the routines.
 KEMAX  (</em>IVAMC) Index associated with equation giving the largest
   value for (estimated error) / (requested error).
 KEXIT  (<em>IVAMC) Equivalenced to IOP17 which is not used after
   initialization.  Defines actions when KORD2I = -7.  (Referenced in
   (</em>IVAA,DA,G).)
   =  1  Take the step over with reduced H.
   =  2  Take the step over.
   =  3  Do the end of step call to OUTPUT.
   =  4  Reset TMARK, then do same as for KEXIT = 2.
   =  5  Reset TMARK, then do same as for KEXIT = 3.
   =  6  Give the fatal error diagnostic.
 KFERR  (<em>IVA)  Temporary storage in checking for option 16.
 KGO    (</em>IVA)  Used to tell from whence a check is being done or an
   error message is being written.
   = 1 Checking an equation group for variational equations.
   = 2 Checking an equation group for diagnostic print.
   = 3 Checking an equation group for integration order control.
   = 4 Checking an equation group for error control.
   = 5 Checking an equation group for specifying ODE orders.
   = 6 Found a problem with output type for printing.
   = 7 Found a problem with an output group for printing.
   = 8 Found a problem with input NEQ.
   = 9 Order specified for the ODE's in the system is out of range.
   =10 Option 16 was not used (an error).
   =11 Error tolerance of 0 specified without proper flags.
 KIS    (<em>IVAMC) Used to check if it is time to dump the solution.
   The check involves incrementing KIS at the end of the step, and
   dumping the solution if KIS is 0.
   = -1  Set in </em>ivacr when it is time to dump solution
   =  0  When starting
   =  2  After being dumped.
   This is set to 1000 just after a user specified discontinuity, and
   counted up from that point.
 KMARK  (<em>IVAMC) Identifies the type of output associated with the next
   output point specified by TSPECS.
 KONV   (</em>IVADE) Counts iterations.  Test for convergence if KONV &gt; 1.
 KORD   (formal in <em>IVA,A,BU,CR,DA,DB,DE,G,IN,PR) KORD(1) is used to
   return flags for the user to test, and KORD(2) tells what routine
   the flag is associated with.  See KORD1I and KORD2I below and the
   write up for the program.  KORD(3) is used for communicating extra
   information to the user in some cases.  KORD(4) to KORD(NTE+3) are
   used for integration order for the equations, and the rest of KORD()
   is available for user options.
 KORD1I (</em>IVAMC) Helps in defining the state of the integrator.
   Frequently has the same value as KORD(1).  Meaning depends on the
   value of KORD(2), or the value about to be assigned to KORD(2).
   &lt;  0  Happens when preparing to give output with extrapolation.
   =  0  Happens when checking F at points for noise test.
   =  1  (KORD(2)=-1)  End of integration has been reached.
   =  1  (KORD(2)= 0)  Computing first predicted derivative.
   =  1  (KORD(2)= 1)  Output for initial point.
   =  2  (KORD(2)=-1)  Giving diagnostic for noise limiting precision.
   =  2  (KORD(2)= 0)  Computing corrected derivative.
   =  2  (KORD(2)= 1)  Output for TSPECS(3).
   =  3  (KORD(2)=-1)  Diagnostic for step size reduction too fast.
   =  3  (KORD(2)= 0)  Computing variational derivative.
   =  3  (KORD(2)= 1)  Output for TSPECS(4).
   =  4  (KORD(2)=-1)  Error, discontinuity.
   =  4  (KORD(2)= 1)  Output for certain number of steps.
   =  5  (KORD(2)= 0)  Get initial derivatives for stiff equations.
   =  5  (KORD(2)= 1)  Extra output from TSPECS.
   =  6  (KORD(2)= 1)  End of step output.
   =  7  (KORD(2)= 0)  Evaluate G before extrapolated output point.
   =  7  (KORD(2)= 1)  Evaluate G before extrapolated output point.
                       (Also used when checking for other G's after
                        finding one.)
   =  8  (KORD(2)= 1)  Tell user step size has changed.
   =  9  (KORD(2)= 1)  Request for user to save solution.
   = 11  (KORD(2)=-1)  Error, step size too small at end of start.
   = 12  (KORD(2)=-1)  Error, step size is too small.
   = 13  (KORD(2)=-1)  Error, output points specified badly.
   = 21  (KORD(2)=-1)  H too small to give reasonable change when added
                       to T.
   = 22  (KORD(2)=-1)  Error, bad tolerance.
   = 23  (KORD(2)=-1)  Set after message for a fatal error.
   = 24  Set on error message in <em>iva, along with KORD2I = -4.
   Also used as an index into MLOC in </em>IVAA when an error is being
   processsed, see MLOC below.
 KORD2I (<em>IVAMC) Helps in defining the state of the integrator.
   Frequently has the same value as KORD(2).
   = -3  Set in </em>ivag, to get a derivative evaluation.
   = -2  Set in <em>ivag, to get another entry to OUTPUT.
   = -1  Return to calling program, done, interrupt, or got an error.
   =  1  Calling OUTPUT or returning to user for OUTPUT type action.
   =  0  Calling DERIVS or returning to user for DERIVS type action.
   = -4  Error message in </em>iva and in <em>ivaop, along with KORD1I = 24.
   = -5  Starting
   = -6  Starting, getting the initial derivative value or derivatives
         for the noise test.
   = -7  Done some extrapolation, KEXIT defines the action to take.
         Set in </em>ivag to activate KEXIT action in <em>iva.
   = -8  Set when user has requested adjustment of the difference
         tables for a discontinutiy.
 KORDI  (</em>IVASC) Order of differential equation being integrated.  If
   all orders are the same, this set once at the beginning.
 KOUNT   (<em>IVADE) Count of number of points back from the initial point
   when solving a delay differential equation.
 KOUNTM  (</em>IVADE) Largest value currrently allowed for KOUNT.
 KOUNTX  (<em>IVADE) Largest value allowed for KOUNTM.
 KOUTKO  Used in DIVACR to track where output is wanted.
 KPRED  (</em>IVAMC) Value assigned to KORD1I when getting a predicted
   derivative.  (1 used now, 5 planned for use with stiff equations.)
 KQD    (<em>IVACR) = max(2, integration order)
 KQDCON (</em>IVAMC) Number of coefficients computed with constant step
   size for stiff equations.
 KQICON (<em>IVAMC) Number of coefficients computed with constant step
   size for nonstiff equations.
 KQL    (</em>IVACR) Integration order at start of (<em>IVACR)
 KQLORD (</em>IVACR) Saved value of KQL when equations are grouped for
   controlling the integration order.
 KQMAXD (<em>IVASC) Maximum integration order used for stiff equations.
 KQMAXI (</em>IVASC) Maximum integration order used for nonstiff equations.
 KQMAXS (<em>IVAMC) Maximum integration order for equations that have
   some limit on the error that can be committed.
 KQMXDS (</em>IVAMC) Used to save KQMAXD in case step is repeated and the
   solution must be dumped.
 KQMXI  (<em>IVAIN) Maximum integration order used for integration or
   interpolation, = KQMAXI+INTERP-1.
 KQMXS  (</em>IVAIN) Maximum step number, = max(KQMXI, KQMAXD).
 KQMXIL (<em>IVAMC) Value of KQMAXI the last time integration coefficients
   were computed.
 KQMXIP (</em>IVAMC) = KQMAXI + MAXINT, for computing integration coeffs.
 KQMXIS (<em>IVAMC) Used to save KQMAXI in case step is repeated and the
   solution must be dumped.
 KQN    (</em>IVACR) Value of integration order at end of <em>IVACR.
 KQQ    Used for the integration order for current equation.  (Values
   &lt; 0 are intended for stiff equations.)  (In </em>IVA,BU,DA,IN,PR)
 KSC    (<em>IVAMC) Number of steps that have been taken with a constant
   step size.
 KSOUT  (</em>IVAMC) When KSTEP reaches this value, the output routine is
   called with KORD(1) = 4.  The default value is a very large number.
 KSSTRT (<em>IVAMC) Set when ending one derivative per step to KSTEP + 2.
   Checked later in </em>IVAHC to decide whether to set the step changing
   factors to their nominal values.
 KSTEP  (<em>IVAMC) Number of steps taken since the start of integration.
 L      Used for temporary storage.  In </em>IVAIN, L is the initial value
   of LDT, except L=1 if LDT=-1, and MAXINT .ge. 0.  (Used in <em>IVAA,BU
   CR,DA,DB,IN,PR.)
 LAHAG  (</em>IVADB) Used to get proper offset into an diagnostic message.
 LAIAG  (<em>IVADB) Used to get proper offset into an diagnostic message.
 LDIS   (</em>IVAA) Count of steps since user flagged a discontinuity.
 LDT    (<em>IVASC) Used to keep track of state of difference table.
   = -5  Used only on first step to indicate that an extra iteration
         is desired to get a firm estimate on the error.
   = -4  Set on initialization before there is any difference table.
   = -3  Set just after predicting, interpolation is not allowed when
         this value is set.
   = -2  Set when difference table is to be updated to the end of the
         current step, but no interpolation is to be done.  (For
         dumping the solution.)
   =  0  Calculations for current step are complete, it is not o.k. to
         update the difference table.
   =  1  Difference table has been updated to the end of the current
         step, e.g. by doing an interpolation.
   =  2  Set when doing a special interpolation during computation of
         derivatives.  (For delay equations.)
 LEX    (</em>IVAMC) Indicates how to get values at next output point:
   = -1  Extrapolate
   =  0  Interpolate (The usual case.)
   =  1  Integrate to the output point, integration is not continued.
 LGO    (<em>IVAIN) Used as an an assigned go to.  Result is to add in
   extra correction term when LDT has been set to 2.
 LGROUP (formal) This is a part of KORD passed into </em>IVACR.  The first
   location is the start of the information on the grouping of
   equations for error control.
 LINC   (*IVAMC) Used to indicate state of step size selection.
   = -10 After computed derivatives at base time, after computing other
         extra derivatives for the noise test.
   = -9  After computed second extra derivative for noise test.
   = -8  After computed first extra derivative for noise test.
   = -7  Dumping the solution and then doing a user initiated restart,
         or getting ready to compute extra derivatives for the noise
         test.
   = -6  Dumping the solution before a restart.
   = -5  Set on the first step, and also set when dumping the solution
         after a discontinuity.
   = -4  Repeat step with no change in the step size.
   = -3  Set when the error tolerance is set improperly.
   = -2  User has complete control of selecting the step size.
   = -1  Step is being repeated.
   =  0  Step size is not to be increased on this step.
   = k&gt;0 Step size can be increased by HINCC</strong>k.
 LINCD  (<em>IVAMC) Value of smallest k for which HINCC</em><em>k .ge. 2.
   (=-2 if user is specifying all step size changes.)
 LINCQ  (</em>IVAMC) Value of smallest k for which HINCC<strong>k .ge. 4.
 LIOPT  (<em>IVAOP) Value of the last index in IOPT on the last call.
   Used so </em>IVA can print IOPT in error messages.
 LL     (<em>IVACR) Temporary variable used when equations are grouped
   for integration order control.
 LNOTM1 (</em>IVAIN) Logical variable = L .ne. -1.  If LNOTM1 is true,
   storage in Y() is different in some way lost to antiquity.  Such
   a case can only arise in the case of stiff equations.
 LOCF1  (<em>IVADB) Gives packed data needed for output of tables by the
   message processor MESS.  See comments there under METABL for defs.
 LOCF2  (</em>IVADB) As for LOCF1 above.
 LOCM   (<em>IVAA) Parameter = 32</em>256, used to unpack integers stored
   in MLOC for use in error message processing.
 LPRINT (formal, <em>IVADB) Defines how much printing is to be done in
   </em>IVADB.  Let |LPRINT| = 10<em>N1 + N2     (N1,N2 digits)
    N1=1   Do not print any variables external to the integrator.
    N1=2   Print  tspecs, current y, past y, current f, all pertinent
           contents of KORD, and TOL.
    N1=3   Above + difference tables up to highest difference used.
    N1=4   Same as N1=1 + all in storage allocated for differences.
    N2=1   Do not print any variables internal to the integrator.
    N2=2   Print all scalar variables in interpolation common block.
    N2=3   Above + all scalar variables in main integ. common block.
    N2=4   Same as N1=3 + all used in arrays XI,BETA,ALPHA, first
           column of G, GS,RBQ,SIGMA
    N2=5   Same as N1=4 + all used in arrays G,D,DS,V
 LSC    (</em>IVAMC) Indicates if starting or if noise may be present.
   =k&lt;0 -k steps have been taken for which noise appears to be limiting
        the precision.
   = 0  Usual case
   = 1  Doing 1 derivative per step after initial part of start.
   = 2  Used as flag that it is time to set LSC=0.
   = 3  Third step, hold the order constant.
   = 4  Second step, increase orders from 2 to 3.
   = 5  First step, third time through the first step (if required).
   = 6  First step, second time through.
   = 7  First step, first time through.
   = 8  Set on initialization.
 LTXT?? Names of this form are used in setting up data statements for
   error messages.  These names are generated automatically by PMESS,
   the program that makes up these messages.
 LX     (<em>IVAA) Used for temporary storage in computing TMARKA().
        ( formal </em>IVADE)  An integer array containing extra
   information, as follows.
  LX(1) Points to a location in Y beyond those already in use.  Values
        of Y requested are computed at TSPECS(1) - Y(LX(1)) and stored
        starting at Y(LX(1)+1).  If this index is 0, no more extra Y
        values are to be computed.
  LX(2) Index of the first equation for which the Y's above are to be
        computed.  Y(LX(1)+1) will correspond to this first equation
        index.
  LX(3) Index of the last equation for which the Y's above are to be
        computed.  Thus the Y's stored starting at Y(LX(1)+1) will
        require no more space than half the space ordinarily required
        for the array Y(), and may require significantly less.
  LX(4) Maximum number of times to integrate F to get Y.  This should
        be &gt; 0, and less than or equal to the order of the highest
        order differential equation.  (= 0 is allowed, but probably
        not what you want.  It would give a value only for F.)  Space
        must be set aside for all integrals of F, even if not all are
        requested.  For a first order system, all Y's are just the
        first integrals of the corresponding F's.  For higher order
        equations, the first Y associated with a given F is the d-th
        integral of the corresponding F, where d is the order of the
        equation, and the last Y corresponding to the F is the first
        integral of that F.
  LX(5) As for LX(4), but gives the index for the fewest number of
        times to integrate F.  Ordinarily this should be &gt; 0.  If 0 is
        requested, an estimate for the value of F at the delay point is
        computed.  This should not be 0 more than once, for equations
        covering the same index, since later such requests would write
        over the earlier results.
  LX(5i+k) , k = 1, 2, ... 5.  Treated as for the cases above.  If i
        different cases of delayed Y's are to be computed, then
        LX(5i+1) must be 0.
 LX2    (<em>IVADE) Value of LX(5i+2), when working on the i-th delay.
 MACT   Used in the programs which call the error message program.
   This array difines the actions to be taken by that program.  (In
   (</em>IVA,A,DA,DE,G,IN,OP)
 MACT0  (<em>IVADB) Used to call the message program, see MACT.
 MACT?  As for MACT, in (</em>IVA,CR,DB)
 MACTFV (<em>IVADB) As for MACT0.
 MAXDIF (</em>IVASC) Maximum differentiations required for stiff equations.
 MAXINT (<em>IVASC) Maximum integrations required.  (= max. order of
   differential equations if equations are not stiff.)
 MAXKQ  (</em>IVA, BU)e
 MAXKQD (<em>IVAMC) Largest integration order allowed for stiff equations.
 MAXKQI (</em>IVAMC) Largest integ. order allowed for nonstiff equations.
 ME???? Parameters defining constants used for interaction with the
   error message program MESS.  See comments there for definitions.
   (In <em>IVA,A,DA,DE,G,IN,OP)
 METHOD (</em>IVAMC) Defines kind of methods being used.
   = -1  Only stiff equations are being integrated.
   =  0  Only nonstiff equations are being integrated.
   =  1  Both kinds of methods are required.
 MLOC   (<em>IVA,A,DE) Contains locations in MTEXT for error messages.  In
   </em>IVAA this data is packed using MLOC??, see below.
 MLOC?? (<em>IVAA) Parameters constructed to aid in making up packed data
   for processing error messages.  Low two digits give the value of
   KORD1I to use for the error index and later processing, the next two
   give the error severity level, and the rest point to text used for
   the message.
 MODF2  (</em>IVADB) Used in constructing the same kind of packed data as
   described for LOCF1 above.
 MULTJ  Local to DIVAOP for calls not using F.
 MTEXT  (<em>IVA,A,CR,IN,OP) Text for error messages.
 MTXT?? (</em>IVA,A,CR,DA,DB,DE,G,IN,OP) Equivalenced into MTEXT.
 N      Used for temporary storage.  (In <em>IVAHC,IN,PR)
 NDTF   (</em>IVASC) Location in F() where difference table starts.
 NE     (<em>IVAMC) Number of equations in the first group.  (=NTE if
   option 18 is not used.)
 NEDDIG (</em>IVADB) Parameter = -MEDDIG.
 NEPTOL (<em>IVAMC) Used for temporary storage and to save the value of
   ITOLEP for error messages.
 NEQ    (formal) Total number of equations being integrated.
 NG     (</em>IVAMC) Used in <em>ivag for the number of g's in the current
   context.
 NGSTOP (</em>IVAG) Dimension 2 array equivalenced to IOP6, and IOP7.  To
   get the number of interpolating and extrapolating G-Stops.
 NGTOT  (<em>IVAMC) NGTOT(1) gives the number of interpolating G-Stops,
   and NGTOT(2) gives the number of extrapolating G-Stops.
 NKDKO  (</em>IVASC) If this is nonzero (option 17), it gives the location
   in KORD() where a vector defining the order of each equation is
   specified.
 NLX    (<em>IVADE) Temporary index used to keep track of interpolations
   being done to get Y() values for a delay differential equation.
 NOISEQ (</em>IVAMC) max(2, order of equation for which (error estimate)/
   (error requested) is a maximum).
 NOUTKO (<em>IVAMC) If nonzero, gives the index in KORD where information
   on what equations are to be included in the diagnostic output is
   given.   See option 10.
 NSTOP  (formal) In </em>IVAG.  Index of the G-stop, see IFLAG.
 NTE    (<em>IVASC) Total number of equations being integrated = NEQ.
 NTEXT  (formao </em>IVADB) Character variable containing heading text.
 NTOLF  (<em>IVAMC) First location in F() where tolerance specifying
   accuracy desired is stored.
 NUMDT  (</em>IVASC) Maximum allowed number of differences available for
   doing an integration.
 NXTCHK (<em>IVA) Equivalenced to INTCHK(1), which gives the next
   available location in INTCHK for storing data on storage allocation.
 NY     (</em>IVAMC) Total order of the system.
 NYNY   (<em>IVASC) Location in Y() where the base value for Y() is saved.
 NYNYO  (</em>IVADE) Equivalenced to the saved value from common of NYNY.
 OUTPUT (formal) Name of subroutine to be called for the output of
   data or for computing G-Stops.  Not used if option 14 is set.
 OVD10  (<em>IVAEV) (largest floating point number) / 10.
 OVTM75 (</em>IVAEV) (largest floating point number) </strong> (-.75)
 RBQ    (<em>IVAMC) Array containing data for the preliminary noise test.
 RD     (formal </em>IVACO) Array use to contain floating point data from
   common.  Values are returned in locations 1 to 3 as follows.
   1    EMAX =  Max. ratio of estimated error to requested error
   2            Reserved for future use
   3            Reserved for future use
 REF    (<em>IVACR) Array of length 3 used for translating error tolerance
   type into the factor used for exponential averaging for that type.
 RND    (</em>IVACR) Usually the current estimated error.  Used in deciding
   if noise is limiting precision.
 RNOISE (<em>IVACR) Value used in comparison with RBQ() for preliminary
   noise test.
 ROBND  (</em>IVAMC) Used to influence the selection of integration order.
   The larger ROBND, the harder it is to increase the order and the
   easier it is to decrease it.
 RVC2   (<em>IVADB) Array used for output of variables DNOISE to SNOISE in
   common block </em>IVAMC.  These are variables that don't require a great
   deal of precision.
 S      (<em>IVACR) Estimate of (step size) * eigenvalue of Jacobian.
 SIGMA  (</em>IVAMC) The k-th entry of this array contains a factor that
   gives the amount the k-th difference is expected to increase if the
   step size in increased.  These numbers get bigger it there is a past
   history of increasing the step size.
 SIGMAS (<em>IVAA) Saved value of SIGMA(k) from the last step, where k =
   integration order for equation with index KEMAX.
 SNOISE (</em>IVAMC) Value used in comparison with RBQ() on equation with
   largest value for (error estimate) / (error requested).
 T      (formal) in <em>IVAIN. T(1) contains the point to be interpolated
   to, and T(2) is used in a check that |HI| .le. |T(2)|.  When used by
   other routines in this package, TSPECS is passed in for T.
 TB      (</em>IVADE) Base time for current interpolation.
 TC      (<em>IVADE) Original value of TN when getting past Y's for a
   delay differential equation.
 TEMP   Used for temporary storage, in </em>IVAHC,PR
 TEMPA  (<em>IVACR) Array equivalenced to (TPS1,TPS2,TPS3,TPS4).
 TEMPAO (</em>IVACR) Array used to accumulate values in TEMPA.
 TG     (<em>IVAMC) TG(1) gives the last value of TSPECS(1) for which an
   interpolatory G-Stop has been computed.  TG(2) is defined similarly
   for extrapolatory G-Stops.
 TGSTOP (</em>IVAMC) TGSTOP(1) gives the value of TSPECS(1) where the last
   0 for an interpolatory G-Stop was found.  TGSTOP(2) is defined
   similarly for extrapolatory G-Stops.
 TMARK  (<em>IVAMC) Location of the next output point.
 TMARKA (</em>IVAA)  Array of length 2 equivalenced to TMARK (and TMARKX).
 TMARKX (<em>IVAMC) Location of the next output point to be found using
   integration or extrapolation.  This variable must follow immediately
   after TMARK in the common block.
 TN     (</em>IVASC) The value of TSPECS(1) at the conclusion of the last
   step.
 TNEQ   (<em>IVADB) Array of dimension 1 equivalenced to TN so that an
   array can be passed to </em>MESS.
 TOL    (formal) This is a part of F passed into <em>IVACR.  The first
   location is the start of the information on the tolerances for error
   control.
 TOLD   (</em>IVAG) Value of TSPECS(1) on one side of a zero.
 TOLG   (<em>IVAMC) Tolerance to pass to dzero when locating G-Stops.
 TOUT   (</em>IVAMC) Location of next output point defined by value of
   TSPECS(3).  Such output is given with KORD(1) = 2.
 TP     (<em>IVA,A,DA,DE,HC) Used for temporary storage.
 TP1    (</em>IVAA,DA,HC,IN,PR) Used for temporary storage.
 TP2    (<em>IVAA,DA,HC,PR) Used for temporary storage.
 TP3    (</em>IVAA) Used for temporary storage.
 TPD    (<em>IVABU) Used for temporary storage.
 TPP    (</em>IVACR) Used for temporary storage.  Usually same as TPS3.
 TPS1   (<em>IVAA,CR) Used for temporary storage.  (In </em>IVACR is the
   difference of order KQQ-2)
 TPS2   (<em>IVAA,CR) Used for temporary storage.  (In </em>IVACR is the
   difference of order KQQ-1)
 TPS3   (<em>IVACR) Contains the difference of order KQQ.  This is the
   last difference used in the corrector.
 TPS4   (</em>IVACR) Contains the difference of order KQQ+1.
 TPS5   (<em>IVACR) Temporary storage.
 TPS6   (</em>IVACR) Temporary storage.
 TPS7   (<em>IVACR) Temporary storage.
 TSAVE  (</em>IVAG) Value of TSPECS(1) before starting the search for a 0.
 TSPECS (formal <em>IVA,A,DB,DE,G)
   TSPECS(1) is the current value of the independent variable.
   TSPECS(2) is the current value of the step size.
   TSPECS(3) is the increment to use between output points that give
             output with KORD(1) = 2.
   TSPECS(4) is the "final" output point.
 V      (</em>IVAMC) Array used in computing integration coefficients.
 XI     (<em>IVASC) XI(K) = TSPECS(1) - value of TSPECS(1) K steps
   previous.
 W      (</em>IVAHC) Array used in computing integration coefficients.
 WDE    (formal, <em>IVADE)  Array used for working storage.  This storage
   is used to save derivative values when iterating to get started.  To
   be safe one should allow as much space as is allowed for differences
   in F.  In most cases the start will not require this much space
   however.  This array is also intended for the support of saving long
   past histories.
 Y      (formal, </em>IVA,A,CR,DA,DB,DE,G,IN,PR) Array containing the
   independent variable and all derivatives up to order one less than
   the order of the differential equation.  Also use to save these
   values at the beginning of the current step, the base values.
 YN     (formal, in *IVAPR)  Base values of y, these follow the
   current values of the dependent variable, y, in Y().</p>
<p>++S Default KDIM = 16
++  Default KDIM = 20
++  Default MAXORD = 2, MAXSTF = 1
++  Default INTEGO, VAREQ, OUTPUT, DUMP, GSTOP, EXTRAP
++  Default STIFF=.F., ARGM=.F., ERRSTO=.F.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-divaf"></span>real</td>
  <td></td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>DIVAF</strong></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-divao"></span>real</td>
  <td></td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>DIVAO</strong></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-idimt"></span>integer</td>
  <td></td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>IDIMT</strong></td><td><blockquote>
<p>2015-03-15 DIVA  Krogh  Removed extra call divabu after noise test
2015-03-15 DIVA  Krogh  Forced restart needs more reduction in h.
2010-02-20 DIVA  Krogh  Fixed calling DIVAOP with array other than F.
2009-11-03 DIVA  Krogh  Added option 11, more variables initialized.
2009-10-30 DIVA  Krogh  Gave KSSTRT and ROBND initial values.
2009-10-30 DIVA  Krogh  Fixed reference to undefined location in F.
2009-10-21 DIVA  Krogh  Got rid of NaN in diag. print when LSC=3.
2009-10-15 DIVA  Krogh  A few changes on how noise is handled.
2002-11-12 DIVA  Krogh  Fixed problem integrating to final output pt
2002-08-29 DIVA  Krogh  Added test for invalid HMIN/HMAX.
2002-07-26 DIVA  Krogh  Added KOUTKO to fully support Option 10.
2002-05-14 DIVA  Krogh  Fix starting prob. for Option 18.
2002-05-13 DIVA  Krogh  Put exponent letter in  numbers missing them
2002-05-12 DIVA  Krogh  Added error message for bad option 5 usage.
2001-09-07 DIVA  Krogh  Changes to allow user tol on G-Stops.
2001-05-25 DIVA  Krogh  Minor change for making .f90 version.
2001-05-18 DIVA  Krogh  Less computing with no error test
2001-05-17 DIVA  Krogh  Fixed so with no error test can't start dump
2001-04-24 DIVA  Krogh  Inserted comments from ivacom.
2000-12-01 DIVA  Krogh  Removed (some of) unused C1, MAXSTF, METEXT.
1999-12-28 DIVA  Krogh  Saved S in DIVACR for output consistency.
1999-08-19 DIVA  Krogh  Removed superfluous test above label 3520.
1997-04-22 DIVA  Krogh  Got rid of assigned go to's. F=0 if diag.
1996-08-26 DIVA  Krogh  Initialize F to 0 if dumping solution.
1996-08-23 DIVA  Krogh  Print TN not TSPECS(1) in error messages.
1996-05-30 DIVA  Krogh  Changed DERIVS/OUTPUT to  DIVAF/DIVAO.
1996-04-27 DIVA  Krogh  Changes to use .C. and C%%.
1996-03-30 DIVA  Krogh  Added external statement.
1996-03-25 DIVA  Krogh  Introduced TEXT1 to comply with F77.
1996-02-27 DIVA  Krogh  Fixed so DUMP not affected by ignored eqs.
1995-12-18 DIVA  Krogh  Fixed so no solution dump on 0 length integ.
1995-11-09 DIVA  Krogh  Fixed so char. data at col. 72 is not ' '.
1995-06-19 DIVA  Krogh  Fixed prob. with discon. just after restart.
1995-05-09 DIVA  Krogh  Fixed G-Stop/discontinuity code interaction
1995-04-26 DIVA  Krogh  Use KQMAXS instead of KQMAXI when LDIS&gt;1000.
1995-04-26 DIVA  Krogh  Keep current KQL on discontinutiy.
1994-12-16 DIVA  Krogh  Fixed option 12 with K12 &lt; 0.
1994-11-11 DIVA  Krogh  Declared all vars.
1994-11-02 DIVA  Krogh  Changes to use M77CON
1994-09-08 DIVA  Krogh  Added CHGTYP code.
1994-07-11 DIVA  Krogh  Fix to get same state with/without var. eqs.
1994-03-07 DIVA  Krogh  Allow larger order in single precision.
1994-01-14 DIVA  Krogh  Minor change to allow changing TFINAL.
1993-04-27 DIVA  Krogh  Additions for Conversion to C.
1993-04-12 DIVA  Krogh  Converted to use slightly altered MESS.
1993-04-12 DIVA  Krogh  Fixed LSC so sol. saved when HMAX is small.
1992-10-13 DIVA  Krogh  Fixed G-Stop/discontinuity code interaction.
1992-09-21 DIVA  Krogh  Fixed bug in discontinuity code.
1992-09-09 DIVA  Krogh  Fixed bug - Var. Eqs. with discontinuities.
1992-08-07 DIVA  Krogh  Storage map printed only if option 10 .ne. 0
1992-07-16 DIVA  Krogh  Restored correct discontinuity code.
1992-06-16 DIVA  Krogh  Eliminate reuse of storage for option 12.
1992-04-08 DIVA  Krogh  Removed unused labels, 1020, 2120.
1992-03-30 DIVA  Krogh  Fixed bug in DIVAOP error message.
1992-03-12 DIVA  Krogh  Simplified DIVABU, more digits in B's.
1992-01-16 DIVA  Krogh  Fixed minor bug in error messages.
1991-12-03 DIVA  Krogh  Major change for improved error checks.
1991-06-17 DIVA  Krogh  Fixed bug in checking storage allocation.
1991-04-11 DIVA  Krogh  Fixed minor bug re. option 12 in DIVAOP.
1991-03-28 DIVA  Krogh  Removed check at label 650 for KORD2I&lt;0.
1991-02-08 DIVA  Krogh  Changed some floats to generics
1990-11-08 DIVA  Krogh  Fixed bug on TSPECS on discon.
1990-09-14 DIVA  Krogh  Fixed bug when discon. and sol. save.
1990-09-13 DIVA  Krogh  Increased dimension of BETA by 1.
1990-09-13 DIVA  Krogh  Added one more poss. on rel. error test.
1990-09-11 DIVA  Krogh  Recent change messed up getting dump output.
1990-06-05 DIVA  Krogh  Fixed bug in noise test, comments in IVACOM.
1990-05-08 DIVA  Krogh  Fixed new bug when TMARK hit in DIVAG.
1990-04-17 DIVA  Krogh  Fixed minor problem in DIVAIN error msg.
1990-04-10 DIVA  Krogh  Fixed interaction between discon. &amp; dump.
1990-03-23 DIVA  Krogh  Fixed bug on option "-2", see 1989-12-07.
1990-03-20 DIVA  Krogh  Fixed rarely occuring loop.
1990-01-29 DIVA  Krogh  Removed unneeded labels.
1989-12-14 DIVA  Krogh  Saved common block DIVAEV.
1989-12-07 DIVA  Krogh  Added option "2" to DIVAOP.
1989-11-09 DIVA  Krogh  Made GG a save var. in DIVAHC
1989-08-21 DIVA  Krogh  Fix out of bounds ref. to V in DIVABU
1989-07-26 DIVA  Krogh  Fix bug in initial dim. check
1989-07-21 DIVA  Krogh  Code for integrating discontinuities
1987-12-07 DIVA  Krogh  Initial code.</p>
</blockquote>
<p>--D replaces "?": ?IVA,?IVAA,?IVABU,?IVACO,?IVACR,?IVAEV,?IVAF,?IVAHC,
-- &amp; ?IVAG,?IVAIN,?IVAMC,?IVAO,?IVAOP,?IVAPR,?IVASC,?IVACE,?IVAIE,
-- &amp; ?IVAPE,?MESS</p>
<p>Note a "*" at the start of a name is used to indicate "D" for the
 double precision version and "S" for the single precision version.</p>
<p>When converting between precisions, don't forget to change the value
 of KDIM set in parameter statements in a variety of routines, and to
 adjust comments for the data statements associated with EIBND in
 <em>IVACR, and B in </em>IVAHC.</p>
<p>Entries
  <em>IVA    Main entry for starting the package.
  </em>IVAA   Main program inside the package, calls the other routines,
          and does checks for output, and noise.  Called by the user
          if reverse communication is used.
  <em>IVABU  Back ups the solution to the current base time, if a step
          that has been started must be taken over for some reason.
  </em>IVACO  Called by user to get certain information from the common
          blocks.
  <em>IVACR  Corrects the solution, estimates errors, and selects order.
  </em>IVADB  Subroutine to assist in debugging codes.  Called by user to
          get a formatted list of all the variables used in the
          integration.  Not required in usual case.
  <em>IVADE  Needed only for delay differential equations.  This is called
          by the user from the derivative subprogram.
  </em>IVAG   Required only if the user has G-Stops, i.e. places to call
          his output subroutine where certain functions have zeroes.
  <em>IVAHC  Compute coefficients that depend on the step size history.
  </em>IVAIN  Used to interpolate to arbitrary points.
  <em>IVAOP  Used to process user option requests.
  </em>IVAPR  Used to update the differences and to predict the solution
          at the end of the current step.</p>
<p>External Routines
  <em>1MACH  Not used in the Fortran 95 version.  ("</em>" is "D" for double
          and "R" for single precision.) This returns constants that
          depend on the floating point arithmetic.  Input arguments of
          1 to 4 give respectively:  underflow limit, overflow limit,
          smallest relative difference between two floating point
          numbers, and the largest relative difference between two
          floating point numbers.
 DERIVS (formal) Name of subroutine to be called for computing
  OPTCHK  Used in checking storage allocation.
  <em>MESS   Used to output error messages and diaganostic messages.
          (Just MESS if no floating point is output.)
  </em>ZERO   Called only if *IVAG is used.  Iterates to find zeros of
          arbitrary (continuous) functions.</p>
<p>Common blocks -- As a left over from the distant past, some variables
   are in common so that they would be saved.
  <em>IVAEV  Holds variables that depend on the environment.
  </em>IVAMC  The main common block for the package.
  *IVASC  The secondary common block for the package.  This contains
          variables that are required for doing interpolation and is
          separate to simplify saving the variables that are required
          when the solution is being dumped (saved).</p>
<p>Common variables and local variables
 ALPHA  (<em>IVAMC) Array with I-th entry = (current step size) / XI(I).
   Used in computing integration coefficients.
 B      (</em>IVAHC) Array used to get started on computing integration
   coefficients.  B(K) = 1. / (K<em>(K+1))
 BAKMIN (</em>IVADE) The largest delay at the initial point.
 BETA   (<em>IVAMC) Array with I-th entry = product (K=1,I-1) of
   (current (XI(K)) / XI(K) from previous step),  BETA(1)=1.  Used in
    updating the difference tables.
 C      (</em>IVAIN) Array used to hold integration/interpolation coeffs.
 C0     Parameter = 0. (in <em>IVAA,DE,CR,A,G,HC,IN,OP,PR)
 C1     Parameter = 1. (in </em>IVA,A,CR,DA,HC,IN,OP)
 C10    Parameter = 10. (in <em>IVAA,CR,OP)
 C1000  Parameter = 1000. (in </em>IVACR)
 C16    Parameter = 16. (in <em>IVAA,OP)
 C1M3   Parameter = .001 (in </em>IVAA)
 C1M5   Parameter = .00001 (in <em>IVAA)
 C1P125 Parameter = 1.125 (in </em>IVAA,HC,OP)
 C1P3   Parameter = 1.3 (in <em>IVAA)
 C1P4   Parameter = 1.4 (in </em>IVACR)
 C2     Parameter = 2. (in <em>IVAA,DE,BU,CR,IN,OP)
 C20    Parameter = 20. (in </em>IVACR)
 C2P5M3 Parameter = .0025 (in <em>IVAA)
 C4     Parameter = 4. (in </em>IVACR,OP)
 C40    Parameter = 40. (in <em>IVACR)
 C4096  Parameter = 4096. (in </em>IVAA)
 C6     Parameter = 6. (in <em>IVAA)
 C8M3   Parameter = .008 (in </em>IVAA)
 CM2    Parameter = -2. (in <em>IVACR)
 CM8    Parameter = -8. (in </em>IVACR)
 CMP5   Parameter = -.5 (in <em>IVACR)
 CMP75  Parameter = -.75 (in </em>IVAOP)
 CP0625 Parameter = .0625 (in <em>IVAA)
 CP1    Parameter = .1 (in </em>IVAA,CR,DA,HC)
 CP125  Parameter = .125 (in <em>IVACR)
 CP25   Parameter = .25 (in </em>IVAA,CR,DE,OP)
 CP3    Parameter = .3 (in <em>IVAA,OP)
 CP4    Parameter = .4 (in </em>IVAA)
 CP5    Parameter = .5 (in <em>IVAA,CR,DA,DE,HC,OP)
 CP5625 Parameter = .5625 (in </em>IVAHC)
 CP625  Parameter = .625 (in <em>IVAOP)
 CP75   Parameter = .75 (in </em>IVACR,OP)
 CP8    Parameter = .8 (in <em>IVACR)
 CP875  Parameter = .875 (in </em>IVAA, OP)
 CP9    Parameter = .9 (in <em>IVAOP)
 CP9375 Parameter = .9375 (in </em>IVACR)
 CQ3125 Parameter = .03125 (in <em>IVACR)
 CRBQI  Parameter = .421875 (in </em>IVAHC)  Initial val for computing RBQ.
 CSUM   (<em>IVAIN) Array used to contain partial sums of the integration
   coefficients.  This is used to corrrect for a difference table that
   has not yet been updated.
 D      (</em>IVAMC) Array to be used later to store coefficients for
   integrating stiff equations.
   derivatives.  Not used if option 13 is set.
 DISADJ (<em>IVAA) Value of stepsize when discontinuity is indicated.
 DNOISE (</em>IVAMC) Used in determining if noise is limiting the
   precision.  It is usually |highest difference used in correcting|
   of the equation with the largest error estimate.
 DS     (<em>IVAMC) Array to be used later to store coefficients for
   estimating errors when integrating stiff equations.
 DVC2   (</em>IVADB) Array used for output of variables HC to TOUT in
   common block <em>IVAMC.
 E      (</em>IVACR) (Estimated error) / (Requested accuracy)
 EAVE   (<em>IVAMC) This is a weighted average of past values of EIMAX.
   It is adjusted to account for expected changes due to step changes.
 EEPS10 (</em>IVAEV) = 10. * (machine epsilon).
 EEPS16 (<em>IVAEV) = 16. * (machine epsilon).
 EEPS2  (</em>IVAEV) =  2. * (machine epsilon).
 EEPT75 (<em>IVAEV) = (machine epsilon) </em><em> (.75)
 EI     (</em>IVACR) Estimate for what E would be if step size increased.
 EIBND  (<em>IVACR) Array containing limits on the estimated error with
   the stepsize increased.  This array tends to make the code a little
   more conservative on step size increases at low order.
 EIMAX  (</em>IVAMC) Estimate of (error estimate / error requested) if the
   step size should be increased.
 EIMIN  (<em>IVAMC) An error estimate is small enough to allow a step
   increase if the estimate of ((error with the step size increased) /
   (error requested)) is less than EIMIN.
 EIMINO (</em>IVAA) Set to C8M3 and never changed.  When step size is being
   reduced if EIMIN .le. EIMINO then the reduction factor is set to
   CP875.  This variable could be a parameter.
 EMAX   (<em>IVAMC) Largest value computed for (error estimate) / (error
   requested).
 EOVEP2 (</em>IVAEV) = EEPS2 * (largest floating point number).
 EPS    (<em>IVACR) Current absolute error tolerance.  Also used for
   temporary storage when computing the desired value of EPS.
 ERCOEF (</em>IVACR) (Error coefficient from formula) / EPS
 EREP   (<em>IVAMC) If EMAX &gt; EREP, a step is repeated.  Ordinarily
   this has the value .3.  This is set &lt; 0 if the error tolerance is
   specified improperly, and is set to a large value if the user
   requests complete control over the step size.  EREP is also set
   &lt; 0 after a user specified discontinuity.
 EROV10 (</em>IVAEV) = 10. / (largest floating point number).
 ETA    (<em>IVAIN) Array used in computing integration/interp. coeffs.
 EVC    (</em>IVADB) Array used for output of variables EEPS2 to EROV10 in
   common block <em>IVAEV.
 EXR    (</em>IVAA) Set to CP1 and never changed.  If it is estimated the
   the (error estimate) / (error requested) on the next step will be
   .ge. EXR then the step size is reduced.  Could be a parameter.
 F      (formal) Array used to store derivative values, the difference
   tables, error tolerance requests, and values used by some other
   options. (in <em>IVA,A,BU,CR,DA,DB,G,IN,PR)
 FDAT  (</em>IVAMC) Used to store data for error messages.  (Local array in
   <em>IVAIN.)
 FOPT  (formal) in </em>IVAOP.  Passed as place to save floating point data
   for options.  This package passes F in for FOPT when calling <em>IVAOP.
 G      (</em>IVAMC) Integration coefficients used for predicting solution.
   G(I, J) gives the I-th coefficient for integrating a J-th order
   differential equation.  G(1, 1) is equal to the step size.
 GAMMA  (<em>IVAIN) Array used in computing integration/interp. coeffs.
 GG     (</em>IVAHC) Array of length = max. differential equation order
   allowed by code - 1.  GG(K) = (HH<strong>(K+1)) / K!
 GNEW   (formal) in <em>IVAG.  Current value for vector function g, whose
   zeroes are to be found.
 GOINT  (</em>IVACR) Used for assigned go to used in computing integration
   coefficients.
 GOLD   (<em>IVAG) Previous value for element of G whose zero search is
   active.
 GS     (</em>IVAMC) Integration coefficients used in estimating errors.
 GT     (formal) in <em>IVAG.  Previous value of GNEW.
 HC     (</em>IVAMC) Ratio of (new step size) / (old step size)
 HDEC   (<em>IVAMC) Default value to use for HC when reducing the step
   size.  (Values closer to 1 may be used some of the time.)
 HH     Equivalenced to G(1,1) = current step size in </em>IVAA,CR,DA,G,HC.
 HI     (<em>IVAIN) Step length from the base value of the independent
   variable for the interpolation.
 HINC   (</em>IVAMC) Default value to use for HC when increasing the step
   size.  (Values closer to 1 may be used some of the time.)
 HINCC  (<em>IVAMC) Actual value used for default value of HC when
   increasing the step size.  Set to HINC after start is considered
   complete.  During the start HINCC is set to 1.125.
 HMAX   (</em>IVAMC) Largest value allowed for abs(step size).  Default
   value is a very large number.
 HMAXP9 (<em>IVAMC) .9 * HMAX.
 HMIN   (</em>IVAMC) Smallest value allowed for abs(step size).  Default
   value is 0.
 HNEW   (<em>IVADE) Value of step size when iterating at initial point
   for delay differential equations.
 I      Used for temporary storage. (</em>IVAA,BU,CR,DA,DE,G,IN,OP,PR)
 IA     (<em>IVAOP) absolute value of first integer stored for an option.
 ICF    (</em>IVAMC) Final index for current loop in <em>IVACR.  Required by
   option 18.
 ICI    (</em>IVAIN) Temporary index, = 0 for interpolation, 1 or 0 for
   differentiation, and d-1, d-2, ... 0 for integration, where d is the
   order of the differential equation.  Index of first location
   in C() used is ICI + an offset.
 ICS    (<em>IVAMC) Starting index for current loop in </em>IVACR.
 ID     (formal) Array use to contain integer data from common.  Values
   are returned in locations 1 to 5 as follows.
   1    KEMAX = Index of equation with largest error estimate
   2    KSTEP = Current step number
   3    NUMDT = Number of differences used for each equation
   4            Reserved for future use
   5            Reserved for future use
 IDAT   (<em>IVAMC) Used to store integer for error messages.  (Also used
   in </em>IVAA for temporary storage of KORD(2).  (Local array in <em>IVAIN.)
 IDE    (</em>IVADE - formal) Array used to contain past information so
   that delays can stretch back indefinitely.  If the first location is
   0, then any interpolations requested must be in the range of the
   current difference tables.  At present, only the value 0 is allowed
   in IDE(1).  This array is intended for the support of saving long
   past histories.  IDE(2) must contain the declared dimension of WDE.
 IDEF   (<em>IVADE -- formal) Flag giving indicaion of what is going on.
   = 0  User should compute derivatives and return to the main
        integrator.
   = 1  Code is computing additional values in order to get past data
        necessary for starting.  User should compute derivatives and
        call </em>IVADE.
   &lt; 0  Indicates an error condition.  If <em>IVADE is called without
        changing the value of IDEF, the integration is stopped and an
        error message printed.  Possible error flags are:
    -1  Difference tables do not span back far enough to compute the
        past values of Y needed.
    -2  There is not enough space in WDE to get the required starting
        values.
 IDIMF  (formal) Declared dimension of F().
 IDIMK  (formal) Declared dimension of KORD().
 IDIMT  (formal) Declared dimension of TSPECS().
 IDIMY  (formal) Declared dimension of Y().
 IDT    (</em>IVAIN) Used as a base index into the difference table.
 IFLAG  (formal in <em>IVAG) Used for communication with user.
   = 1  Continue as if </em>IVAG was not called.
   = 2  Check KORD(1) as one would do at start of OUTPUT if no G-Stops
        were present. (Exit if in DERIVS.)
   = 3  Return to the integrator.
   = 4  Compute G and return to <em>IVAG.
   = 5  A G-Stop has been found, and NSTOP gives its index.  (If NSTOP
        &lt; 0, the stop was an extrapolating stop.)
   = 6  Same as 5, but requested accuracy was not met.
   = 7  Same as 5, but there is a probable error in computing G.
   = 8  Fatal error of some type.  (An error message has been printed.)
 IG     (</em>IVAG)  IG = KORD(2) on the initial entry (0 for extrapolating
   G-Stops, and 1 for interpolating).
 IGFLG  (<em>IVAMC) Used primarily in </em>ivag, but also used in <em>iva to keep
   track of the state of GSTOP calculations.
   = -2 Extrapolatory G's initialized, but not the interpolatory.
   = -1 Interpolatory G's initialized, but not the extrapolatory.
   =  0 Set when integration is started or restarted, or option setting
        GSTOP is set.
   =  1 Iterating to find a GSTOP.
   =  2 User told that a GSTOP was found.
   =  3 Checking G's at point where a GSTOP was located.
   =  4 Checking G's at a T output point.
   =  5 Usual case, no sign change detected.
 IGSTOP (</em>IVAMC) IGSTOP(k) is set in <em>ivag to the index of the last G
   with a 0, where k is one for an interpolatory G-Stop, and k is two
   for an extrapolatory G-Stop.
 IGTYPE (</em>IVAMC) Array with two elements as for IGSTOP, but this saves
   a flag giving the nature of convergence to the stop.
   = 0  All known G-stops completely processed.
   = 4  Need to compute next value while iterating.
   = 5  Got good convergence.
   = 6  Got convergence, but not to desired accuracy.
   = 7  Problem in getting convergence.
   = 8  A fatal error of some type.
 IHI    (<em>IVA) Last location used by the current option.
 ILGREP (</em>IVAMC) Used when correction to keep track of equations that
   are to use a certain error tolerance.
 ILGROR (<em>IVACR) Index of last equation in the current group of
   equations grouped for selecting integration order.
 ILOW   (</em>IVA) First location used by the current option.
 INCOM  (<em>IVADE) Array equivalenced to LDT in the common block </em>IVASC.
   Used to simplify saving information in the common block.
 INCOP  (<em>IVAOP) Array containing data giving the amount of space in
   IOPT used for each of the options.
 INGS   Current index for G-stop being examined in DIVAG.
 INICAS (</em>IVADE) Used to track the initialization for a delay equation.
   = 1  Very beginning.
   = 2  Getting derivative at the very beginning.
   = 3  Getting derivatives at points prior to the initial point.
   = 4  Getting derivative at initial point after iteration is started.
 INTCHK (<em>IVA) Array passed to OPTCHK containing information on storage
   allocation.  See comments in OPTCHK for details.
 INTEG  (</em>IVAIN) Number of integrations being done. (&lt;0 for
   differentiations and =0 for interpolation.)  Also used as counter
   when computing integration coefficients.
        (<em>IVAPR) Number of integrations being done.
 INTEGS (</em>IVAPR) = -1 for equations that are not stiff, 0 for those
   that are stiff.
 INTEGZ (<em>IVAIN) min(INTEG, 0)
 INTERP (</em>IVAIN) added to the usual integration order to get the order
   to be used when interpolating: 3-KQMAXI, if HI=0; 1, if
   |HI| &gt; |XI(1)| and HI * XI(1) &lt; 0; 0, otherwise -- the usual case.
 IOP10  (<em>IVAMC) Number of times diagnostic output is to be given when
   leaving </em>ivacr (the corrector).
 IOP11  (<em>IVAMC) Gives current step number of the method.  Tells how
   many of certain coefficients must be computed. (Has nothing to do
   with options.) = min(max integ order + 1, KDIM).  Also set when
   starting to flag that certain memory locations must be set to 0.
 IOP12  (</em>IVAMC) Points to location in F() where user supplied values
   of HINC, HDEC, HMIN, and HMAX.  (0 if option 12 not used.)
 IOP13  (<em>IVAMC) If not zero, reverse communication will be used for
   getting the values of derivatives.  Associated with option 13.
 IOP14  (</em>IVAMC) If not zero, reverse communication will be used in
   place of calls to the output routine.  Associated with option 14.
 IOP15  (<em>IVAMC) If not zero, a return will be made to the user after
   the initialization.  Associated with option 15.  This might be used
   to overlay </em>iva, some of the user's code, and perhaps <em>ivaop.
 IOP16  (</em>IVAMC) Points to location in KORD() where information for
   specifying the error tolerance is specified.  See option 16.
 IOP17  (<em>IVAMC) Used in initialization for option 17, afterwards this
   cell is used by KEXIT which is equivalenced to IOP17.
 IOP18  (</em>IVAMC) Points to location in KORD() where information for
   specifying a grouping of equations for derivative evaluation is
   stored.  See option 18.
 IOP19  (<em>IVAMC) Points to location in KORD() where information for
   specifying a grouping of equations for integration order control
   is stored.  See option 19.
 IOP20  (</em>IVAMC) Used for option 20, gives first location in F where
   estimated errors are to be stored.  Expected to be useful in a
   program for solving boundary value problems using multiple shooting.
 IOP21  (<em>IVAMC) Was used for stiff equations option (never completely
   coded).  The optional code still uses this (don't activate it!).
   Now used to flag the location if F where the user has stored the
    tolerance to use in finding G-Stops.
 IOP21S (</em>IVAMC) Was used for stiff equations see above.
 IOP22  (<em>IVAMC) Set aside for possible option for stiff equations.
 IOP3   (</em>IVAMC) Value set by option 3.
   =  0 Interpolate to final point. (The default)
   =  1 Integrate to final point.
   = -1 Extrapolate to final point.
 IOP4   (<em>IVAMC) Value set by option 4.  The output routine is called
   with KORD(1) = 4, every IOP4 steps.  (Default value for IOP4 is a
   very large number.
 IOP5   (</em>IVAMC) Value provided by option 5, used to specify extra
   output points.
 IOP6   (<em>IVAMC) Value provided by option 6.  If nonzero, the output
   routine is called at the end of every step.  If &gt; 0, there are
   IOP6 interpolating G-Stops.
 IOP7   (</em>IVAMC) Value provided by option 7.  If &gt; 0, there are K7
   extrapolating G-Stops.
 IOP8   (<em>IVAMC) Value provided by option 8.  If nonzero, the output
   routine is called with KORD(1)=8 whenever the step size is changed.
 IOP9   (</em>IVAMC) Value provided by option 9.  Used to specify that the
   user wishes to save the solution.
 IOPIVA (<em>IVA) Used to save length of IOPT vector for error messages.
 IOPST  (</em>IVASC) Intended for possible use in stiff equations.
 IOPT   (formal <em>IVA and IVAOP) Used to specify options.
 IOPTC  (</em>IVAOP) In <em>IVAOP equivalenced so that IOPTC(3) is equivalent
   to IOP3.
 IOPTS  (</em>IVAOP) Array containing the current default values to be
   stored into IOPTC.
 IORD   (<em>IVACR) Index of first equation in the current group of
   equations grouped for selecting integration order.
 IOUTKO (</em>IVADC) Used in <em>IVADI to point to KORD to keep track of
   equation grouping for diagnostic output.
 ISVCOM (</em>IVADE) Used to save info. in the common block <em>IVASC.
 ITERS  (</em>IVADE) Counts iterations in starting delay differential
   equations.  Max. value for this is arbitrarily 100.
 ITOLEP (<em>IVAMC) Used for temporary storage, and for the index of a
   tolerance relative to the start of tolerances.
 IVC1   (</em>IVADB) Array used for output of variables IOPST to NUMDT in
   common block <em>IVASC.
 IVC2   (</em>IVADB) Array used for output of variables ICF to NY in
   common block <em>IVAMC.
 IWB    (</em>IVADE) Current base index for saving F values in WDE when
   starting delay differential equations.
 IY     (<em>IVAMC) Used for the current index to the Y() array.  (Local
   variable in </em>IVAIN used in computing IYI.)  Equivalenced to
   IZFLAG in <em>IVAG.
 IYI    (</em>IVAIN) Y(IYI) is currently being computed.
 IYN    (<em>IVAIN) Y(IYN) is base Y() corresponding to Y(IYI).
 IYNI   (</em>IVAIN) Used as base index for computing IYN as IY is for INI.
 IYO    (<em>IVADE) Points to first base value of Y for current
   interpolation when getting values for a delay differential equation.
 IZFLAG (</em>IVAG)  Equivalenced to IY.  Set to 0 initially, and later
   set to the value returned by <em>ZERO.
    = 0  Value set on entry at start of search.
    = 1  Compute next g again.
    = 2  Normal terminiation.
    = 3  Normal termination -- error criterion not satisfied.
    = 4  Apparent discontinuity -- no zero found.
    = 5  Couldn't find a sign change.
    = 6  </em>ZERO was called with a bad value in IZFLAG.
 J      For temporary storage. (In <em>IVA,A,BU,CR,DA,DB,DE,HC,IN,OP,PR)
 J1     (</em>IVAA &amp; DA) Used for temporary storage.
 J2     (<em>IVAA) Used for temporary storage.
 JL     (</em>IVA) Used for checking storage.
 JLGREP (<em>IVACR) Contents of first location of KORD (called LGROUP in
   </em>IVACR) for the current error tolerance rule.
 JLGROR (<em>IVACR) Contents of first location of KORD for the current
   integration order control.
 JLIM   (</em>IVA) Used for checking second item in KORD list for options
   16 and 19.
 K      For temporary storage.  (In <em>IVA,A,BU,CR,DA,DB,DE,HC,IN,OP,PR)
 KDIM   Parameter giving the largest number of differences supported.
        Used in all the routines.
 KEMAX  (</em>IVAMC) Index associated with equation giving the largest
   value for (estimated error) / (requested error).
 KEXIT  (<em>IVAMC) Equivalenced to IOP17 which is not used after
   initialization.  Defines actions when KORD2I = -7.  (Referenced in
   (</em>IVAA,DA,G).)
   =  1  Take the step over with reduced H.
   =  2  Take the step over.
   =  3  Do the end of step call to OUTPUT.
   =  4  Reset TMARK, then do same as for KEXIT = 2.
   =  5  Reset TMARK, then do same as for KEXIT = 3.
   =  6  Give the fatal error diagnostic.
 KFERR  (<em>IVA)  Temporary storage in checking for option 16.
 KGO    (</em>IVA)  Used to tell from whence a check is being done or an
   error message is being written.
   = 1 Checking an equation group for variational equations.
   = 2 Checking an equation group for diagnostic print.
   = 3 Checking an equation group for integration order control.
   = 4 Checking an equation group for error control.
   = 5 Checking an equation group for specifying ODE orders.
   = 6 Found a problem with output type for printing.
   = 7 Found a problem with an output group for printing.
   = 8 Found a problem with input NEQ.
   = 9 Order specified for the ODE's in the system is out of range.
   =10 Option 16 was not used (an error).
   =11 Error tolerance of 0 specified without proper flags.
 KIS    (<em>IVAMC) Used to check if it is time to dump the solution.
   The check involves incrementing KIS at the end of the step, and
   dumping the solution if KIS is 0.
   = -1  Set in </em>ivacr when it is time to dump solution
   =  0  When starting
   =  2  After being dumped.
   This is set to 1000 just after a user specified discontinuity, and
   counted up from that point.
 KMARK  (<em>IVAMC) Identifies the type of output associated with the next
   output point specified by TSPECS.
 KONV   (</em>IVADE) Counts iterations.  Test for convergence if KONV &gt; 1.
 KORD   (formal in <em>IVA,A,BU,CR,DA,DB,DE,G,IN,PR) KORD(1) is used to
   return flags for the user to test, and KORD(2) tells what routine
   the flag is associated with.  See KORD1I and KORD2I below and the
   write up for the program.  KORD(3) is used for communicating extra
   information to the user in some cases.  KORD(4) to KORD(NTE+3) are
   used for integration order for the equations, and the rest of KORD()
   is available for user options.
 KORD1I (</em>IVAMC) Helps in defining the state of the integrator.
   Frequently has the same value as KORD(1).  Meaning depends on the
   value of KORD(2), or the value about to be assigned to KORD(2).
   &lt;  0  Happens when preparing to give output with extrapolation.
   =  0  Happens when checking F at points for noise test.
   =  1  (KORD(2)=-1)  End of integration has been reached.
   =  1  (KORD(2)= 0)  Computing first predicted derivative.
   =  1  (KORD(2)= 1)  Output for initial point.
   =  2  (KORD(2)=-1)  Giving diagnostic for noise limiting precision.
   =  2  (KORD(2)= 0)  Computing corrected derivative.
   =  2  (KORD(2)= 1)  Output for TSPECS(3).
   =  3  (KORD(2)=-1)  Diagnostic for step size reduction too fast.
   =  3  (KORD(2)= 0)  Computing variational derivative.
   =  3  (KORD(2)= 1)  Output for TSPECS(4).
   =  4  (KORD(2)=-1)  Error, discontinuity.
   =  4  (KORD(2)= 1)  Output for certain number of steps.
   =  5  (KORD(2)= 0)  Get initial derivatives for stiff equations.
   =  5  (KORD(2)= 1)  Extra output from TSPECS.
   =  6  (KORD(2)= 1)  End of step output.
   =  7  (KORD(2)= 0)  Evaluate G before extrapolated output point.
   =  7  (KORD(2)= 1)  Evaluate G before extrapolated output point.
                       (Also used when checking for other G's after
                        finding one.)
   =  8  (KORD(2)= 1)  Tell user step size has changed.
   =  9  (KORD(2)= 1)  Request for user to save solution.
   = 11  (KORD(2)=-1)  Error, step size too small at end of start.
   = 12  (KORD(2)=-1)  Error, step size is too small.
   = 13  (KORD(2)=-1)  Error, output points specified badly.
   = 21  (KORD(2)=-1)  H too small to give reasonable change when added
                       to T.
   = 22  (KORD(2)=-1)  Error, bad tolerance.
   = 23  (KORD(2)=-1)  Set after message for a fatal error.
   = 24  Set on error message in <em>iva, along with KORD2I = -4.
   Also used as an index into MLOC in </em>IVAA when an error is being
   processsed, see MLOC below.
 KORD2I (<em>IVAMC) Helps in defining the state of the integrator.
   Frequently has the same value as KORD(2).
   = -3  Set in </em>ivag, to get a derivative evaluation.
   = -2  Set in <em>ivag, to get another entry to OUTPUT.
   = -1  Return to calling program, done, interrupt, or got an error.
   =  1  Calling OUTPUT or returning to user for OUTPUT type action.
   =  0  Calling DERIVS or returning to user for DERIVS type action.
   = -4  Error message in </em>iva and in <em>ivaop, along with KORD1I = 24.
   = -5  Starting
   = -6  Starting, getting the initial derivative value or derivatives
         for the noise test.
   = -7  Done some extrapolation, KEXIT defines the action to take.
         Set in </em>ivag to activate KEXIT action in <em>iva.
   = -8  Set when user has requested adjustment of the difference
         tables for a discontinutiy.
 KORDI  (</em>IVASC) Order of differential equation being integrated.  If
   all orders are the same, this set once at the beginning.
 KOUNT   (<em>IVADE) Count of number of points back from the initial point
   when solving a delay differential equation.
 KOUNTM  (</em>IVADE) Largest value currrently allowed for KOUNT.
 KOUNTX  (<em>IVADE) Largest value allowed for KOUNTM.
 KOUTKO  Used in DIVACR to track where output is wanted.
 KPRED  (</em>IVAMC) Value assigned to KORD1I when getting a predicted
   derivative.  (1 used now, 5 planned for use with stiff equations.)
 KQD    (<em>IVACR) = max(2, integration order)
 KQDCON (</em>IVAMC) Number of coefficients computed with constant step
   size for stiff equations.
 KQICON (<em>IVAMC) Number of coefficients computed with constant step
   size for nonstiff equations.
 KQL    (</em>IVACR) Integration order at start of (<em>IVACR)
 KQLORD (</em>IVACR) Saved value of KQL when equations are grouped for
   controlling the integration order.
 KQMAXD (<em>IVASC) Maximum integration order used for stiff equations.
 KQMAXI (</em>IVASC) Maximum integration order used for nonstiff equations.
 KQMAXS (<em>IVAMC) Maximum integration order for equations that have
   some limit on the error that can be committed.
 KQMXDS (</em>IVAMC) Used to save KQMAXD in case step is repeated and the
   solution must be dumped.
 KQMXI  (<em>IVAIN) Maximum integration order used for integration or
   interpolation, = KQMAXI+INTERP-1.
 KQMXS  (</em>IVAIN) Maximum step number, = max(KQMXI, KQMAXD).
 KQMXIL (<em>IVAMC) Value of KQMAXI the last time integration coefficients
   were computed.
 KQMXIP (</em>IVAMC) = KQMAXI + MAXINT, for computing integration coeffs.
 KQMXIS (<em>IVAMC) Used to save KQMAXI in case step is repeated and the
   solution must be dumped.
 KQN    (</em>IVACR) Value of integration order at end of <em>IVACR.
 KQQ    Used for the integration order for current equation.  (Values
   &lt; 0 are intended for stiff equations.)  (In </em>IVA,BU,DA,IN,PR)
 KSC    (<em>IVAMC) Number of steps that have been taken with a constant
   step size.
 KSOUT  (</em>IVAMC) When KSTEP reaches this value, the output routine is
   called with KORD(1) = 4.  The default value is a very large number.
 KSSTRT (<em>IVAMC) Set when ending one derivative per step to KSTEP + 2.
   Checked later in </em>IVAHC to decide whether to set the step changing
   factors to their nominal values.
 KSTEP  (<em>IVAMC) Number of steps taken since the start of integration.
 L      Used for temporary storage.  In </em>IVAIN, L is the initial value
   of LDT, except L=1 if LDT=-1, and MAXINT .ge. 0.  (Used in <em>IVAA,BU
   CR,DA,DB,IN,PR.)
 LAHAG  (</em>IVADB) Used to get proper offset into an diagnostic message.
 LAIAG  (<em>IVADB) Used to get proper offset into an diagnostic message.
 LDIS   (</em>IVAA) Count of steps since user flagged a discontinuity.
 LDT    (<em>IVASC) Used to keep track of state of difference table.
   = -5  Used only on first step to indicate that an extra iteration
         is desired to get a firm estimate on the error.
   = -4  Set on initialization before there is any difference table.
   = -3  Set just after predicting, interpolation is not allowed when
         this value is set.
   = -2  Set when difference table is to be updated to the end of the
         current step, but no interpolation is to be done.  (For
         dumping the solution.)
   =  0  Calculations for current step are complete, it is not o.k. to
         update the difference table.
   =  1  Difference table has been updated to the end of the current
         step, e.g. by doing an interpolation.
   =  2  Set when doing a special interpolation during computation of
         derivatives.  (For delay equations.)
 LEX    (</em>IVAMC) Indicates how to get values at next output point:
   = -1  Extrapolate
   =  0  Interpolate (The usual case.)
   =  1  Integrate to the output point, integration is not continued.
 LGO    (<em>IVAIN) Used as an an assigned go to.  Result is to add in
   extra correction term when LDT has been set to 2.
 LGROUP (formal) This is a part of KORD passed into </em>IVACR.  The first
   location is the start of the information on the grouping of
   equations for error control.
 LINC   (*IVAMC) Used to indicate state of step size selection.
   = -10 After computed derivatives at base time, after computing other
         extra derivatives for the noise test.
   = -9  After computed second extra derivative for noise test.
   = -8  After computed first extra derivative for noise test.
   = -7  Dumping the solution and then doing a user initiated restart,
         or getting ready to compute extra derivatives for the noise
         test.
   = -6  Dumping the solution before a restart.
   = -5  Set on the first step, and also set when dumping the solution
         after a discontinuity.
   = -4  Repeat step with no change in the step size.
   = -3  Set when the error tolerance is set improperly.
   = -2  User has complete control of selecting the step size.
   = -1  Step is being repeated.
   =  0  Step size is not to be increased on this step.
   = k&gt;0 Step size can be increased by HINCC</strong>k.
 LINCD  (<em>IVAMC) Value of smallest k for which HINCC</em><em>k .ge. 2.
   (=-2 if user is specifying all step size changes.)
 LINCQ  (</em>IVAMC) Value of smallest k for which HINCC<strong>k .ge. 4.
 LIOPT  (<em>IVAOP) Value of the last index in IOPT on the last call.
   Used so </em>IVA can print IOPT in error messages.
 LL     (<em>IVACR) Temporary variable used when equations are grouped
   for integration order control.
 LNOTM1 (</em>IVAIN) Logical variable = L .ne. -1.  If LNOTM1 is true,
   storage in Y() is different in some way lost to antiquity.  Such
   a case can only arise in the case of stiff equations.
 LOCF1  (<em>IVADB) Gives packed data needed for output of tables by the
   message processor MESS.  See comments there under METABL for defs.
 LOCF2  (</em>IVADB) As for LOCF1 above.
 LOCM   (<em>IVAA) Parameter = 32</em>256, used to unpack integers stored
   in MLOC for use in error message processing.
 LPRINT (formal, <em>IVADB) Defines how much printing is to be done in
   </em>IVADB.  Let |LPRINT| = 10<em>N1 + N2     (N1,N2 digits)
    N1=1   Do not print any variables external to the integrator.
    N1=2   Print  tspecs, current y, past y, current f, all pertinent
           contents of KORD, and TOL.
    N1=3   Above + difference tables up to highest difference used.
    N1=4   Same as N1=1 + all in storage allocated for differences.
    N2=1   Do not print any variables internal to the integrator.
    N2=2   Print all scalar variables in interpolation common block.
    N2=3   Above + all scalar variables in main integ. common block.
    N2=4   Same as N1=3 + all used in arrays XI,BETA,ALPHA, first
           column of G, GS,RBQ,SIGMA
    N2=5   Same as N1=4 + all used in arrays G,D,DS,V
 LSC    (</em>IVAMC) Indicates if starting or if noise may be present.
   =k&lt;0 -k steps have been taken for which noise appears to be limiting
        the precision.
   = 0  Usual case
   = 1  Doing 1 derivative per step after initial part of start.
   = 2  Used as flag that it is time to set LSC=0.
   = 3  Third step, hold the order constant.
   = 4  Second step, increase orders from 2 to 3.
   = 5  First step, third time through the first step (if required).
   = 6  First step, second time through.
   = 7  First step, first time through.
   = 8  Set on initialization.
 LTXT?? Names of this form are used in setting up data statements for
   error messages.  These names are generated automatically by PMESS,
   the program that makes up these messages.
 LX     (<em>IVAA) Used for temporary storage in computing TMARKA().
        ( formal </em>IVADE)  An integer array containing extra
   information, as follows.
  LX(1) Points to a location in Y beyond those already in use.  Values
        of Y requested are computed at TSPECS(1) - Y(LX(1)) and stored
        starting at Y(LX(1)+1).  If this index is 0, no more extra Y
        values are to be computed.
  LX(2) Index of the first equation for which the Y's above are to be
        computed.  Y(LX(1)+1) will correspond to this first equation
        index.
  LX(3) Index of the last equation for which the Y's above are to be
        computed.  Thus the Y's stored starting at Y(LX(1)+1) will
        require no more space than half the space ordinarily required
        for the array Y(), and may require significantly less.
  LX(4) Maximum number of times to integrate F to get Y.  This should
        be &gt; 0, and less than or equal to the order of the highest
        order differential equation.  (= 0 is allowed, but probably
        not what you want.  It would give a value only for F.)  Space
        must be set aside for all integrals of F, even if not all are
        requested.  For a first order system, all Y's are just the
        first integrals of the corresponding F's.  For higher order
        equations, the first Y associated with a given F is the d-th
        integral of the corresponding F, where d is the order of the
        equation, and the last Y corresponding to the F is the first
        integral of that F.
  LX(5) As for LX(4), but gives the index for the fewest number of
        times to integrate F.  Ordinarily this should be &gt; 0.  If 0 is
        requested, an estimate for the value of F at the delay point is
        computed.  This should not be 0 more than once, for equations
        covering the same index, since later such requests would write
        over the earlier results.
  LX(5i+k) , k = 1, 2, ... 5.  Treated as for the cases above.  If i
        different cases of delayed Y's are to be computed, then
        LX(5i+1) must be 0.
 LX2    (<em>IVADE) Value of LX(5i+2), when working on the i-th delay.
 MACT   Used in the programs which call the error message program.
   This array difines the actions to be taken by that program.  (In
   (</em>IVA,A,DA,DE,G,IN,OP)
 MACT0  (<em>IVADB) Used to call the message program, see MACT.
 MACT?  As for MACT, in (</em>IVA,CR,DB)
 MACTFV (<em>IVADB) As for MACT0.
 MAXDIF (</em>IVASC) Maximum differentiations required for stiff equations.
 MAXINT (<em>IVASC) Maximum integrations required.  (= max. order of
   differential equations if equations are not stiff.)
 MAXKQ  (</em>IVA, BU)e
 MAXKQD (<em>IVAMC) Largest integration order allowed for stiff equations.
 MAXKQI (</em>IVAMC) Largest integ. order allowed for nonstiff equations.
 ME???? Parameters defining constants used for interaction with the
   error message program MESS.  See comments there for definitions.
   (In <em>IVA,A,DA,DE,G,IN,OP)
 METHOD (</em>IVAMC) Defines kind of methods being used.
   = -1  Only stiff equations are being integrated.
   =  0  Only nonstiff equations are being integrated.
   =  1  Both kinds of methods are required.
 MLOC   (<em>IVA,A,DE) Contains locations in MTEXT for error messages.  In
   </em>IVAA this data is packed using MLOC??, see below.
 MLOC?? (<em>IVAA) Parameters constructed to aid in making up packed data
   for processing error messages.  Low two digits give the value of
   KORD1I to use for the error index and later processing, the next two
   give the error severity level, and the rest point to text used for
   the message.
 MODF2  (</em>IVADB) Used in constructing the same kind of packed data as
   described for LOCF1 above.
 MULTJ  Local to DIVAOP for calls not using F.
 MTEXT  (<em>IVA,A,CR,IN,OP) Text for error messages.
 MTXT?? (</em>IVA,A,CR,DA,DB,DE,G,IN,OP) Equivalenced into MTEXT.
 N      Used for temporary storage.  (In <em>IVAHC,IN,PR)
 NDTF   (</em>IVASC) Location in F() where difference table starts.
 NE     (<em>IVAMC) Number of equations in the first group.  (=NTE if
   option 18 is not used.)
 NEDDIG (</em>IVADB) Parameter = -MEDDIG.
 NEPTOL (<em>IVAMC) Used for temporary storage and to save the value of
   ITOLEP for error messages.
 NEQ    (formal) Total number of equations being integrated.
 NG     (</em>IVAMC) Used in <em>ivag for the number of g's in the current
   context.
 NGSTOP (</em>IVAG) Dimension 2 array equivalenced to IOP6, and IOP7.  To
   get the number of interpolating and extrapolating G-Stops.
 NGTOT  (<em>IVAMC) NGTOT(1) gives the number of interpolating G-Stops,
   and NGTOT(2) gives the number of extrapolating G-Stops.
 NKDKO  (</em>IVASC) If this is nonzero (option 17), it gives the location
   in KORD() where a vector defining the order of each equation is
   specified.
 NLX    (<em>IVADE) Temporary index used to keep track of interpolations
   being done to get Y() values for a delay differential equation.
 NOISEQ (</em>IVAMC) max(2, order of equation for which (error estimate)/
   (error requested) is a maximum).
 NOUTKO (<em>IVAMC) If nonzero, gives the index in KORD where information
   on what equations are to be included in the diagnostic output is
   given.   See option 10.
 NSTOP  (formal) In </em>IVAG.  Index of the G-stop, see IFLAG.
 NTE    (<em>IVASC) Total number of equations being integrated = NEQ.
 NTEXT  (formao </em>IVADB) Character variable containing heading text.
 NTOLF  (<em>IVAMC) First location in F() where tolerance specifying
   accuracy desired is stored.
 NUMDT  (</em>IVASC) Maximum allowed number of differences available for
   doing an integration.
 NXTCHK (<em>IVA) Equivalenced to INTCHK(1), which gives the next
   available location in INTCHK for storing data on storage allocation.
 NY     (</em>IVAMC) Total order of the system.
 NYNY   (<em>IVASC) Location in Y() where the base value for Y() is saved.
 NYNYO  (</em>IVADE) Equivalenced to the saved value from common of NYNY.
 OUTPUT (formal) Name of subroutine to be called for the output of
   data or for computing G-Stops.  Not used if option 14 is set.
 OVD10  (<em>IVAEV) (largest floating point number) / 10.
 OVTM75 (</em>IVAEV) (largest floating point number) </strong> (-.75)
 RBQ    (<em>IVAMC) Array containing data for the preliminary noise test.
 RD     (formal </em>IVACO) Array use to contain floating point data from
   common.  Values are returned in locations 1 to 3 as follows.
   1    EMAX =  Max. ratio of estimated error to requested error
   2            Reserved for future use
   3            Reserved for future use
 REF    (<em>IVACR) Array of length 3 used for translating error tolerance
   type into the factor used for exponential averaging for that type.
 RND    (</em>IVACR) Usually the current estimated error.  Used in deciding
   if noise is limiting precision.
 RNOISE (<em>IVACR) Value used in comparison with RBQ() for preliminary
   noise test.
 ROBND  (</em>IVAMC) Used to influence the selection of integration order.
   The larger ROBND, the harder it is to increase the order and the
   easier it is to decrease it.
 RVC2   (<em>IVADB) Array used for output of variables DNOISE to SNOISE in
   common block </em>IVAMC.  These are variables that don't require a great
   deal of precision.
 S      (<em>IVACR) Estimate of (step size) * eigenvalue of Jacobian.
 SIGMA  (</em>IVAMC) The k-th entry of this array contains a factor that
   gives the amount the k-th difference is expected to increase if the
   step size in increased.  These numbers get bigger it there is a past
   history of increasing the step size.
 SIGMAS (<em>IVAA) Saved value of SIGMA(k) from the last step, where k =
   integration order for equation with index KEMAX.
 SNOISE (</em>IVAMC) Value used in comparison with RBQ() on equation with
   largest value for (error estimate) / (error requested).
 T      (formal) in <em>IVAIN. T(1) contains the point to be interpolated
   to, and T(2) is used in a check that |HI| .le. |T(2)|.  When used by
   other routines in this package, TSPECS is passed in for T.
 TB      (</em>IVADE) Base time for current interpolation.
 TC      (<em>IVADE) Original value of TN when getting past Y's for a
   delay differential equation.
 TEMP   Used for temporary storage, in </em>IVAHC,PR
 TEMPA  (<em>IVACR) Array equivalenced to (TPS1,TPS2,TPS3,TPS4).
 TEMPAO (</em>IVACR) Array used to accumulate values in TEMPA.
 TG     (<em>IVAMC) TG(1) gives the last value of TSPECS(1) for which an
   interpolatory G-Stop has been computed.  TG(2) is defined similarly
   for extrapolatory G-Stops.
 TGSTOP (</em>IVAMC) TGSTOP(1) gives the value of TSPECS(1) where the last
   0 for an interpolatory G-Stop was found.  TGSTOP(2) is defined
   similarly for extrapolatory G-Stops.
 TMARK  (<em>IVAMC) Location of the next output point.
 TMARKA (</em>IVAA)  Array of length 2 equivalenced to TMARK (and TMARKX).
 TMARKX (<em>IVAMC) Location of the next output point to be found using
   integration or extrapolation.  This variable must follow immediately
   after TMARK in the common block.
 TN     (</em>IVASC) The value of TSPECS(1) at the conclusion of the last
   step.
 TNEQ   (<em>IVADB) Array of dimension 1 equivalenced to TN so that an
   array can be passed to </em>MESS.
 TOL    (formal) This is a part of F passed into <em>IVACR.  The first
   location is the start of the information on the tolerances for error
   control.
 TOLD   (</em>IVAG) Value of TSPECS(1) on one side of a zero.
 TOLG   (<em>IVAMC) Tolerance to pass to dzero when locating G-Stops.
 TOUT   (</em>IVAMC) Location of next output point defined by value of
   TSPECS(3).  Such output is given with KORD(1) = 2.
 TP     (<em>IVA,A,DA,DE,HC) Used for temporary storage.
 TP1    (</em>IVAA,DA,HC,IN,PR) Used for temporary storage.
 TP2    (<em>IVAA,DA,HC,PR) Used for temporary storage.
 TP3    (</em>IVAA) Used for temporary storage.
 TPD    (<em>IVABU) Used for temporary storage.
 TPP    (</em>IVACR) Used for temporary storage.  Usually same as TPS3.
 TPS1   (<em>IVAA,CR) Used for temporary storage.  (In </em>IVACR is the
   difference of order KQQ-2)
 TPS2   (<em>IVAA,CR) Used for temporary storage.  (In </em>IVACR is the
   difference of order KQQ-1)
 TPS3   (<em>IVACR) Contains the difference of order KQQ.  This is the
   last difference used in the corrector.
 TPS4   (</em>IVACR) Contains the difference of order KQQ+1.
 TPS5   (<em>IVACR) Temporary storage.
 TPS6   (</em>IVACR) Temporary storage.
 TPS7   (<em>IVACR) Temporary storage.
 TSAVE  (</em>IVAG) Value of TSPECS(1) before starting the search for a 0.
 TSPECS (formal <em>IVA,A,DB,DE,G)
   TSPECS(1) is the current value of the independent variable.
   TSPECS(2) is the current value of the step size.
   TSPECS(3) is the increment to use between output points that give
             output with KORD(1) = 2.
   TSPECS(4) is the "final" output point.
 V      (</em>IVAMC) Array used in computing integration coefficients.
 XI     (<em>IVASC) XI(K) = TSPECS(1) - value of TSPECS(1) K steps
   previous.
 W      (</em>IVAHC) Array used in computing integration coefficients.
 WDE    (formal, <em>IVADE)  Array used for working storage.  This storage
   is used to save derivative values when iterating to get started.  To
   be safe one should allow as much space as is allowed for differences
   in F.  In most cases the start will not require this much space
   however.  This array is also intended for the support of saving long
   past histories.
 Y      (formal, </em>IVA,A,CR,DA,DB,DE,G,IN,PR) Array containing the
   independent variable and all derivatives up to order one less than
   the order of the differential equation.  Also use to save these
   values at the beginning of the current step, the base values.
 YN     (formal, in *IVAPR)  Base values of y, these follow the
   current values of the dependent variable, y, in Y().</p>
<p>++S Default KDIM = 16
++  Default KDIM = 20
++  Default MAXORD = 2, MAXSTF = 1
++  Default INTEGO, VAREQ, OUTPUT, DUMP, GSTOP, EXTRAP
++  Default STIFF=.F., ARGM=.F., ERRSTO=.F.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-idimy"></span>integer</td>
  <td></td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>IDIMY</strong></td><td><blockquote>
<p>2015-03-15 DIVA  Krogh  Removed extra call divabu after noise test
2015-03-15 DIVA  Krogh  Forced restart needs more reduction in h.
2010-02-20 DIVA  Krogh  Fixed calling DIVAOP with array other than F.
2009-11-03 DIVA  Krogh  Added option 11, more variables initialized.
2009-10-30 DIVA  Krogh  Gave KSSTRT and ROBND initial values.
2009-10-30 DIVA  Krogh  Fixed reference to undefined location in F.
2009-10-21 DIVA  Krogh  Got rid of NaN in diag. print when LSC=3.
2009-10-15 DIVA  Krogh  A few changes on how noise is handled.
2002-11-12 DIVA  Krogh  Fixed problem integrating to final output pt
2002-08-29 DIVA  Krogh  Added test for invalid HMIN/HMAX.
2002-07-26 DIVA  Krogh  Added KOUTKO to fully support Option 10.
2002-05-14 DIVA  Krogh  Fix starting prob. for Option 18.
2002-05-13 DIVA  Krogh  Put exponent letter in  numbers missing them
2002-05-12 DIVA  Krogh  Added error message for bad option 5 usage.
2001-09-07 DIVA  Krogh  Changes to allow user tol on G-Stops.
2001-05-25 DIVA  Krogh  Minor change for making .f90 version.
2001-05-18 DIVA  Krogh  Less computing with no error test
2001-05-17 DIVA  Krogh  Fixed so with no error test can't start dump
2001-04-24 DIVA  Krogh  Inserted comments from ivacom.
2000-12-01 DIVA  Krogh  Removed (some of) unused C1, MAXSTF, METEXT.
1999-12-28 DIVA  Krogh  Saved S in DIVACR for output consistency.
1999-08-19 DIVA  Krogh  Removed superfluous test above label 3520.
1997-04-22 DIVA  Krogh  Got rid of assigned go to's. F=0 if diag.
1996-08-26 DIVA  Krogh  Initialize F to 0 if dumping solution.
1996-08-23 DIVA  Krogh  Print TN not TSPECS(1) in error messages.
1996-05-30 DIVA  Krogh  Changed DERIVS/OUTPUT to  DIVAF/DIVAO.
1996-04-27 DIVA  Krogh  Changes to use .C. and C%%.
1996-03-30 DIVA  Krogh  Added external statement.
1996-03-25 DIVA  Krogh  Introduced TEXT1 to comply with F77.
1996-02-27 DIVA  Krogh  Fixed so DUMP not affected by ignored eqs.
1995-12-18 DIVA  Krogh  Fixed so no solution dump on 0 length integ.
1995-11-09 DIVA  Krogh  Fixed so char. data at col. 72 is not ' '.
1995-06-19 DIVA  Krogh  Fixed prob. with discon. just after restart.
1995-05-09 DIVA  Krogh  Fixed G-Stop/discontinuity code interaction
1995-04-26 DIVA  Krogh  Use KQMAXS instead of KQMAXI when LDIS&gt;1000.
1995-04-26 DIVA  Krogh  Keep current KQL on discontinutiy.
1994-12-16 DIVA  Krogh  Fixed option 12 with K12 &lt; 0.
1994-11-11 DIVA  Krogh  Declared all vars.
1994-11-02 DIVA  Krogh  Changes to use M77CON
1994-09-08 DIVA  Krogh  Added CHGTYP code.
1994-07-11 DIVA  Krogh  Fix to get same state with/without var. eqs.
1994-03-07 DIVA  Krogh  Allow larger order in single precision.
1994-01-14 DIVA  Krogh  Minor change to allow changing TFINAL.
1993-04-27 DIVA  Krogh  Additions for Conversion to C.
1993-04-12 DIVA  Krogh  Converted to use slightly altered MESS.
1993-04-12 DIVA  Krogh  Fixed LSC so sol. saved when HMAX is small.
1992-10-13 DIVA  Krogh  Fixed G-Stop/discontinuity code interaction.
1992-09-21 DIVA  Krogh  Fixed bug in discontinuity code.
1992-09-09 DIVA  Krogh  Fixed bug - Var. Eqs. with discontinuities.
1992-08-07 DIVA  Krogh  Storage map printed only if option 10 .ne. 0
1992-07-16 DIVA  Krogh  Restored correct discontinuity code.
1992-06-16 DIVA  Krogh  Eliminate reuse of storage for option 12.
1992-04-08 DIVA  Krogh  Removed unused labels, 1020, 2120.
1992-03-30 DIVA  Krogh  Fixed bug in DIVAOP error message.
1992-03-12 DIVA  Krogh  Simplified DIVABU, more digits in B's.
1992-01-16 DIVA  Krogh  Fixed minor bug in error messages.
1991-12-03 DIVA  Krogh  Major change for improved error checks.
1991-06-17 DIVA  Krogh  Fixed bug in checking storage allocation.
1991-04-11 DIVA  Krogh  Fixed minor bug re. option 12 in DIVAOP.
1991-03-28 DIVA  Krogh  Removed check at label 650 for KORD2I&lt;0.
1991-02-08 DIVA  Krogh  Changed some floats to generics
1990-11-08 DIVA  Krogh  Fixed bug on TSPECS on discon.
1990-09-14 DIVA  Krogh  Fixed bug when discon. and sol. save.
1990-09-13 DIVA  Krogh  Increased dimension of BETA by 1.
1990-09-13 DIVA  Krogh  Added one more poss. on rel. error test.
1990-09-11 DIVA  Krogh  Recent change messed up getting dump output.
1990-06-05 DIVA  Krogh  Fixed bug in noise test, comments in IVACOM.
1990-05-08 DIVA  Krogh  Fixed new bug when TMARK hit in DIVAG.
1990-04-17 DIVA  Krogh  Fixed minor problem in DIVAIN error msg.
1990-04-10 DIVA  Krogh  Fixed interaction between discon. &amp; dump.
1990-03-23 DIVA  Krogh  Fixed bug on option "-2", see 1989-12-07.
1990-03-20 DIVA  Krogh  Fixed rarely occuring loop.
1990-01-29 DIVA  Krogh  Removed unneeded labels.
1989-12-14 DIVA  Krogh  Saved common block DIVAEV.
1989-12-07 DIVA  Krogh  Added option "2" to DIVAOP.
1989-11-09 DIVA  Krogh  Made GG a save var. in DIVAHC
1989-08-21 DIVA  Krogh  Fix out of bounds ref. to V in DIVABU
1989-07-26 DIVA  Krogh  Fix bug in initial dim. check
1989-07-21 DIVA  Krogh  Code for integrating discontinuities
1987-12-07 DIVA  Krogh  Initial code.</p>
</blockquote>
<p>--D replaces "?": ?IVA,?IVAA,?IVABU,?IVACO,?IVACR,?IVAEV,?IVAF,?IVAHC,
-- &amp; ?IVAG,?IVAIN,?IVAMC,?IVAO,?IVAOP,?IVAPR,?IVASC,?IVACE,?IVAIE,
-- &amp; ?IVAPE,?MESS</p>
<p>Note a "*" at the start of a name is used to indicate "D" for the
 double precision version and "S" for the single precision version.</p>
<p>When converting between precisions, don't forget to change the value
 of KDIM set in parameter statements in a variety of routines, and to
 adjust comments for the data statements associated with EIBND in
 <em>IVACR, and B in </em>IVAHC.</p>
<p>Entries
  <em>IVA    Main entry for starting the package.
  </em>IVAA   Main program inside the package, calls the other routines,
          and does checks for output, and noise.  Called by the user
          if reverse communication is used.
  <em>IVABU  Back ups the solution to the current base time, if a step
          that has been started must be taken over for some reason.
  </em>IVACO  Called by user to get certain information from the common
          blocks.
  <em>IVACR  Corrects the solution, estimates errors, and selects order.
  </em>IVADB  Subroutine to assist in debugging codes.  Called by user to
          get a formatted list of all the variables used in the
          integration.  Not required in usual case.
  <em>IVADE  Needed only for delay differential equations.  This is called
          by the user from the derivative subprogram.
  </em>IVAG   Required only if the user has G-Stops, i.e. places to call
          his output subroutine where certain functions have zeroes.
  <em>IVAHC  Compute coefficients that depend on the step size history.
  </em>IVAIN  Used to interpolate to arbitrary points.
  <em>IVAOP  Used to process user option requests.
  </em>IVAPR  Used to update the differences and to predict the solution
          at the end of the current step.</p>
<p>External Routines
  <em>1MACH  Not used in the Fortran 95 version.  ("</em>" is "D" for double
          and "R" for single precision.) This returns constants that
          depend on the floating point arithmetic.  Input arguments of
          1 to 4 give respectively:  underflow limit, overflow limit,
          smallest relative difference between two floating point
          numbers, and the largest relative difference between two
          floating point numbers.
 DERIVS (formal) Name of subroutine to be called for computing
  OPTCHK  Used in checking storage allocation.
  <em>MESS   Used to output error messages and diaganostic messages.
          (Just MESS if no floating point is output.)
  </em>ZERO   Called only if *IVAG is used.  Iterates to find zeros of
          arbitrary (continuous) functions.</p>
<p>Common blocks -- As a left over from the distant past, some variables
   are in common so that they would be saved.
  <em>IVAEV  Holds variables that depend on the environment.
  </em>IVAMC  The main common block for the package.
  *IVASC  The secondary common block for the package.  This contains
          variables that are required for doing interpolation and is
          separate to simplify saving the variables that are required
          when the solution is being dumped (saved).</p>
<p>Common variables and local variables
 ALPHA  (<em>IVAMC) Array with I-th entry = (current step size) / XI(I).
   Used in computing integration coefficients.
 B      (</em>IVAHC) Array used to get started on computing integration
   coefficients.  B(K) = 1. / (K<em>(K+1))
 BAKMIN (</em>IVADE) The largest delay at the initial point.
 BETA   (<em>IVAMC) Array with I-th entry = product (K=1,I-1) of
   (current (XI(K)) / XI(K) from previous step),  BETA(1)=1.  Used in
    updating the difference tables.
 C      (</em>IVAIN) Array used to hold integration/interpolation coeffs.
 C0     Parameter = 0. (in <em>IVAA,DE,CR,A,G,HC,IN,OP,PR)
 C1     Parameter = 1. (in </em>IVA,A,CR,DA,HC,IN,OP)
 C10    Parameter = 10. (in <em>IVAA,CR,OP)
 C1000  Parameter = 1000. (in </em>IVACR)
 C16    Parameter = 16. (in <em>IVAA,OP)
 C1M3   Parameter = .001 (in </em>IVAA)
 C1M5   Parameter = .00001 (in <em>IVAA)
 C1P125 Parameter = 1.125 (in </em>IVAA,HC,OP)
 C1P3   Parameter = 1.3 (in <em>IVAA)
 C1P4   Parameter = 1.4 (in </em>IVACR)
 C2     Parameter = 2. (in <em>IVAA,DE,BU,CR,IN,OP)
 C20    Parameter = 20. (in </em>IVACR)
 C2P5M3 Parameter = .0025 (in <em>IVAA)
 C4     Parameter = 4. (in </em>IVACR,OP)
 C40    Parameter = 40. (in <em>IVACR)
 C4096  Parameter = 4096. (in </em>IVAA)
 C6     Parameter = 6. (in <em>IVAA)
 C8M3   Parameter = .008 (in </em>IVAA)
 CM2    Parameter = -2. (in <em>IVACR)
 CM8    Parameter = -8. (in </em>IVACR)
 CMP5   Parameter = -.5 (in <em>IVACR)
 CMP75  Parameter = -.75 (in </em>IVAOP)
 CP0625 Parameter = .0625 (in <em>IVAA)
 CP1    Parameter = .1 (in </em>IVAA,CR,DA,HC)
 CP125  Parameter = .125 (in <em>IVACR)
 CP25   Parameter = .25 (in </em>IVAA,CR,DE,OP)
 CP3    Parameter = .3 (in <em>IVAA,OP)
 CP4    Parameter = .4 (in </em>IVAA)
 CP5    Parameter = .5 (in <em>IVAA,CR,DA,DE,HC,OP)
 CP5625 Parameter = .5625 (in </em>IVAHC)
 CP625  Parameter = .625 (in <em>IVAOP)
 CP75   Parameter = .75 (in </em>IVACR,OP)
 CP8    Parameter = .8 (in <em>IVACR)
 CP875  Parameter = .875 (in </em>IVAA, OP)
 CP9    Parameter = .9 (in <em>IVAOP)
 CP9375 Parameter = .9375 (in </em>IVACR)
 CQ3125 Parameter = .03125 (in <em>IVACR)
 CRBQI  Parameter = .421875 (in </em>IVAHC)  Initial val for computing RBQ.
 CSUM   (<em>IVAIN) Array used to contain partial sums of the integration
   coefficients.  This is used to corrrect for a difference table that
   has not yet been updated.
 D      (</em>IVAMC) Array to be used later to store coefficients for
   integrating stiff equations.
   derivatives.  Not used if option 13 is set.
 DISADJ (<em>IVAA) Value of stepsize when discontinuity is indicated.
 DNOISE (</em>IVAMC) Used in determining if noise is limiting the
   precision.  It is usually |highest difference used in correcting|
   of the equation with the largest error estimate.
 DS     (<em>IVAMC) Array to be used later to store coefficients for
   estimating errors when integrating stiff equations.
 DVC2   (</em>IVADB) Array used for output of variables HC to TOUT in
   common block <em>IVAMC.
 E      (</em>IVACR) (Estimated error) / (Requested accuracy)
 EAVE   (<em>IVAMC) This is a weighted average of past values of EIMAX.
   It is adjusted to account for expected changes due to step changes.
 EEPS10 (</em>IVAEV) = 10. * (machine epsilon).
 EEPS16 (<em>IVAEV) = 16. * (machine epsilon).
 EEPS2  (</em>IVAEV) =  2. * (machine epsilon).
 EEPT75 (<em>IVAEV) = (machine epsilon) </em><em> (.75)
 EI     (</em>IVACR) Estimate for what E would be if step size increased.
 EIBND  (<em>IVACR) Array containing limits on the estimated error with
   the stepsize increased.  This array tends to make the code a little
   more conservative on step size increases at low order.
 EIMAX  (</em>IVAMC) Estimate of (error estimate / error requested) if the
   step size should be increased.
 EIMIN  (<em>IVAMC) An error estimate is small enough to allow a step
   increase if the estimate of ((error with the step size increased) /
   (error requested)) is less than EIMIN.
 EIMINO (</em>IVAA) Set to C8M3 and never changed.  When step size is being
   reduced if EIMIN .le. EIMINO then the reduction factor is set to
   CP875.  This variable could be a parameter.
 EMAX   (<em>IVAMC) Largest value computed for (error estimate) / (error
   requested).
 EOVEP2 (</em>IVAEV) = EEPS2 * (largest floating point number).
 EPS    (<em>IVACR) Current absolute error tolerance.  Also used for
   temporary storage when computing the desired value of EPS.
 ERCOEF (</em>IVACR) (Error coefficient from formula) / EPS
 EREP   (<em>IVAMC) If EMAX &gt; EREP, a step is repeated.  Ordinarily
   this has the value .3.  This is set &lt; 0 if the error tolerance is
   specified improperly, and is set to a large value if the user
   requests complete control over the step size.  EREP is also set
   &lt; 0 after a user specified discontinuity.
 EROV10 (</em>IVAEV) = 10. / (largest floating point number).
 ETA    (<em>IVAIN) Array used in computing integration/interp. coeffs.
 EVC    (</em>IVADB) Array used for output of variables EEPS2 to EROV10 in
   common block <em>IVAEV.
 EXR    (</em>IVAA) Set to CP1 and never changed.  If it is estimated the
   the (error estimate) / (error requested) on the next step will be
   .ge. EXR then the step size is reduced.  Could be a parameter.
 F      (formal) Array used to store derivative values, the difference
   tables, error tolerance requests, and values used by some other
   options. (in <em>IVA,A,BU,CR,DA,DB,G,IN,PR)
 FDAT  (</em>IVAMC) Used to store data for error messages.  (Local array in
   <em>IVAIN.)
 FOPT  (formal) in </em>IVAOP.  Passed as place to save floating point data
   for options.  This package passes F in for FOPT when calling <em>IVAOP.
 G      (</em>IVAMC) Integration coefficients used for predicting solution.
   G(I, J) gives the I-th coefficient for integrating a J-th order
   differential equation.  G(1, 1) is equal to the step size.
 GAMMA  (<em>IVAIN) Array used in computing integration/interp. coeffs.
 GG     (</em>IVAHC) Array of length = max. differential equation order
   allowed by code - 1.  GG(K) = (HH<strong>(K+1)) / K!
 GNEW   (formal) in <em>IVAG.  Current value for vector function g, whose
   zeroes are to be found.
 GOINT  (</em>IVACR) Used for assigned go to used in computing integration
   coefficients.
 GOLD   (<em>IVAG) Previous value for element of G whose zero search is
   active.
 GS     (</em>IVAMC) Integration coefficients used in estimating errors.
 GT     (formal) in <em>IVAG.  Previous value of GNEW.
 HC     (</em>IVAMC) Ratio of (new step size) / (old step size)
 HDEC   (<em>IVAMC) Default value to use for HC when reducing the step
   size.  (Values closer to 1 may be used some of the time.)
 HH     Equivalenced to G(1,1) = current step size in </em>IVAA,CR,DA,G,HC.
 HI     (<em>IVAIN) Step length from the base value of the independent
   variable for the interpolation.
 HINC   (</em>IVAMC) Default value to use for HC when increasing the step
   size.  (Values closer to 1 may be used some of the time.)
 HINCC  (<em>IVAMC) Actual value used for default value of HC when
   increasing the step size.  Set to HINC after start is considered
   complete.  During the start HINCC is set to 1.125.
 HMAX   (</em>IVAMC) Largest value allowed for abs(step size).  Default
   value is a very large number.
 HMAXP9 (<em>IVAMC) .9 * HMAX.
 HMIN   (</em>IVAMC) Smallest value allowed for abs(step size).  Default
   value is 0.
 HNEW   (<em>IVADE) Value of step size when iterating at initial point
   for delay differential equations.
 I      Used for temporary storage. (</em>IVAA,BU,CR,DA,DE,G,IN,OP,PR)
 IA     (<em>IVAOP) absolute value of first integer stored for an option.
 ICF    (</em>IVAMC) Final index for current loop in <em>IVACR.  Required by
   option 18.
 ICI    (</em>IVAIN) Temporary index, = 0 for interpolation, 1 or 0 for
   differentiation, and d-1, d-2, ... 0 for integration, where d is the
   order of the differential equation.  Index of first location
   in C() used is ICI + an offset.
 ICS    (<em>IVAMC) Starting index for current loop in </em>IVACR.
 ID     (formal) Array use to contain integer data from common.  Values
   are returned in locations 1 to 5 as follows.
   1    KEMAX = Index of equation with largest error estimate
   2    KSTEP = Current step number
   3    NUMDT = Number of differences used for each equation
   4            Reserved for future use
   5            Reserved for future use
 IDAT   (<em>IVAMC) Used to store integer for error messages.  (Also used
   in </em>IVAA for temporary storage of KORD(2).  (Local array in <em>IVAIN.)
 IDE    (</em>IVADE - formal) Array used to contain past information so
   that delays can stretch back indefinitely.  If the first location is
   0, then any interpolations requested must be in the range of the
   current difference tables.  At present, only the value 0 is allowed
   in IDE(1).  This array is intended for the support of saving long
   past histories.  IDE(2) must contain the declared dimension of WDE.
 IDEF   (<em>IVADE -- formal) Flag giving indicaion of what is going on.
   = 0  User should compute derivatives and return to the main
        integrator.
   = 1  Code is computing additional values in order to get past data
        necessary for starting.  User should compute derivatives and
        call </em>IVADE.
   &lt; 0  Indicates an error condition.  If <em>IVADE is called without
        changing the value of IDEF, the integration is stopped and an
        error message printed.  Possible error flags are:
    -1  Difference tables do not span back far enough to compute the
        past values of Y needed.
    -2  There is not enough space in WDE to get the required starting
        values.
 IDIMF  (formal) Declared dimension of F().
 IDIMK  (formal) Declared dimension of KORD().
 IDIMT  (formal) Declared dimension of TSPECS().
 IDIMY  (formal) Declared dimension of Y().
 IDT    (</em>IVAIN) Used as a base index into the difference table.
 IFLAG  (formal in <em>IVAG) Used for communication with user.
   = 1  Continue as if </em>IVAG was not called.
   = 2  Check KORD(1) as one would do at start of OUTPUT if no G-Stops
        were present. (Exit if in DERIVS.)
   = 3  Return to the integrator.
   = 4  Compute G and return to <em>IVAG.
   = 5  A G-Stop has been found, and NSTOP gives its index.  (If NSTOP
        &lt; 0, the stop was an extrapolating stop.)
   = 6  Same as 5, but requested accuracy was not met.
   = 7  Same as 5, but there is a probable error in computing G.
   = 8  Fatal error of some type.  (An error message has been printed.)
 IG     (</em>IVAG)  IG = KORD(2) on the initial entry (0 for extrapolating
   G-Stops, and 1 for interpolating).
 IGFLG  (<em>IVAMC) Used primarily in </em>ivag, but also used in <em>iva to keep
   track of the state of GSTOP calculations.
   = -2 Extrapolatory G's initialized, but not the interpolatory.
   = -1 Interpolatory G's initialized, but not the extrapolatory.
   =  0 Set when integration is started or restarted, or option setting
        GSTOP is set.
   =  1 Iterating to find a GSTOP.
   =  2 User told that a GSTOP was found.
   =  3 Checking G's at point where a GSTOP was located.
   =  4 Checking G's at a T output point.
   =  5 Usual case, no sign change detected.
 IGSTOP (</em>IVAMC) IGSTOP(k) is set in <em>ivag to the index of the last G
   with a 0, where k is one for an interpolatory G-Stop, and k is two
   for an extrapolatory G-Stop.
 IGTYPE (</em>IVAMC) Array with two elements as for IGSTOP, but this saves
   a flag giving the nature of convergence to the stop.
   = 0  All known G-stops completely processed.
   = 4  Need to compute next value while iterating.
   = 5  Got good convergence.
   = 6  Got convergence, but not to desired accuracy.
   = 7  Problem in getting convergence.
   = 8  A fatal error of some type.
 IHI    (<em>IVA) Last location used by the current option.
 ILGREP (</em>IVAMC) Used when correction to keep track of equations that
   are to use a certain error tolerance.
 ILGROR (<em>IVACR) Index of last equation in the current group of
   equations grouped for selecting integration order.
 ILOW   (</em>IVA) First location used by the current option.
 INCOM  (<em>IVADE) Array equivalenced to LDT in the common block </em>IVASC.
   Used to simplify saving information in the common block.
 INCOP  (<em>IVAOP) Array containing data giving the amount of space in
   IOPT used for each of the options.
 INGS   Current index for G-stop being examined in DIVAG.
 INICAS (</em>IVADE) Used to track the initialization for a delay equation.
   = 1  Very beginning.
   = 2  Getting derivative at the very beginning.
   = 3  Getting derivatives at points prior to the initial point.
   = 4  Getting derivative at initial point after iteration is started.
 INTCHK (<em>IVA) Array passed to OPTCHK containing information on storage
   allocation.  See comments in OPTCHK for details.
 INTEG  (</em>IVAIN) Number of integrations being done. (&lt;0 for
   differentiations and =0 for interpolation.)  Also used as counter
   when computing integration coefficients.
        (<em>IVAPR) Number of integrations being done.
 INTEGS (</em>IVAPR) = -1 for equations that are not stiff, 0 for those
   that are stiff.
 INTEGZ (<em>IVAIN) min(INTEG, 0)
 INTERP (</em>IVAIN) added to the usual integration order to get the order
   to be used when interpolating: 3-KQMAXI, if HI=0; 1, if
   |HI| &gt; |XI(1)| and HI * XI(1) &lt; 0; 0, otherwise -- the usual case.
 IOP10  (<em>IVAMC) Number of times diagnostic output is to be given when
   leaving </em>ivacr (the corrector).
 IOP11  (<em>IVAMC) Gives current step number of the method.  Tells how
   many of certain coefficients must be computed. (Has nothing to do
   with options.) = min(max integ order + 1, KDIM).  Also set when
   starting to flag that certain memory locations must be set to 0.
 IOP12  (</em>IVAMC) Points to location in F() where user supplied values
   of HINC, HDEC, HMIN, and HMAX.  (0 if option 12 not used.)
 IOP13  (<em>IVAMC) If not zero, reverse communication will be used for
   getting the values of derivatives.  Associated with option 13.
 IOP14  (</em>IVAMC) If not zero, reverse communication will be used in
   place of calls to the output routine.  Associated with option 14.
 IOP15  (<em>IVAMC) If not zero, a return will be made to the user after
   the initialization.  Associated with option 15.  This might be used
   to overlay </em>iva, some of the user's code, and perhaps <em>ivaop.
 IOP16  (</em>IVAMC) Points to location in KORD() where information for
   specifying the error tolerance is specified.  See option 16.
 IOP17  (<em>IVAMC) Used in initialization for option 17, afterwards this
   cell is used by KEXIT which is equivalenced to IOP17.
 IOP18  (</em>IVAMC) Points to location in KORD() where information for
   specifying a grouping of equations for derivative evaluation is
   stored.  See option 18.
 IOP19  (<em>IVAMC) Points to location in KORD() where information for
   specifying a grouping of equations for integration order control
   is stored.  See option 19.
 IOP20  (</em>IVAMC) Used for option 20, gives first location in F where
   estimated errors are to be stored.  Expected to be useful in a
   program for solving boundary value problems using multiple shooting.
 IOP21  (<em>IVAMC) Was used for stiff equations option (never completely
   coded).  The optional code still uses this (don't activate it!).
   Now used to flag the location if F where the user has stored the
    tolerance to use in finding G-Stops.
 IOP21S (</em>IVAMC) Was used for stiff equations see above.
 IOP22  (<em>IVAMC) Set aside for possible option for stiff equations.
 IOP3   (</em>IVAMC) Value set by option 3.
   =  0 Interpolate to final point. (The default)
   =  1 Integrate to final point.
   = -1 Extrapolate to final point.
 IOP4   (<em>IVAMC) Value set by option 4.  The output routine is called
   with KORD(1) = 4, every IOP4 steps.  (Default value for IOP4 is a
   very large number.
 IOP5   (</em>IVAMC) Value provided by option 5, used to specify extra
   output points.
 IOP6   (<em>IVAMC) Value provided by option 6.  If nonzero, the output
   routine is called at the end of every step.  If &gt; 0, there are
   IOP6 interpolating G-Stops.
 IOP7   (</em>IVAMC) Value provided by option 7.  If &gt; 0, there are K7
   extrapolating G-Stops.
 IOP8   (<em>IVAMC) Value provided by option 8.  If nonzero, the output
   routine is called with KORD(1)=8 whenever the step size is changed.
 IOP9   (</em>IVAMC) Value provided by option 9.  Used to specify that the
   user wishes to save the solution.
 IOPIVA (<em>IVA) Used to save length of IOPT vector for error messages.
 IOPST  (</em>IVASC) Intended for possible use in stiff equations.
 IOPT   (formal <em>IVA and IVAOP) Used to specify options.
 IOPTC  (</em>IVAOP) In <em>IVAOP equivalenced so that IOPTC(3) is equivalent
   to IOP3.
 IOPTS  (</em>IVAOP) Array containing the current default values to be
   stored into IOPTC.
 IORD   (<em>IVACR) Index of first equation in the current group of
   equations grouped for selecting integration order.
 IOUTKO (</em>IVADC) Used in <em>IVADI to point to KORD to keep track of
   equation grouping for diagnostic output.
 ISVCOM (</em>IVADE) Used to save info. in the common block <em>IVASC.
 ITERS  (</em>IVADE) Counts iterations in starting delay differential
   equations.  Max. value for this is arbitrarily 100.
 ITOLEP (<em>IVAMC) Used for temporary storage, and for the index of a
   tolerance relative to the start of tolerances.
 IVC1   (</em>IVADB) Array used for output of variables IOPST to NUMDT in
   common block <em>IVASC.
 IVC2   (</em>IVADB) Array used for output of variables ICF to NY in
   common block <em>IVAMC.
 IWB    (</em>IVADE) Current base index for saving F values in WDE when
   starting delay differential equations.
 IY     (<em>IVAMC) Used for the current index to the Y() array.  (Local
   variable in </em>IVAIN used in computing IYI.)  Equivalenced to
   IZFLAG in <em>IVAG.
 IYI    (</em>IVAIN) Y(IYI) is currently being computed.
 IYN    (<em>IVAIN) Y(IYN) is base Y() corresponding to Y(IYI).
 IYNI   (</em>IVAIN) Used as base index for computing IYN as IY is for INI.
 IYO    (<em>IVADE) Points to first base value of Y for current
   interpolation when getting values for a delay differential equation.
 IZFLAG (</em>IVAG)  Equivalenced to IY.  Set to 0 initially, and later
   set to the value returned by <em>ZERO.
    = 0  Value set on entry at start of search.
    = 1  Compute next g again.
    = 2  Normal terminiation.
    = 3  Normal termination -- error criterion not satisfied.
    = 4  Apparent discontinuity -- no zero found.
    = 5  Couldn't find a sign change.
    = 6  </em>ZERO was called with a bad value in IZFLAG.
 J      For temporary storage. (In <em>IVA,A,BU,CR,DA,DB,DE,HC,IN,OP,PR)
 J1     (</em>IVAA &amp; DA) Used for temporary storage.
 J2     (<em>IVAA) Used for temporary storage.
 JL     (</em>IVA) Used for checking storage.
 JLGREP (<em>IVACR) Contents of first location of KORD (called LGROUP in
   </em>IVACR) for the current error tolerance rule.
 JLGROR (<em>IVACR) Contents of first location of KORD for the current
   integration order control.
 JLIM   (</em>IVA) Used for checking second item in KORD list for options
   16 and 19.
 K      For temporary storage.  (In <em>IVA,A,BU,CR,DA,DB,DE,HC,IN,OP,PR)
 KDIM   Parameter giving the largest number of differences supported.
        Used in all the routines.
 KEMAX  (</em>IVAMC) Index associated with equation giving the largest
   value for (estimated error) / (requested error).
 KEXIT  (<em>IVAMC) Equivalenced to IOP17 which is not used after
   initialization.  Defines actions when KORD2I = -7.  (Referenced in
   (</em>IVAA,DA,G).)
   =  1  Take the step over with reduced H.
   =  2  Take the step over.
   =  3  Do the end of step call to OUTPUT.
   =  4  Reset TMARK, then do same as for KEXIT = 2.
   =  5  Reset TMARK, then do same as for KEXIT = 3.
   =  6  Give the fatal error diagnostic.
 KFERR  (<em>IVA)  Temporary storage in checking for option 16.
 KGO    (</em>IVA)  Used to tell from whence a check is being done or an
   error message is being written.
   = 1 Checking an equation group for variational equations.
   = 2 Checking an equation group for diagnostic print.
   = 3 Checking an equation group for integration order control.
   = 4 Checking an equation group for error control.
   = 5 Checking an equation group for specifying ODE orders.
   = 6 Found a problem with output type for printing.
   = 7 Found a problem with an output group for printing.
   = 8 Found a problem with input NEQ.
   = 9 Order specified for the ODE's in the system is out of range.
   =10 Option 16 was not used (an error).
   =11 Error tolerance of 0 specified without proper flags.
 KIS    (<em>IVAMC) Used to check if it is time to dump the solution.
   The check involves incrementing KIS at the end of the step, and
   dumping the solution if KIS is 0.
   = -1  Set in </em>ivacr when it is time to dump solution
   =  0  When starting
   =  2  After being dumped.
   This is set to 1000 just after a user specified discontinuity, and
   counted up from that point.
 KMARK  (<em>IVAMC) Identifies the type of output associated with the next
   output point specified by TSPECS.
 KONV   (</em>IVADE) Counts iterations.  Test for convergence if KONV &gt; 1.
 KORD   (formal in <em>IVA,A,BU,CR,DA,DB,DE,G,IN,PR) KORD(1) is used to
   return flags for the user to test, and KORD(2) tells what routine
   the flag is associated with.  See KORD1I and KORD2I below and the
   write up for the program.  KORD(3) is used for communicating extra
   information to the user in some cases.  KORD(4) to KORD(NTE+3) are
   used for integration order for the equations, and the rest of KORD()
   is available for user options.
 KORD1I (</em>IVAMC) Helps in defining the state of the integrator.
   Frequently has the same value as KORD(1).  Meaning depends on the
   value of KORD(2), or the value about to be assigned to KORD(2).
   &lt;  0  Happens when preparing to give output with extrapolation.
   =  0  Happens when checking F at points for noise test.
   =  1  (KORD(2)=-1)  End of integration has been reached.
   =  1  (KORD(2)= 0)  Computing first predicted derivative.
   =  1  (KORD(2)= 1)  Output for initial point.
   =  2  (KORD(2)=-1)  Giving diagnostic for noise limiting precision.
   =  2  (KORD(2)= 0)  Computing corrected derivative.
   =  2  (KORD(2)= 1)  Output for TSPECS(3).
   =  3  (KORD(2)=-1)  Diagnostic for step size reduction too fast.
   =  3  (KORD(2)= 0)  Computing variational derivative.
   =  3  (KORD(2)= 1)  Output for TSPECS(4).
   =  4  (KORD(2)=-1)  Error, discontinuity.
   =  4  (KORD(2)= 1)  Output for certain number of steps.
   =  5  (KORD(2)= 0)  Get initial derivatives for stiff equations.
   =  5  (KORD(2)= 1)  Extra output from TSPECS.
   =  6  (KORD(2)= 1)  End of step output.
   =  7  (KORD(2)= 0)  Evaluate G before extrapolated output point.
   =  7  (KORD(2)= 1)  Evaluate G before extrapolated output point.
                       (Also used when checking for other G's after
                        finding one.)
   =  8  (KORD(2)= 1)  Tell user step size has changed.
   =  9  (KORD(2)= 1)  Request for user to save solution.
   = 11  (KORD(2)=-1)  Error, step size too small at end of start.
   = 12  (KORD(2)=-1)  Error, step size is too small.
   = 13  (KORD(2)=-1)  Error, output points specified badly.
   = 21  (KORD(2)=-1)  H too small to give reasonable change when added
                       to T.
   = 22  (KORD(2)=-1)  Error, bad tolerance.
   = 23  (KORD(2)=-1)  Set after message for a fatal error.
   = 24  Set on error message in <em>iva, along with KORD2I = -4.
   Also used as an index into MLOC in </em>IVAA when an error is being
   processsed, see MLOC below.
 KORD2I (<em>IVAMC) Helps in defining the state of the integrator.
   Frequently has the same value as KORD(2).
   = -3  Set in </em>ivag, to get a derivative evaluation.
   = -2  Set in <em>ivag, to get another entry to OUTPUT.
   = -1  Return to calling program, done, interrupt, or got an error.
   =  1  Calling OUTPUT or returning to user for OUTPUT type action.
   =  0  Calling DERIVS or returning to user for DERIVS type action.
   = -4  Error message in </em>iva and in <em>ivaop, along with KORD1I = 24.
   = -5  Starting
   = -6  Starting, getting the initial derivative value or derivatives
         for the noise test.
   = -7  Done some extrapolation, KEXIT defines the action to take.
         Set in </em>ivag to activate KEXIT action in <em>iva.
   = -8  Set when user has requested adjustment of the difference
         tables for a discontinutiy.
 KORDI  (</em>IVASC) Order of differential equation being integrated.  If
   all orders are the same, this set once at the beginning.
 KOUNT   (<em>IVADE) Count of number of points back from the initial point
   when solving a delay differential equation.
 KOUNTM  (</em>IVADE) Largest value currrently allowed for KOUNT.
 KOUNTX  (<em>IVADE) Largest value allowed for KOUNTM.
 KOUTKO  Used in DIVACR to track where output is wanted.
 KPRED  (</em>IVAMC) Value assigned to KORD1I when getting a predicted
   derivative.  (1 used now, 5 planned for use with stiff equations.)
 KQD    (<em>IVACR) = max(2, integration order)
 KQDCON (</em>IVAMC) Number of coefficients computed with constant step
   size for stiff equations.
 KQICON (<em>IVAMC) Number of coefficients computed with constant step
   size for nonstiff equations.
 KQL    (</em>IVACR) Integration order at start of (<em>IVACR)
 KQLORD (</em>IVACR) Saved value of KQL when equations are grouped for
   controlling the integration order.
 KQMAXD (<em>IVASC) Maximum integration order used for stiff equations.
 KQMAXI (</em>IVASC) Maximum integration order used for nonstiff equations.
 KQMAXS (<em>IVAMC) Maximum integration order for equations that have
   some limit on the error that can be committed.
 KQMXDS (</em>IVAMC) Used to save KQMAXD in case step is repeated and the
   solution must be dumped.
 KQMXI  (<em>IVAIN) Maximum integration order used for integration or
   interpolation, = KQMAXI+INTERP-1.
 KQMXS  (</em>IVAIN) Maximum step number, = max(KQMXI, KQMAXD).
 KQMXIL (<em>IVAMC) Value of KQMAXI the last time integration coefficients
   were computed.
 KQMXIP (</em>IVAMC) = KQMAXI + MAXINT, for computing integration coeffs.
 KQMXIS (<em>IVAMC) Used to save KQMAXI in case step is repeated and the
   solution must be dumped.
 KQN    (</em>IVACR) Value of integration order at end of <em>IVACR.
 KQQ    Used for the integration order for current equation.  (Values
   &lt; 0 are intended for stiff equations.)  (In </em>IVA,BU,DA,IN,PR)
 KSC    (<em>IVAMC) Number of steps that have been taken with a constant
   step size.
 KSOUT  (</em>IVAMC) When KSTEP reaches this value, the output routine is
   called with KORD(1) = 4.  The default value is a very large number.
 KSSTRT (<em>IVAMC) Set when ending one derivative per step to KSTEP + 2.
   Checked later in </em>IVAHC to decide whether to set the step changing
   factors to their nominal values.
 KSTEP  (<em>IVAMC) Number of steps taken since the start of integration.
 L      Used for temporary storage.  In </em>IVAIN, L is the initial value
   of LDT, except L=1 if LDT=-1, and MAXINT .ge. 0.  (Used in <em>IVAA,BU
   CR,DA,DB,IN,PR.)
 LAHAG  (</em>IVADB) Used to get proper offset into an diagnostic message.
 LAIAG  (<em>IVADB) Used to get proper offset into an diagnostic message.
 LDIS   (</em>IVAA) Count of steps since user flagged a discontinuity.
 LDT    (<em>IVASC) Used to keep track of state of difference table.
   = -5  Used only on first step to indicate that an extra iteration
         is desired to get a firm estimate on the error.
   = -4  Set on initialization before there is any difference table.
   = -3  Set just after predicting, interpolation is not allowed when
         this value is set.
   = -2  Set when difference table is to be updated to the end of the
         current step, but no interpolation is to be done.  (For
         dumping the solution.)
   =  0  Calculations for current step are complete, it is not o.k. to
         update the difference table.
   =  1  Difference table has been updated to the end of the current
         step, e.g. by doing an interpolation.
   =  2  Set when doing a special interpolation during computation of
         derivatives.  (For delay equations.)
 LEX    (</em>IVAMC) Indicates how to get values at next output point:
   = -1  Extrapolate
   =  0  Interpolate (The usual case.)
   =  1  Integrate to the output point, integration is not continued.
 LGO    (<em>IVAIN) Used as an an assigned go to.  Result is to add in
   extra correction term when LDT has been set to 2.
 LGROUP (formal) This is a part of KORD passed into </em>IVACR.  The first
   location is the start of the information on the grouping of
   equations for error control.
 LINC   (*IVAMC) Used to indicate state of step size selection.
   = -10 After computed derivatives at base time, after computing other
         extra derivatives for the noise test.
   = -9  After computed second extra derivative for noise test.
   = -8  After computed first extra derivative for noise test.
   = -7  Dumping the solution and then doing a user initiated restart,
         or getting ready to compute extra derivatives for the noise
         test.
   = -6  Dumping the solution before a restart.
   = -5  Set on the first step, and also set when dumping the solution
         after a discontinuity.
   = -4  Repeat step with no change in the step size.
   = -3  Set when the error tolerance is set improperly.
   = -2  User has complete control of selecting the step size.
   = -1  Step is being repeated.
   =  0  Step size is not to be increased on this step.
   = k&gt;0 Step size can be increased by HINCC</strong>k.
 LINCD  (<em>IVAMC) Value of smallest k for which HINCC</em><em>k .ge. 2.
   (=-2 if user is specifying all step size changes.)
 LINCQ  (</em>IVAMC) Value of smallest k for which HINCC<strong>k .ge. 4.
 LIOPT  (<em>IVAOP) Value of the last index in IOPT on the last call.
   Used so </em>IVA can print IOPT in error messages.
 LL     (<em>IVACR) Temporary variable used when equations are grouped
   for integration order control.
 LNOTM1 (</em>IVAIN) Logical variable = L .ne. -1.  If LNOTM1 is true,
   storage in Y() is different in some way lost to antiquity.  Such
   a case can only arise in the case of stiff equations.
 LOCF1  (<em>IVADB) Gives packed data needed for output of tables by the
   message processor MESS.  See comments there under METABL for defs.
 LOCF2  (</em>IVADB) As for LOCF1 above.
 LOCM   (<em>IVAA) Parameter = 32</em>256, used to unpack integers stored
   in MLOC for use in error message processing.
 LPRINT (formal, <em>IVADB) Defines how much printing is to be done in
   </em>IVADB.  Let |LPRINT| = 10<em>N1 + N2     (N1,N2 digits)
    N1=1   Do not print any variables external to the integrator.
    N1=2   Print  tspecs, current y, past y, current f, all pertinent
           contents of KORD, and TOL.
    N1=3   Above + difference tables up to highest difference used.
    N1=4   Same as N1=1 + all in storage allocated for differences.
    N2=1   Do not print any variables internal to the integrator.
    N2=2   Print all scalar variables in interpolation common block.
    N2=3   Above + all scalar variables in main integ. common block.
    N2=4   Same as N1=3 + all used in arrays XI,BETA,ALPHA, first
           column of G, GS,RBQ,SIGMA
    N2=5   Same as N1=4 + all used in arrays G,D,DS,V
 LSC    (</em>IVAMC) Indicates if starting or if noise may be present.
   =k&lt;0 -k steps have been taken for which noise appears to be limiting
        the precision.
   = 0  Usual case
   = 1  Doing 1 derivative per step after initial part of start.
   = 2  Used as flag that it is time to set LSC=0.
   = 3  Third step, hold the order constant.
   = 4  Second step, increase orders from 2 to 3.
   = 5  First step, third time through the first step (if required).
   = 6  First step, second time through.
   = 7  First step, first time through.
   = 8  Set on initialization.
 LTXT?? Names of this form are used in setting up data statements for
   error messages.  These names are generated automatically by PMESS,
   the program that makes up these messages.
 LX     (<em>IVAA) Used for temporary storage in computing TMARKA().
        ( formal </em>IVADE)  An integer array containing extra
   information, as follows.
  LX(1) Points to a location in Y beyond those already in use.  Values
        of Y requested are computed at TSPECS(1) - Y(LX(1)) and stored
        starting at Y(LX(1)+1).  If this index is 0, no more extra Y
        values are to be computed.
  LX(2) Index of the first equation for which the Y's above are to be
        computed.  Y(LX(1)+1) will correspond to this first equation
        index.
  LX(3) Index of the last equation for which the Y's above are to be
        computed.  Thus the Y's stored starting at Y(LX(1)+1) will
        require no more space than half the space ordinarily required
        for the array Y(), and may require significantly less.
  LX(4) Maximum number of times to integrate F to get Y.  This should
        be &gt; 0, and less than or equal to the order of the highest
        order differential equation.  (= 0 is allowed, but probably
        not what you want.  It would give a value only for F.)  Space
        must be set aside for all integrals of F, even if not all are
        requested.  For a first order system, all Y's are just the
        first integrals of the corresponding F's.  For higher order
        equations, the first Y associated with a given F is the d-th
        integral of the corresponding F, where d is the order of the
        equation, and the last Y corresponding to the F is the first
        integral of that F.
  LX(5) As for LX(4), but gives the index for the fewest number of
        times to integrate F.  Ordinarily this should be &gt; 0.  If 0 is
        requested, an estimate for the value of F at the delay point is
        computed.  This should not be 0 more than once, for equations
        covering the same index, since later such requests would write
        over the earlier results.
  LX(5i+k) , k = 1, 2, ... 5.  Treated as for the cases above.  If i
        different cases of delayed Y's are to be computed, then
        LX(5i+1) must be 0.
 LX2    (<em>IVADE) Value of LX(5i+2), when working on the i-th delay.
 MACT   Used in the programs which call the error message program.
   This array difines the actions to be taken by that program.  (In
   (</em>IVA,A,DA,DE,G,IN,OP)
 MACT0  (<em>IVADB) Used to call the message program, see MACT.
 MACT?  As for MACT, in (</em>IVA,CR,DB)
 MACTFV (<em>IVADB) As for MACT0.
 MAXDIF (</em>IVASC) Maximum differentiations required for stiff equations.
 MAXINT (<em>IVASC) Maximum integrations required.  (= max. order of
   differential equations if equations are not stiff.)
 MAXKQ  (</em>IVA, BU)e
 MAXKQD (<em>IVAMC) Largest integration order allowed for stiff equations.
 MAXKQI (</em>IVAMC) Largest integ. order allowed for nonstiff equations.
 ME???? Parameters defining constants used for interaction with the
   error message program MESS.  See comments there for definitions.
   (In <em>IVA,A,DA,DE,G,IN,OP)
 METHOD (</em>IVAMC) Defines kind of methods being used.
   = -1  Only stiff equations are being integrated.
   =  0  Only nonstiff equations are being integrated.
   =  1  Both kinds of methods are required.
 MLOC   (<em>IVA,A,DE) Contains locations in MTEXT for error messages.  In
   </em>IVAA this data is packed using MLOC??, see below.
 MLOC?? (<em>IVAA) Parameters constructed to aid in making up packed data
   for processing error messages.  Low two digits give the value of
   KORD1I to use for the error index and later processing, the next two
   give the error severity level, and the rest point to text used for
   the message.
 MODF2  (</em>IVADB) Used in constructing the same kind of packed data as
   described for LOCF1 above.
 MULTJ  Local to DIVAOP for calls not using F.
 MTEXT  (<em>IVA,A,CR,IN,OP) Text for error messages.
 MTXT?? (</em>IVA,A,CR,DA,DB,DE,G,IN,OP) Equivalenced into MTEXT.
 N      Used for temporary storage.  (In <em>IVAHC,IN,PR)
 NDTF   (</em>IVASC) Location in F() where difference table starts.
 NE     (<em>IVAMC) Number of equations in the first group.  (=NTE if
   option 18 is not used.)
 NEDDIG (</em>IVADB) Parameter = -MEDDIG.
 NEPTOL (<em>IVAMC) Used for temporary storage and to save the value of
   ITOLEP for error messages.
 NEQ    (formal) Total number of equations being integrated.
 NG     (</em>IVAMC) Used in <em>ivag for the number of g's in the current
   context.
 NGSTOP (</em>IVAG) Dimension 2 array equivalenced to IOP6, and IOP7.  To
   get the number of interpolating and extrapolating G-Stops.
 NGTOT  (<em>IVAMC) NGTOT(1) gives the number of interpolating G-Stops,
   and NGTOT(2) gives the number of extrapolating G-Stops.
 NKDKO  (</em>IVASC) If this is nonzero (option 17), it gives the location
   in KORD() where a vector defining the order of each equation is
   specified.
 NLX    (<em>IVADE) Temporary index used to keep track of interpolations
   being done to get Y() values for a delay differential equation.
 NOISEQ (</em>IVAMC) max(2, order of equation for which (error estimate)/
   (error requested) is a maximum).
 NOUTKO (<em>IVAMC) If nonzero, gives the index in KORD where information
   on what equations are to be included in the diagnostic output is
   given.   See option 10.
 NSTOP  (formal) In </em>IVAG.  Index of the G-stop, see IFLAG.
 NTE    (<em>IVASC) Total number of equations being integrated = NEQ.
 NTEXT  (formao </em>IVADB) Character variable containing heading text.
 NTOLF  (<em>IVAMC) First location in F() where tolerance specifying
   accuracy desired is stored.
 NUMDT  (</em>IVASC) Maximum allowed number of differences available for
   doing an integration.
 NXTCHK (<em>IVA) Equivalenced to INTCHK(1), which gives the next
   available location in INTCHK for storing data on storage allocation.
 NY     (</em>IVAMC) Total order of the system.
 NYNY   (<em>IVASC) Location in Y() where the base value for Y() is saved.
 NYNYO  (</em>IVADE) Equivalenced to the saved value from common of NYNY.
 OUTPUT (formal) Name of subroutine to be called for the output of
   data or for computing G-Stops.  Not used if option 14 is set.
 OVD10  (<em>IVAEV) (largest floating point number) / 10.
 OVTM75 (</em>IVAEV) (largest floating point number) </strong> (-.75)
 RBQ    (<em>IVAMC) Array containing data for the preliminary noise test.
 RD     (formal </em>IVACO) Array use to contain floating point data from
   common.  Values are returned in locations 1 to 3 as follows.
   1    EMAX =  Max. ratio of estimated error to requested error
   2            Reserved for future use
   3            Reserved for future use
 REF    (<em>IVACR) Array of length 3 used for translating error tolerance
   type into the factor used for exponential averaging for that type.
 RND    (</em>IVACR) Usually the current estimated error.  Used in deciding
   if noise is limiting precision.
 RNOISE (<em>IVACR) Value used in comparison with RBQ() for preliminary
   noise test.
 ROBND  (</em>IVAMC) Used to influence the selection of integration order.
   The larger ROBND, the harder it is to increase the order and the
   easier it is to decrease it.
 RVC2   (<em>IVADB) Array used for output of variables DNOISE to SNOISE in
   common block </em>IVAMC.  These are variables that don't require a great
   deal of precision.
 S      (<em>IVACR) Estimate of (step size) * eigenvalue of Jacobian.
 SIGMA  (</em>IVAMC) The k-th entry of this array contains a factor that
   gives the amount the k-th difference is expected to increase if the
   step size in increased.  These numbers get bigger it there is a past
   history of increasing the step size.
 SIGMAS (<em>IVAA) Saved value of SIGMA(k) from the last step, where k =
   integration order for equation with index KEMAX.
 SNOISE (</em>IVAMC) Value used in comparison with RBQ() on equation with
   largest value for (error estimate) / (error requested).
 T      (formal) in <em>IVAIN. T(1) contains the point to be interpolated
   to, and T(2) is used in a check that |HI| .le. |T(2)|.  When used by
   other routines in this package, TSPECS is passed in for T.
 TB      (</em>IVADE) Base time for current interpolation.
 TC      (<em>IVADE) Original value of TN when getting past Y's for a
   delay differential equation.
 TEMP   Used for temporary storage, in </em>IVAHC,PR
 TEMPA  (<em>IVACR) Array equivalenced to (TPS1,TPS2,TPS3,TPS4).
 TEMPAO (</em>IVACR) Array used to accumulate values in TEMPA.
 TG     (<em>IVAMC) TG(1) gives the last value of TSPECS(1) for which an
   interpolatory G-Stop has been computed.  TG(2) is defined similarly
   for extrapolatory G-Stops.
 TGSTOP (</em>IVAMC) TGSTOP(1) gives the value of TSPECS(1) where the last
   0 for an interpolatory G-Stop was found.  TGSTOP(2) is defined
   similarly for extrapolatory G-Stops.
 TMARK  (<em>IVAMC) Location of the next output point.
 TMARKA (</em>IVAA)  Array of length 2 equivalenced to TMARK (and TMARKX).
 TMARKX (<em>IVAMC) Location of the next output point to be found using
   integration or extrapolation.  This variable must follow immediately
   after TMARK in the common block.
 TN     (</em>IVASC) The value of TSPECS(1) at the conclusion of the last
   step.
 TNEQ   (<em>IVADB) Array of dimension 1 equivalenced to TN so that an
   array can be passed to </em>MESS.
 TOL    (formal) This is a part of F passed into <em>IVACR.  The first
   location is the start of the information on the tolerances for error
   control.
 TOLD   (</em>IVAG) Value of TSPECS(1) on one side of a zero.
 TOLG   (<em>IVAMC) Tolerance to pass to dzero when locating G-Stops.
 TOUT   (</em>IVAMC) Location of next output point defined by value of
   TSPECS(3).  Such output is given with KORD(1) = 2.
 TP     (<em>IVA,A,DA,DE,HC) Used for temporary storage.
 TP1    (</em>IVAA,DA,HC,IN,PR) Used for temporary storage.
 TP2    (<em>IVAA,DA,HC,PR) Used for temporary storage.
 TP3    (</em>IVAA) Used for temporary storage.
 TPD    (<em>IVABU) Used for temporary storage.
 TPP    (</em>IVACR) Used for temporary storage.  Usually same as TPS3.
 TPS1   (<em>IVAA,CR) Used for temporary storage.  (In </em>IVACR is the
   difference of order KQQ-2)
 TPS2   (<em>IVAA,CR) Used for temporary storage.  (In </em>IVACR is the
   difference of order KQQ-1)
 TPS3   (<em>IVACR) Contains the difference of order KQQ.  This is the
   last difference used in the corrector.
 TPS4   (</em>IVACR) Contains the difference of order KQQ+1.
 TPS5   (<em>IVACR) Temporary storage.
 TPS6   (</em>IVACR) Temporary storage.
 TPS7   (<em>IVACR) Temporary storage.
 TSAVE  (</em>IVAG) Value of TSPECS(1) before starting the search for a 0.
 TSPECS (formal <em>IVA,A,DB,DE,G)
   TSPECS(1) is the current value of the independent variable.
   TSPECS(2) is the current value of the step size.
   TSPECS(3) is the increment to use between output points that give
             output with KORD(1) = 2.
   TSPECS(4) is the "final" output point.
 V      (</em>IVAMC) Array used in computing integration coefficients.
 XI     (<em>IVASC) XI(K) = TSPECS(1) - value of TSPECS(1) K steps
   previous.
 W      (</em>IVAHC) Array used in computing integration coefficients.
 WDE    (formal, <em>IVADE)  Array used for working storage.  This storage
   is used to save derivative values when iterating to get started.  To
   be safe one should allow as much space as is allowed for differences
   in F.  In most cases the start will not require this much space
   however.  This array is also intended for the support of saving long
   past histories.
 Y      (formal, </em>IVA,A,CR,DA,DB,DE,G,IN,PR) Array containing the
   independent variable and all derivatives up to order one less than
   the order of the differential equation.  Also use to save these
   values at the beginning of the current step, the base values.
 YN     (formal, in *IVAPR)  Base values of y, these follow the
   current values of the dependent variable, y, in Y().</p>
<p>++S Default KDIM = 16
++  Default KDIM = 20
++  Default MAXORD = 2, MAXSTF = 1
++  Default INTEGO, VAREQ, OUTPUT, DUMP, GSTOP, EXTRAP
++  Default STIFF=.F., ARGM=.F., ERRSTO=.F.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-idimf"></span>integer</td>
  <td></td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>IDIMF</strong></td><td><blockquote>
<p>2015-03-15 DIVA  Krogh  Removed extra call divabu after noise test
2015-03-15 DIVA  Krogh  Forced restart needs more reduction in h.
2010-02-20 DIVA  Krogh  Fixed calling DIVAOP with array other than F.
2009-11-03 DIVA  Krogh  Added option 11, more variables initialized.
2009-10-30 DIVA  Krogh  Gave KSSTRT and ROBND initial values.
2009-10-30 DIVA  Krogh  Fixed reference to undefined location in F.
2009-10-21 DIVA  Krogh  Got rid of NaN in diag. print when LSC=3.
2009-10-15 DIVA  Krogh  A few changes on how noise is handled.
2002-11-12 DIVA  Krogh  Fixed problem integrating to final output pt
2002-08-29 DIVA  Krogh  Added test for invalid HMIN/HMAX.
2002-07-26 DIVA  Krogh  Added KOUTKO to fully support Option 10.
2002-05-14 DIVA  Krogh  Fix starting prob. for Option 18.
2002-05-13 DIVA  Krogh  Put exponent letter in  numbers missing them
2002-05-12 DIVA  Krogh  Added error message for bad option 5 usage.
2001-09-07 DIVA  Krogh  Changes to allow user tol on G-Stops.
2001-05-25 DIVA  Krogh  Minor change for making .f90 version.
2001-05-18 DIVA  Krogh  Less computing with no error test
2001-05-17 DIVA  Krogh  Fixed so with no error test can't start dump
2001-04-24 DIVA  Krogh  Inserted comments from ivacom.
2000-12-01 DIVA  Krogh  Removed (some of) unused C1, MAXSTF, METEXT.
1999-12-28 DIVA  Krogh  Saved S in DIVACR for output consistency.
1999-08-19 DIVA  Krogh  Removed superfluous test above label 3520.
1997-04-22 DIVA  Krogh  Got rid of assigned go to's. F=0 if diag.
1996-08-26 DIVA  Krogh  Initialize F to 0 if dumping solution.
1996-08-23 DIVA  Krogh  Print TN not TSPECS(1) in error messages.
1996-05-30 DIVA  Krogh  Changed DERIVS/OUTPUT to  DIVAF/DIVAO.
1996-04-27 DIVA  Krogh  Changes to use .C. and C%%.
1996-03-30 DIVA  Krogh  Added external statement.
1996-03-25 DIVA  Krogh  Introduced TEXT1 to comply with F77.
1996-02-27 DIVA  Krogh  Fixed so DUMP not affected by ignored eqs.
1995-12-18 DIVA  Krogh  Fixed so no solution dump on 0 length integ.
1995-11-09 DIVA  Krogh  Fixed so char. data at col. 72 is not ' '.
1995-06-19 DIVA  Krogh  Fixed prob. with discon. just after restart.
1995-05-09 DIVA  Krogh  Fixed G-Stop/discontinuity code interaction
1995-04-26 DIVA  Krogh  Use KQMAXS instead of KQMAXI when LDIS&gt;1000.
1995-04-26 DIVA  Krogh  Keep current KQL on discontinutiy.
1994-12-16 DIVA  Krogh  Fixed option 12 with K12 &lt; 0.
1994-11-11 DIVA  Krogh  Declared all vars.
1994-11-02 DIVA  Krogh  Changes to use M77CON
1994-09-08 DIVA  Krogh  Added CHGTYP code.
1994-07-11 DIVA  Krogh  Fix to get same state with/without var. eqs.
1994-03-07 DIVA  Krogh  Allow larger order in single precision.
1994-01-14 DIVA  Krogh  Minor change to allow changing TFINAL.
1993-04-27 DIVA  Krogh  Additions for Conversion to C.
1993-04-12 DIVA  Krogh  Converted to use slightly altered MESS.
1993-04-12 DIVA  Krogh  Fixed LSC so sol. saved when HMAX is small.
1992-10-13 DIVA  Krogh  Fixed G-Stop/discontinuity code interaction.
1992-09-21 DIVA  Krogh  Fixed bug in discontinuity code.
1992-09-09 DIVA  Krogh  Fixed bug - Var. Eqs. with discontinuities.
1992-08-07 DIVA  Krogh  Storage map printed only if option 10 .ne. 0
1992-07-16 DIVA  Krogh  Restored correct discontinuity code.
1992-06-16 DIVA  Krogh  Eliminate reuse of storage for option 12.
1992-04-08 DIVA  Krogh  Removed unused labels, 1020, 2120.
1992-03-30 DIVA  Krogh  Fixed bug in DIVAOP error message.
1992-03-12 DIVA  Krogh  Simplified DIVABU, more digits in B's.
1992-01-16 DIVA  Krogh  Fixed minor bug in error messages.
1991-12-03 DIVA  Krogh  Major change for improved error checks.
1991-06-17 DIVA  Krogh  Fixed bug in checking storage allocation.
1991-04-11 DIVA  Krogh  Fixed minor bug re. option 12 in DIVAOP.
1991-03-28 DIVA  Krogh  Removed check at label 650 for KORD2I&lt;0.
1991-02-08 DIVA  Krogh  Changed some floats to generics
1990-11-08 DIVA  Krogh  Fixed bug on TSPECS on discon.
1990-09-14 DIVA  Krogh  Fixed bug when discon. and sol. save.
1990-09-13 DIVA  Krogh  Increased dimension of BETA by 1.
1990-09-13 DIVA  Krogh  Added one more poss. on rel. error test.
1990-09-11 DIVA  Krogh  Recent change messed up getting dump output.
1990-06-05 DIVA  Krogh  Fixed bug in noise test, comments in IVACOM.
1990-05-08 DIVA  Krogh  Fixed new bug when TMARK hit in DIVAG.
1990-04-17 DIVA  Krogh  Fixed minor problem in DIVAIN error msg.
1990-04-10 DIVA  Krogh  Fixed interaction between discon. &amp; dump.
1990-03-23 DIVA  Krogh  Fixed bug on option "-2", see 1989-12-07.
1990-03-20 DIVA  Krogh  Fixed rarely occuring loop.
1990-01-29 DIVA  Krogh  Removed unneeded labels.
1989-12-14 DIVA  Krogh  Saved common block DIVAEV.
1989-12-07 DIVA  Krogh  Added option "2" to DIVAOP.
1989-11-09 DIVA  Krogh  Made GG a save var. in DIVAHC
1989-08-21 DIVA  Krogh  Fix out of bounds ref. to V in DIVABU
1989-07-26 DIVA  Krogh  Fix bug in initial dim. check
1989-07-21 DIVA  Krogh  Code for integrating discontinuities
1987-12-07 DIVA  Krogh  Initial code.</p>
</blockquote>
<p>--D replaces "?": ?IVA,?IVAA,?IVABU,?IVACO,?IVACR,?IVAEV,?IVAF,?IVAHC,
-- &amp; ?IVAG,?IVAIN,?IVAMC,?IVAO,?IVAOP,?IVAPR,?IVASC,?IVACE,?IVAIE,
-- &amp; ?IVAPE,?MESS</p>
<p>Note a "*" at the start of a name is used to indicate "D" for the
 double precision version and "S" for the single precision version.</p>
<p>When converting between precisions, don't forget to change the value
 of KDIM set in parameter statements in a variety of routines, and to
 adjust comments for the data statements associated with EIBND in
 <em>IVACR, and B in </em>IVAHC.</p>
<p>Entries
  <em>IVA    Main entry for starting the package.
  </em>IVAA   Main program inside the package, calls the other routines,
          and does checks for output, and noise.  Called by the user
          if reverse communication is used.
  <em>IVABU  Back ups the solution to the current base time, if a step
          that has been started must be taken over for some reason.
  </em>IVACO  Called by user to get certain information from the common
          blocks.
  <em>IVACR  Corrects the solution, estimates errors, and selects order.
  </em>IVADB  Subroutine to assist in debugging codes.  Called by user to
          get a formatted list of all the variables used in the
          integration.  Not required in usual case.
  <em>IVADE  Needed only for delay differential equations.  This is called
          by the user from the derivative subprogram.
  </em>IVAG   Required only if the user has G-Stops, i.e. places to call
          his output subroutine where certain functions have zeroes.
  <em>IVAHC  Compute coefficients that depend on the step size history.
  </em>IVAIN  Used to interpolate to arbitrary points.
  <em>IVAOP  Used to process user option requests.
  </em>IVAPR  Used to update the differences and to predict the solution
          at the end of the current step.</p>
<p>External Routines
  <em>1MACH  Not used in the Fortran 95 version.  ("</em>" is "D" for double
          and "R" for single precision.) This returns constants that
          depend on the floating point arithmetic.  Input arguments of
          1 to 4 give respectively:  underflow limit, overflow limit,
          smallest relative difference between two floating point
          numbers, and the largest relative difference between two
          floating point numbers.
 DERIVS (formal) Name of subroutine to be called for computing
  OPTCHK  Used in checking storage allocation.
  <em>MESS   Used to output error messages and diaganostic messages.
          (Just MESS if no floating point is output.)
  </em>ZERO   Called only if *IVAG is used.  Iterates to find zeros of
          arbitrary (continuous) functions.</p>
<p>Common blocks -- As a left over from the distant past, some variables
   are in common so that they would be saved.
  <em>IVAEV  Holds variables that depend on the environment.
  </em>IVAMC  The main common block for the package.
  *IVASC  The secondary common block for the package.  This contains
          variables that are required for doing interpolation and is
          separate to simplify saving the variables that are required
          when the solution is being dumped (saved).</p>
<p>Common variables and local variables
 ALPHA  (<em>IVAMC) Array with I-th entry = (current step size) / XI(I).
   Used in computing integration coefficients.
 B      (</em>IVAHC) Array used to get started on computing integration
   coefficients.  B(K) = 1. / (K<em>(K+1))
 BAKMIN (</em>IVADE) The largest delay at the initial point.
 BETA   (<em>IVAMC) Array with I-th entry = product (K=1,I-1) of
   (current (XI(K)) / XI(K) from previous step),  BETA(1)=1.  Used in
    updating the difference tables.
 C      (</em>IVAIN) Array used to hold integration/interpolation coeffs.
 C0     Parameter = 0. (in <em>IVAA,DE,CR,A,G,HC,IN,OP,PR)
 C1     Parameter = 1. (in </em>IVA,A,CR,DA,HC,IN,OP)
 C10    Parameter = 10. (in <em>IVAA,CR,OP)
 C1000  Parameter = 1000. (in </em>IVACR)
 C16    Parameter = 16. (in <em>IVAA,OP)
 C1M3   Parameter = .001 (in </em>IVAA)
 C1M5   Parameter = .00001 (in <em>IVAA)
 C1P125 Parameter = 1.125 (in </em>IVAA,HC,OP)
 C1P3   Parameter = 1.3 (in <em>IVAA)
 C1P4   Parameter = 1.4 (in </em>IVACR)
 C2     Parameter = 2. (in <em>IVAA,DE,BU,CR,IN,OP)
 C20    Parameter = 20. (in </em>IVACR)
 C2P5M3 Parameter = .0025 (in <em>IVAA)
 C4     Parameter = 4. (in </em>IVACR,OP)
 C40    Parameter = 40. (in <em>IVACR)
 C4096  Parameter = 4096. (in </em>IVAA)
 C6     Parameter = 6. (in <em>IVAA)
 C8M3   Parameter = .008 (in </em>IVAA)
 CM2    Parameter = -2. (in <em>IVACR)
 CM8    Parameter = -8. (in </em>IVACR)
 CMP5   Parameter = -.5 (in <em>IVACR)
 CMP75  Parameter = -.75 (in </em>IVAOP)
 CP0625 Parameter = .0625 (in <em>IVAA)
 CP1    Parameter = .1 (in </em>IVAA,CR,DA,HC)
 CP125  Parameter = .125 (in <em>IVACR)
 CP25   Parameter = .25 (in </em>IVAA,CR,DE,OP)
 CP3    Parameter = .3 (in <em>IVAA,OP)
 CP4    Parameter = .4 (in </em>IVAA)
 CP5    Parameter = .5 (in <em>IVAA,CR,DA,DE,HC,OP)
 CP5625 Parameter = .5625 (in </em>IVAHC)
 CP625  Parameter = .625 (in <em>IVAOP)
 CP75   Parameter = .75 (in </em>IVACR,OP)
 CP8    Parameter = .8 (in <em>IVACR)
 CP875  Parameter = .875 (in </em>IVAA, OP)
 CP9    Parameter = .9 (in <em>IVAOP)
 CP9375 Parameter = .9375 (in </em>IVACR)
 CQ3125 Parameter = .03125 (in <em>IVACR)
 CRBQI  Parameter = .421875 (in </em>IVAHC)  Initial val for computing RBQ.
 CSUM   (<em>IVAIN) Array used to contain partial sums of the integration
   coefficients.  This is used to corrrect for a difference table that
   has not yet been updated.
 D      (</em>IVAMC) Array to be used later to store coefficients for
   integrating stiff equations.
   derivatives.  Not used if option 13 is set.
 DISADJ (<em>IVAA) Value of stepsize when discontinuity is indicated.
 DNOISE (</em>IVAMC) Used in determining if noise is limiting the
   precision.  It is usually |highest difference used in correcting|
   of the equation with the largest error estimate.
 DS     (<em>IVAMC) Array to be used later to store coefficients for
   estimating errors when integrating stiff equations.
 DVC2   (</em>IVADB) Array used for output of variables HC to TOUT in
   common block <em>IVAMC.
 E      (</em>IVACR) (Estimated error) / (Requested accuracy)
 EAVE   (<em>IVAMC) This is a weighted average of past values of EIMAX.
   It is adjusted to account for expected changes due to step changes.
 EEPS10 (</em>IVAEV) = 10. * (machine epsilon).
 EEPS16 (<em>IVAEV) = 16. * (machine epsilon).
 EEPS2  (</em>IVAEV) =  2. * (machine epsilon).
 EEPT75 (<em>IVAEV) = (machine epsilon) </em><em> (.75)
 EI     (</em>IVACR) Estimate for what E would be if step size increased.
 EIBND  (<em>IVACR) Array containing limits on the estimated error with
   the stepsize increased.  This array tends to make the code a little
   more conservative on step size increases at low order.
 EIMAX  (</em>IVAMC) Estimate of (error estimate / error requested) if the
   step size should be increased.
 EIMIN  (<em>IVAMC) An error estimate is small enough to allow a step
   increase if the estimate of ((error with the step size increased) /
   (error requested)) is less than EIMIN.
 EIMINO (</em>IVAA) Set to C8M3 and never changed.  When step size is being
   reduced if EIMIN .le. EIMINO then the reduction factor is set to
   CP875.  This variable could be a parameter.
 EMAX   (<em>IVAMC) Largest value computed for (error estimate) / (error
   requested).
 EOVEP2 (</em>IVAEV) = EEPS2 * (largest floating point number).
 EPS    (<em>IVACR) Current absolute error tolerance.  Also used for
   temporary storage when computing the desired value of EPS.
 ERCOEF (</em>IVACR) (Error coefficient from formula) / EPS
 EREP   (<em>IVAMC) If EMAX &gt; EREP, a step is repeated.  Ordinarily
   this has the value .3.  This is set &lt; 0 if the error tolerance is
   specified improperly, and is set to a large value if the user
   requests complete control over the step size.  EREP is also set
   &lt; 0 after a user specified discontinuity.
 EROV10 (</em>IVAEV) = 10. / (largest floating point number).
 ETA    (<em>IVAIN) Array used in computing integration/interp. coeffs.
 EVC    (</em>IVADB) Array used for output of variables EEPS2 to EROV10 in
   common block <em>IVAEV.
 EXR    (</em>IVAA) Set to CP1 and never changed.  If it is estimated the
   the (error estimate) / (error requested) on the next step will be
   .ge. EXR then the step size is reduced.  Could be a parameter.
 F      (formal) Array used to store derivative values, the difference
   tables, error tolerance requests, and values used by some other
   options. (in <em>IVA,A,BU,CR,DA,DB,G,IN,PR)
 FDAT  (</em>IVAMC) Used to store data for error messages.  (Local array in
   <em>IVAIN.)
 FOPT  (formal) in </em>IVAOP.  Passed as place to save floating point data
   for options.  This package passes F in for FOPT when calling <em>IVAOP.
 G      (</em>IVAMC) Integration coefficients used for predicting solution.
   G(I, J) gives the I-th coefficient for integrating a J-th order
   differential equation.  G(1, 1) is equal to the step size.
 GAMMA  (<em>IVAIN) Array used in computing integration/interp. coeffs.
 GG     (</em>IVAHC) Array of length = max. differential equation order
   allowed by code - 1.  GG(K) = (HH<strong>(K+1)) / K!
 GNEW   (formal) in <em>IVAG.  Current value for vector function g, whose
   zeroes are to be found.
 GOINT  (</em>IVACR) Used for assigned go to used in computing integration
   coefficients.
 GOLD   (<em>IVAG) Previous value for element of G whose zero search is
   active.
 GS     (</em>IVAMC) Integration coefficients used in estimating errors.
 GT     (formal) in <em>IVAG.  Previous value of GNEW.
 HC     (</em>IVAMC) Ratio of (new step size) / (old step size)
 HDEC   (<em>IVAMC) Default value to use for HC when reducing the step
   size.  (Values closer to 1 may be used some of the time.)
 HH     Equivalenced to G(1,1) = current step size in </em>IVAA,CR,DA,G,HC.
 HI     (<em>IVAIN) Step length from the base value of the independent
   variable for the interpolation.
 HINC   (</em>IVAMC) Default value to use for HC when increasing the step
   size.  (Values closer to 1 may be used some of the time.)
 HINCC  (<em>IVAMC) Actual value used for default value of HC when
   increasing the step size.  Set to HINC after start is considered
   complete.  During the start HINCC is set to 1.125.
 HMAX   (</em>IVAMC) Largest value allowed for abs(step size).  Default
   value is a very large number.
 HMAXP9 (<em>IVAMC) .9 * HMAX.
 HMIN   (</em>IVAMC) Smallest value allowed for abs(step size).  Default
   value is 0.
 HNEW   (<em>IVADE) Value of step size when iterating at initial point
   for delay differential equations.
 I      Used for temporary storage. (</em>IVAA,BU,CR,DA,DE,G,IN,OP,PR)
 IA     (<em>IVAOP) absolute value of first integer stored for an option.
 ICF    (</em>IVAMC) Final index for current loop in <em>IVACR.  Required by
   option 18.
 ICI    (</em>IVAIN) Temporary index, = 0 for interpolation, 1 or 0 for
   differentiation, and d-1, d-2, ... 0 for integration, where d is the
   order of the differential equation.  Index of first location
   in C() used is ICI + an offset.
 ICS    (<em>IVAMC) Starting index for current loop in </em>IVACR.
 ID     (formal) Array use to contain integer data from common.  Values
   are returned in locations 1 to 5 as follows.
   1    KEMAX = Index of equation with largest error estimate
   2    KSTEP = Current step number
   3    NUMDT = Number of differences used for each equation
   4            Reserved for future use
   5            Reserved for future use
 IDAT   (<em>IVAMC) Used to store integer for error messages.  (Also used
   in </em>IVAA for temporary storage of KORD(2).  (Local array in <em>IVAIN.)
 IDE    (</em>IVADE - formal) Array used to contain past information so
   that delays can stretch back indefinitely.  If the first location is
   0, then any interpolations requested must be in the range of the
   current difference tables.  At present, only the value 0 is allowed
   in IDE(1).  This array is intended for the support of saving long
   past histories.  IDE(2) must contain the declared dimension of WDE.
 IDEF   (<em>IVADE -- formal) Flag giving indicaion of what is going on.
   = 0  User should compute derivatives and return to the main
        integrator.
   = 1  Code is computing additional values in order to get past data
        necessary for starting.  User should compute derivatives and
        call </em>IVADE.
   &lt; 0  Indicates an error condition.  If <em>IVADE is called without
        changing the value of IDEF, the integration is stopped and an
        error message printed.  Possible error flags are:
    -1  Difference tables do not span back far enough to compute the
        past values of Y needed.
    -2  There is not enough space in WDE to get the required starting
        values.
 IDIMF  (formal) Declared dimension of F().
 IDIMK  (formal) Declared dimension of KORD().
 IDIMT  (formal) Declared dimension of TSPECS().
 IDIMY  (formal) Declared dimension of Y().
 IDT    (</em>IVAIN) Used as a base index into the difference table.
 IFLAG  (formal in <em>IVAG) Used for communication with user.
   = 1  Continue as if </em>IVAG was not called.
   = 2  Check KORD(1) as one would do at start of OUTPUT if no G-Stops
        were present. (Exit if in DERIVS.)
   = 3  Return to the integrator.
   = 4  Compute G and return to <em>IVAG.
   = 5  A G-Stop has been found, and NSTOP gives its index.  (If NSTOP
        &lt; 0, the stop was an extrapolating stop.)
   = 6  Same as 5, but requested accuracy was not met.
   = 7  Same as 5, but there is a probable error in computing G.
   = 8  Fatal error of some type.  (An error message has been printed.)
 IG     (</em>IVAG)  IG = KORD(2) on the initial entry (0 for extrapolating
   G-Stops, and 1 for interpolating).
 IGFLG  (<em>IVAMC) Used primarily in </em>ivag, but also used in <em>iva to keep
   track of the state of GSTOP calculations.
   = -2 Extrapolatory G's initialized, but not the interpolatory.
   = -1 Interpolatory G's initialized, but not the extrapolatory.
   =  0 Set when integration is started or restarted, or option setting
        GSTOP is set.
   =  1 Iterating to find a GSTOP.
   =  2 User told that a GSTOP was found.
   =  3 Checking G's at point where a GSTOP was located.
   =  4 Checking G's at a T output point.
   =  5 Usual case, no sign change detected.
 IGSTOP (</em>IVAMC) IGSTOP(k) is set in <em>ivag to the index of the last G
   with a 0, where k is one for an interpolatory G-Stop, and k is two
   for an extrapolatory G-Stop.
 IGTYPE (</em>IVAMC) Array with two elements as for IGSTOP, but this saves
   a flag giving the nature of convergence to the stop.
   = 0  All known G-stops completely processed.
   = 4  Need to compute next value while iterating.
   = 5  Got good convergence.
   = 6  Got convergence, but not to desired accuracy.
   = 7  Problem in getting convergence.
   = 8  A fatal error of some type.
 IHI    (<em>IVA) Last location used by the current option.
 ILGREP (</em>IVAMC) Used when correction to keep track of equations that
   are to use a certain error tolerance.
 ILGROR (<em>IVACR) Index of last equation in the current group of
   equations grouped for selecting integration order.
 ILOW   (</em>IVA) First location used by the current option.
 INCOM  (<em>IVADE) Array equivalenced to LDT in the common block </em>IVASC.
   Used to simplify saving information in the common block.
 INCOP  (<em>IVAOP) Array containing data giving the amount of space in
   IOPT used for each of the options.
 INGS   Current index for G-stop being examined in DIVAG.
 INICAS (</em>IVADE) Used to track the initialization for a delay equation.
   = 1  Very beginning.
   = 2  Getting derivative at the very beginning.
   = 3  Getting derivatives at points prior to the initial point.
   = 4  Getting derivative at initial point after iteration is started.
 INTCHK (<em>IVA) Array passed to OPTCHK containing information on storage
   allocation.  See comments in OPTCHK for details.
 INTEG  (</em>IVAIN) Number of integrations being done. (&lt;0 for
   differentiations and =0 for interpolation.)  Also used as counter
   when computing integration coefficients.
        (<em>IVAPR) Number of integrations being done.
 INTEGS (</em>IVAPR) = -1 for equations that are not stiff, 0 for those
   that are stiff.
 INTEGZ (<em>IVAIN) min(INTEG, 0)
 INTERP (</em>IVAIN) added to the usual integration order to get the order
   to be used when interpolating: 3-KQMAXI, if HI=0; 1, if
   |HI| &gt; |XI(1)| and HI * XI(1) &lt; 0; 0, otherwise -- the usual case.
 IOP10  (<em>IVAMC) Number of times diagnostic output is to be given when
   leaving </em>ivacr (the corrector).
 IOP11  (<em>IVAMC) Gives current step number of the method.  Tells how
   many of certain coefficients must be computed. (Has nothing to do
   with options.) = min(max integ order + 1, KDIM).  Also set when
   starting to flag that certain memory locations must be set to 0.
 IOP12  (</em>IVAMC) Points to location in F() where user supplied values
   of HINC, HDEC, HMIN, and HMAX.  (0 if option 12 not used.)
 IOP13  (<em>IVAMC) If not zero, reverse communication will be used for
   getting the values of derivatives.  Associated with option 13.
 IOP14  (</em>IVAMC) If not zero, reverse communication will be used in
   place of calls to the output routine.  Associated with option 14.
 IOP15  (<em>IVAMC) If not zero, a return will be made to the user after
   the initialization.  Associated with option 15.  This might be used
   to overlay </em>iva, some of the user's code, and perhaps <em>ivaop.
 IOP16  (</em>IVAMC) Points to location in KORD() where information for
   specifying the error tolerance is specified.  See option 16.
 IOP17  (<em>IVAMC) Used in initialization for option 17, afterwards this
   cell is used by KEXIT which is equivalenced to IOP17.
 IOP18  (</em>IVAMC) Points to location in KORD() where information for
   specifying a grouping of equations for derivative evaluation is
   stored.  See option 18.
 IOP19  (<em>IVAMC) Points to location in KORD() where information for
   specifying a grouping of equations for integration order control
   is stored.  See option 19.
 IOP20  (</em>IVAMC) Used for option 20, gives first location in F where
   estimated errors are to be stored.  Expected to be useful in a
   program for solving boundary value problems using multiple shooting.
 IOP21  (<em>IVAMC) Was used for stiff equations option (never completely
   coded).  The optional code still uses this (don't activate it!).
   Now used to flag the location if F where the user has stored the
    tolerance to use in finding G-Stops.
 IOP21S (</em>IVAMC) Was used for stiff equations see above.
 IOP22  (<em>IVAMC) Set aside for possible option for stiff equations.
 IOP3   (</em>IVAMC) Value set by option 3.
   =  0 Interpolate to final point. (The default)
   =  1 Integrate to final point.
   = -1 Extrapolate to final point.
 IOP4   (<em>IVAMC) Value set by option 4.  The output routine is called
   with KORD(1) = 4, every IOP4 steps.  (Default value for IOP4 is a
   very large number.
 IOP5   (</em>IVAMC) Value provided by option 5, used to specify extra
   output points.
 IOP6   (<em>IVAMC) Value provided by option 6.  If nonzero, the output
   routine is called at the end of every step.  If &gt; 0, there are
   IOP6 interpolating G-Stops.
 IOP7   (</em>IVAMC) Value provided by option 7.  If &gt; 0, there are K7
   extrapolating G-Stops.
 IOP8   (<em>IVAMC) Value provided by option 8.  If nonzero, the output
   routine is called with KORD(1)=8 whenever the step size is changed.
 IOP9   (</em>IVAMC) Value provided by option 9.  Used to specify that the
   user wishes to save the solution.
 IOPIVA (<em>IVA) Used to save length of IOPT vector for error messages.
 IOPST  (</em>IVASC) Intended for possible use in stiff equations.
 IOPT   (formal <em>IVA and IVAOP) Used to specify options.
 IOPTC  (</em>IVAOP) In <em>IVAOP equivalenced so that IOPTC(3) is equivalent
   to IOP3.
 IOPTS  (</em>IVAOP) Array containing the current default values to be
   stored into IOPTC.
 IORD   (<em>IVACR) Index of first equation in the current group of
   equations grouped for selecting integration order.
 IOUTKO (</em>IVADC) Used in <em>IVADI to point to KORD to keep track of
   equation grouping for diagnostic output.
 ISVCOM (</em>IVADE) Used to save info. in the common block <em>IVASC.
 ITERS  (</em>IVADE) Counts iterations in starting delay differential
   equations.  Max. value for this is arbitrarily 100.
 ITOLEP (<em>IVAMC) Used for temporary storage, and for the index of a
   tolerance relative to the start of tolerances.
 IVC1   (</em>IVADB) Array used for output of variables IOPST to NUMDT in
   common block <em>IVASC.
 IVC2   (</em>IVADB) Array used for output of variables ICF to NY in
   common block <em>IVAMC.
 IWB    (</em>IVADE) Current base index for saving F values in WDE when
   starting delay differential equations.
 IY     (<em>IVAMC) Used for the current index to the Y() array.  (Local
   variable in </em>IVAIN used in computing IYI.)  Equivalenced to
   IZFLAG in <em>IVAG.
 IYI    (</em>IVAIN) Y(IYI) is currently being computed.
 IYN    (<em>IVAIN) Y(IYN) is base Y() corresponding to Y(IYI).
 IYNI   (</em>IVAIN) Used as base index for computing IYN as IY is for INI.
 IYO    (<em>IVADE) Points to first base value of Y for current
   interpolation when getting values for a delay differential equation.
 IZFLAG (</em>IVAG)  Equivalenced to IY.  Set to 0 initially, and later
   set to the value returned by <em>ZERO.
    = 0  Value set on entry at start of search.
    = 1  Compute next g again.
    = 2  Normal terminiation.
    = 3  Normal termination -- error criterion not satisfied.
    = 4  Apparent discontinuity -- no zero found.
    = 5  Couldn't find a sign change.
    = 6  </em>ZERO was called with a bad value in IZFLAG.
 J      For temporary storage. (In <em>IVA,A,BU,CR,DA,DB,DE,HC,IN,OP,PR)
 J1     (</em>IVAA &amp; DA) Used for temporary storage.
 J2     (<em>IVAA) Used for temporary storage.
 JL     (</em>IVA) Used for checking storage.
 JLGREP (<em>IVACR) Contents of first location of KORD (called LGROUP in
   </em>IVACR) for the current error tolerance rule.
 JLGROR (<em>IVACR) Contents of first location of KORD for the current
   integration order control.
 JLIM   (</em>IVA) Used for checking second item in KORD list for options
   16 and 19.
 K      For temporary storage.  (In <em>IVA,A,BU,CR,DA,DB,DE,HC,IN,OP,PR)
 KDIM   Parameter giving the largest number of differences supported.
        Used in all the routines.
 KEMAX  (</em>IVAMC) Index associated with equation giving the largest
   value for (estimated error) / (requested error).
 KEXIT  (<em>IVAMC) Equivalenced to IOP17 which is not used after
   initialization.  Defines actions when KORD2I = -7.  (Referenced in
   (</em>IVAA,DA,G).)
   =  1  Take the step over with reduced H.
   =  2  Take the step over.
   =  3  Do the end of step call to OUTPUT.
   =  4  Reset TMARK, then do same as for KEXIT = 2.
   =  5  Reset TMARK, then do same as for KEXIT = 3.
   =  6  Give the fatal error diagnostic.
 KFERR  (<em>IVA)  Temporary storage in checking for option 16.
 KGO    (</em>IVA)  Used to tell from whence a check is being done or an
   error message is being written.
   = 1 Checking an equation group for variational equations.
   = 2 Checking an equation group for diagnostic print.
   = 3 Checking an equation group for integration order control.
   = 4 Checking an equation group for error control.
   = 5 Checking an equation group for specifying ODE orders.
   = 6 Found a problem with output type for printing.
   = 7 Found a problem with an output group for printing.
   = 8 Found a problem with input NEQ.
   = 9 Order specified for the ODE's in the system is out of range.
   =10 Option 16 was not used (an error).
   =11 Error tolerance of 0 specified without proper flags.
 KIS    (<em>IVAMC) Used to check if it is time to dump the solution.
   The check involves incrementing KIS at the end of the step, and
   dumping the solution if KIS is 0.
   = -1  Set in </em>ivacr when it is time to dump solution
   =  0  When starting
   =  2  After being dumped.
   This is set to 1000 just after a user specified discontinuity, and
   counted up from that point.
 KMARK  (<em>IVAMC) Identifies the type of output associated with the next
   output point specified by TSPECS.
 KONV   (</em>IVADE) Counts iterations.  Test for convergence if KONV &gt; 1.
 KORD   (formal in <em>IVA,A,BU,CR,DA,DB,DE,G,IN,PR) KORD(1) is used to
   return flags for the user to test, and KORD(2) tells what routine
   the flag is associated with.  See KORD1I and KORD2I below and the
   write up for the program.  KORD(3) is used for communicating extra
   information to the user in some cases.  KORD(4) to KORD(NTE+3) are
   used for integration order for the equations, and the rest of KORD()
   is available for user options.
 KORD1I (</em>IVAMC) Helps in defining the state of the integrator.
   Frequently has the same value as KORD(1).  Meaning depends on the
   value of KORD(2), or the value about to be assigned to KORD(2).
   &lt;  0  Happens when preparing to give output with extrapolation.
   =  0  Happens when checking F at points for noise test.
   =  1  (KORD(2)=-1)  End of integration has been reached.
   =  1  (KORD(2)= 0)  Computing first predicted derivative.
   =  1  (KORD(2)= 1)  Output for initial point.
   =  2  (KORD(2)=-1)  Giving diagnostic for noise limiting precision.
   =  2  (KORD(2)= 0)  Computing corrected derivative.
   =  2  (KORD(2)= 1)  Output for TSPECS(3).
   =  3  (KORD(2)=-1)  Diagnostic for step size reduction too fast.
   =  3  (KORD(2)= 0)  Computing variational derivative.
   =  3  (KORD(2)= 1)  Output for TSPECS(4).
   =  4  (KORD(2)=-1)  Error, discontinuity.
   =  4  (KORD(2)= 1)  Output for certain number of steps.
   =  5  (KORD(2)= 0)  Get initial derivatives for stiff equations.
   =  5  (KORD(2)= 1)  Extra output from TSPECS.
   =  6  (KORD(2)= 1)  End of step output.
   =  7  (KORD(2)= 0)  Evaluate G before extrapolated output point.
   =  7  (KORD(2)= 1)  Evaluate G before extrapolated output point.
                       (Also used when checking for other G's after
                        finding one.)
   =  8  (KORD(2)= 1)  Tell user step size has changed.
   =  9  (KORD(2)= 1)  Request for user to save solution.
   = 11  (KORD(2)=-1)  Error, step size too small at end of start.
   = 12  (KORD(2)=-1)  Error, step size is too small.
   = 13  (KORD(2)=-1)  Error, output points specified badly.
   = 21  (KORD(2)=-1)  H too small to give reasonable change when added
                       to T.
   = 22  (KORD(2)=-1)  Error, bad tolerance.
   = 23  (KORD(2)=-1)  Set after message for a fatal error.
   = 24  Set on error message in <em>iva, along with KORD2I = -4.
   Also used as an index into MLOC in </em>IVAA when an error is being
   processsed, see MLOC below.
 KORD2I (<em>IVAMC) Helps in defining the state of the integrator.
   Frequently has the same value as KORD(2).
   = -3  Set in </em>ivag, to get a derivative evaluation.
   = -2  Set in <em>ivag, to get another entry to OUTPUT.
   = -1  Return to calling program, done, interrupt, or got an error.
   =  1  Calling OUTPUT or returning to user for OUTPUT type action.
   =  0  Calling DERIVS or returning to user for DERIVS type action.
   = -4  Error message in </em>iva and in <em>ivaop, along with KORD1I = 24.
   = -5  Starting
   = -6  Starting, getting the initial derivative value or derivatives
         for the noise test.
   = -7  Done some extrapolation, KEXIT defines the action to take.
         Set in </em>ivag to activate KEXIT action in <em>iva.
   = -8  Set when user has requested adjustment of the difference
         tables for a discontinutiy.
 KORDI  (</em>IVASC) Order of differential equation being integrated.  If
   all orders are the same, this set once at the beginning.
 KOUNT   (<em>IVADE) Count of number of points back from the initial point
   when solving a delay differential equation.
 KOUNTM  (</em>IVADE) Largest value currrently allowed for KOUNT.
 KOUNTX  (<em>IVADE) Largest value allowed for KOUNTM.
 KOUTKO  Used in DIVACR to track where output is wanted.
 KPRED  (</em>IVAMC) Value assigned to KORD1I when getting a predicted
   derivative.  (1 used now, 5 planned for use with stiff equations.)
 KQD    (<em>IVACR) = max(2, integration order)
 KQDCON (</em>IVAMC) Number of coefficients computed with constant step
   size for stiff equations.
 KQICON (<em>IVAMC) Number of coefficients computed with constant step
   size for nonstiff equations.
 KQL    (</em>IVACR) Integration order at start of (<em>IVACR)
 KQLORD (</em>IVACR) Saved value of KQL when equations are grouped for
   controlling the integration order.
 KQMAXD (<em>IVASC) Maximum integration order used for stiff equations.
 KQMAXI (</em>IVASC) Maximum integration order used for nonstiff equations.
 KQMAXS (<em>IVAMC) Maximum integration order for equations that have
   some limit on the error that can be committed.
 KQMXDS (</em>IVAMC) Used to save KQMAXD in case step is repeated and the
   solution must be dumped.
 KQMXI  (<em>IVAIN) Maximum integration order used for integration or
   interpolation, = KQMAXI+INTERP-1.
 KQMXS  (</em>IVAIN) Maximum step number, = max(KQMXI, KQMAXD).
 KQMXIL (<em>IVAMC) Value of KQMAXI the last time integration coefficients
   were computed.
 KQMXIP (</em>IVAMC) = KQMAXI + MAXINT, for computing integration coeffs.
 KQMXIS (<em>IVAMC) Used to save KQMAXI in case step is repeated and the
   solution must be dumped.
 KQN    (</em>IVACR) Value of integration order at end of <em>IVACR.
 KQQ    Used for the integration order for current equation.  (Values
   &lt; 0 are intended for stiff equations.)  (In </em>IVA,BU,DA,IN,PR)
 KSC    (<em>IVAMC) Number of steps that have been taken with a constant
   step size.
 KSOUT  (</em>IVAMC) When KSTEP reaches this value, the output routine is
   called with KORD(1) = 4.  The default value is a very large number.
 KSSTRT (<em>IVAMC) Set when ending one derivative per step to KSTEP + 2.
   Checked later in </em>IVAHC to decide whether to set the step changing
   factors to their nominal values.
 KSTEP  (<em>IVAMC) Number of steps taken since the start of integration.
 L      Used for temporary storage.  In </em>IVAIN, L is the initial value
   of LDT, except L=1 if LDT=-1, and MAXINT .ge. 0.  (Used in <em>IVAA,BU
   CR,DA,DB,IN,PR.)
 LAHAG  (</em>IVADB) Used to get proper offset into an diagnostic message.
 LAIAG  (<em>IVADB) Used to get proper offset into an diagnostic message.
 LDIS   (</em>IVAA) Count of steps since user flagged a discontinuity.
 LDT    (<em>IVASC) Used to keep track of state of difference table.
   = -5  Used only on first step to indicate that an extra iteration
         is desired to get a firm estimate on the error.
   = -4  Set on initialization before there is any difference table.
   = -3  Set just after predicting, interpolation is not allowed when
         this value is set.
   = -2  Set when difference table is to be updated to the end of the
         current step, but no interpolation is to be done.  (For
         dumping the solution.)
   =  0  Calculations for current step are complete, it is not o.k. to
         update the difference table.
   =  1  Difference table has been updated to the end of the current
         step, e.g. by doing an interpolation.
   =  2  Set when doing a special interpolation during computation of
         derivatives.  (For delay equations.)
 LEX    (</em>IVAMC) Indicates how to get values at next output point:
   = -1  Extrapolate
   =  0  Interpolate (The usual case.)
   =  1  Integrate to the output point, integration is not continued.
 LGO    (<em>IVAIN) Used as an an assigned go to.  Result is to add in
   extra correction term when LDT has been set to 2.
 LGROUP (formal) This is a part of KORD passed into </em>IVACR.  The first
   location is the start of the information on the grouping of
   equations for error control.
 LINC   (*IVAMC) Used to indicate state of step size selection.
   = -10 After computed derivatives at base time, after computing other
         extra derivatives for the noise test.
   = -9  After computed second extra derivative for noise test.
   = -8  After computed first extra derivative for noise test.
   = -7  Dumping the solution and then doing a user initiated restart,
         or getting ready to compute extra derivatives for the noise
         test.
   = -6  Dumping the solution before a restart.
   = -5  Set on the first step, and also set when dumping the solution
         after a discontinuity.
   = -4  Repeat step with no change in the step size.
   = -3  Set when the error tolerance is set improperly.
   = -2  User has complete control of selecting the step size.
   = -1  Step is being repeated.
   =  0  Step size is not to be increased on this step.
   = k&gt;0 Step size can be increased by HINCC</strong>k.
 LINCD  (<em>IVAMC) Value of smallest k for which HINCC</em><em>k .ge. 2.
   (=-2 if user is specifying all step size changes.)
 LINCQ  (</em>IVAMC) Value of smallest k for which HINCC<strong>k .ge. 4.
 LIOPT  (<em>IVAOP) Value of the last index in IOPT on the last call.
   Used so </em>IVA can print IOPT in error messages.
 LL     (<em>IVACR) Temporary variable used when equations are grouped
   for integration order control.
 LNOTM1 (</em>IVAIN) Logical variable = L .ne. -1.  If LNOTM1 is true,
   storage in Y() is different in some way lost to antiquity.  Such
   a case can only arise in the case of stiff equations.
 LOCF1  (<em>IVADB) Gives packed data needed for output of tables by the
   message processor MESS.  See comments there under METABL for defs.
 LOCF2  (</em>IVADB) As for LOCF1 above.
 LOCM   (<em>IVAA) Parameter = 32</em>256, used to unpack integers stored
   in MLOC for use in error message processing.
 LPRINT (formal, <em>IVADB) Defines how much printing is to be done in
   </em>IVADB.  Let |LPRINT| = 10<em>N1 + N2     (N1,N2 digits)
    N1=1   Do not print any variables external to the integrator.
    N1=2   Print  tspecs, current y, past y, current f, all pertinent
           contents of KORD, and TOL.
    N1=3   Above + difference tables up to highest difference used.
    N1=4   Same as N1=1 + all in storage allocated for differences.
    N2=1   Do not print any variables internal to the integrator.
    N2=2   Print all scalar variables in interpolation common block.
    N2=3   Above + all scalar variables in main integ. common block.
    N2=4   Same as N1=3 + all used in arrays XI,BETA,ALPHA, first
           column of G, GS,RBQ,SIGMA
    N2=5   Same as N1=4 + all used in arrays G,D,DS,V
 LSC    (</em>IVAMC) Indicates if starting or if noise may be present.
   =k&lt;0 -k steps have been taken for which noise appears to be limiting
        the precision.
   = 0  Usual case
   = 1  Doing 1 derivative per step after initial part of start.
   = 2  Used as flag that it is time to set LSC=0.
   = 3  Third step, hold the order constant.
   = 4  Second step, increase orders from 2 to 3.
   = 5  First step, third time through the first step (if required).
   = 6  First step, second time through.
   = 7  First step, first time through.
   = 8  Set on initialization.
 LTXT?? Names of this form are used in setting up data statements for
   error messages.  These names are generated automatically by PMESS,
   the program that makes up these messages.
 LX     (<em>IVAA) Used for temporary storage in computing TMARKA().
        ( formal </em>IVADE)  An integer array containing extra
   information, as follows.
  LX(1) Points to a location in Y beyond those already in use.  Values
        of Y requested are computed at TSPECS(1) - Y(LX(1)) and stored
        starting at Y(LX(1)+1).  If this index is 0, no more extra Y
        values are to be computed.
  LX(2) Index of the first equation for which the Y's above are to be
        computed.  Y(LX(1)+1) will correspond to this first equation
        index.
  LX(3) Index of the last equation for which the Y's above are to be
        computed.  Thus the Y's stored starting at Y(LX(1)+1) will
        require no more space than half the space ordinarily required
        for the array Y(), and may require significantly less.
  LX(4) Maximum number of times to integrate F to get Y.  This should
        be &gt; 0, and less than or equal to the order of the highest
        order differential equation.  (= 0 is allowed, but probably
        not what you want.  It would give a value only for F.)  Space
        must be set aside for all integrals of F, even if not all are
        requested.  For a first order system, all Y's are just the
        first integrals of the corresponding F's.  For higher order
        equations, the first Y associated with a given F is the d-th
        integral of the corresponding F, where d is the order of the
        equation, and the last Y corresponding to the F is the first
        integral of that F.
  LX(5) As for LX(4), but gives the index for the fewest number of
        times to integrate F.  Ordinarily this should be &gt; 0.  If 0 is
        requested, an estimate for the value of F at the delay point is
        computed.  This should not be 0 more than once, for equations
        covering the same index, since later such requests would write
        over the earlier results.
  LX(5i+k) , k = 1, 2, ... 5.  Treated as for the cases above.  If i
        different cases of delayed Y's are to be computed, then
        LX(5i+1) must be 0.
 LX2    (<em>IVADE) Value of LX(5i+2), when working on the i-th delay.
 MACT   Used in the programs which call the error message program.
   This array difines the actions to be taken by that program.  (In
   (</em>IVA,A,DA,DE,G,IN,OP)
 MACT0  (<em>IVADB) Used to call the message program, see MACT.
 MACT?  As for MACT, in (</em>IVA,CR,DB)
 MACTFV (<em>IVADB) As for MACT0.
 MAXDIF (</em>IVASC) Maximum differentiations required for stiff equations.
 MAXINT (<em>IVASC) Maximum integrations required.  (= max. order of
   differential equations if equations are not stiff.)
 MAXKQ  (</em>IVA, BU)e
 MAXKQD (<em>IVAMC) Largest integration order allowed for stiff equations.
 MAXKQI (</em>IVAMC) Largest integ. order allowed for nonstiff equations.
 ME???? Parameters defining constants used for interaction with the
   error message program MESS.  See comments there for definitions.
   (In <em>IVA,A,DA,DE,G,IN,OP)
 METHOD (</em>IVAMC) Defines kind of methods being used.
   = -1  Only stiff equations are being integrated.
   =  0  Only nonstiff equations are being integrated.
   =  1  Both kinds of methods are required.
 MLOC   (<em>IVA,A,DE) Contains locations in MTEXT for error messages.  In
   </em>IVAA this data is packed using MLOC??, see below.
 MLOC?? (<em>IVAA) Parameters constructed to aid in making up packed data
   for processing error messages.  Low two digits give the value of
   KORD1I to use for the error index and later processing, the next two
   give the error severity level, and the rest point to text used for
   the message.
 MODF2  (</em>IVADB) Used in constructing the same kind of packed data as
   described for LOCF1 above.
 MULTJ  Local to DIVAOP for calls not using F.
 MTEXT  (<em>IVA,A,CR,IN,OP) Text for error messages.
 MTXT?? (</em>IVA,A,CR,DA,DB,DE,G,IN,OP) Equivalenced into MTEXT.
 N      Used for temporary storage.  (In <em>IVAHC,IN,PR)
 NDTF   (</em>IVASC) Location in F() where difference table starts.
 NE     (<em>IVAMC) Number of equations in the first group.  (=NTE if
   option 18 is not used.)
 NEDDIG (</em>IVADB) Parameter = -MEDDIG.
 NEPTOL (<em>IVAMC) Used for temporary storage and to save the value of
   ITOLEP for error messages.
 NEQ    (formal) Total number of equations being integrated.
 NG     (</em>IVAMC) Used in <em>ivag for the number of g's in the current
   context.
 NGSTOP (</em>IVAG) Dimension 2 array equivalenced to IOP6, and IOP7.  To
   get the number of interpolating and extrapolating G-Stops.
 NGTOT  (<em>IVAMC) NGTOT(1) gives the number of interpolating G-Stops,
   and NGTOT(2) gives the number of extrapolating G-Stops.
 NKDKO  (</em>IVASC) If this is nonzero (option 17), it gives the location
   in KORD() where a vector defining the order of each equation is
   specified.
 NLX    (<em>IVADE) Temporary index used to keep track of interpolations
   being done to get Y() values for a delay differential equation.
 NOISEQ (</em>IVAMC) max(2, order of equation for which (error estimate)/
   (error requested) is a maximum).
 NOUTKO (<em>IVAMC) If nonzero, gives the index in KORD where information
   on what equations are to be included in the diagnostic output is
   given.   See option 10.
 NSTOP  (formal) In </em>IVAG.  Index of the G-stop, see IFLAG.
 NTE    (<em>IVASC) Total number of equations being integrated = NEQ.
 NTEXT  (formao </em>IVADB) Character variable containing heading text.
 NTOLF  (<em>IVAMC) First location in F() where tolerance specifying
   accuracy desired is stored.
 NUMDT  (</em>IVASC) Maximum allowed number of differences available for
   doing an integration.
 NXTCHK (<em>IVA) Equivalenced to INTCHK(1), which gives the next
   available location in INTCHK for storing data on storage allocation.
 NY     (</em>IVAMC) Total order of the system.
 NYNY   (<em>IVASC) Location in Y() where the base value for Y() is saved.
 NYNYO  (</em>IVADE) Equivalenced to the saved value from common of NYNY.
 OUTPUT (formal) Name of subroutine to be called for the output of
   data or for computing G-Stops.  Not used if option 14 is set.
 OVD10  (<em>IVAEV) (largest floating point number) / 10.
 OVTM75 (</em>IVAEV) (largest floating point number) </strong> (-.75)
 RBQ    (<em>IVAMC) Array containing data for the preliminary noise test.
 RD     (formal </em>IVACO) Array use to contain floating point data from
   common.  Values are returned in locations 1 to 3 as follows.
   1    EMAX =  Max. ratio of estimated error to requested error
   2            Reserved for future use
   3            Reserved for future use
 REF    (<em>IVACR) Array of length 3 used for translating error tolerance
   type into the factor used for exponential averaging for that type.
 RND    (</em>IVACR) Usually the current estimated error.  Used in deciding
   if noise is limiting precision.
 RNOISE (<em>IVACR) Value used in comparison with RBQ() for preliminary
   noise test.
 ROBND  (</em>IVAMC) Used to influence the selection of integration order.
   The larger ROBND, the harder it is to increase the order and the
   easier it is to decrease it.
 RVC2   (<em>IVADB) Array used for output of variables DNOISE to SNOISE in
   common block </em>IVAMC.  These are variables that don't require a great
   deal of precision.
 S      (<em>IVACR) Estimate of (step size) * eigenvalue of Jacobian.
 SIGMA  (</em>IVAMC) The k-th entry of this array contains a factor that
   gives the amount the k-th difference is expected to increase if the
   step size in increased.  These numbers get bigger it there is a past
   history of increasing the step size.
 SIGMAS (<em>IVAA) Saved value of SIGMA(k) from the last step, where k =
   integration order for equation with index KEMAX.
 SNOISE (</em>IVAMC) Value used in comparison with RBQ() on equation with
   largest value for (error estimate) / (error requested).
 T      (formal) in <em>IVAIN. T(1) contains the point to be interpolated
   to, and T(2) is used in a check that |HI| .le. |T(2)|.  When used by
   other routines in this package, TSPECS is passed in for T.
 TB      (</em>IVADE) Base time for current interpolation.
 TC      (<em>IVADE) Original value of TN when getting past Y's for a
   delay differential equation.
 TEMP   Used for temporary storage, in </em>IVAHC,PR
 TEMPA  (<em>IVACR) Array equivalenced to (TPS1,TPS2,TPS3,TPS4).
 TEMPAO (</em>IVACR) Array used to accumulate values in TEMPA.
 TG     (<em>IVAMC) TG(1) gives the last value of TSPECS(1) for which an
   interpolatory G-Stop has been computed.  TG(2) is defined similarly
   for extrapolatory G-Stops.
 TGSTOP (</em>IVAMC) TGSTOP(1) gives the value of TSPECS(1) where the last
   0 for an interpolatory G-Stop was found.  TGSTOP(2) is defined
   similarly for extrapolatory G-Stops.
 TMARK  (<em>IVAMC) Location of the next output point.
 TMARKA (</em>IVAA)  Array of length 2 equivalenced to TMARK (and TMARKX).
 TMARKX (<em>IVAMC) Location of the next output point to be found using
   integration or extrapolation.  This variable must follow immediately
   after TMARK in the common block.
 TN     (</em>IVASC) The value of TSPECS(1) at the conclusion of the last
   step.
 TNEQ   (<em>IVADB) Array of dimension 1 equivalenced to TN so that an
   array can be passed to </em>MESS.
 TOL    (formal) This is a part of F passed into <em>IVACR.  The first
   location is the start of the information on the tolerances for error
   control.
 TOLD   (</em>IVAG) Value of TSPECS(1) on one side of a zero.
 TOLG   (<em>IVAMC) Tolerance to pass to dzero when locating G-Stops.
 TOUT   (</em>IVAMC) Location of next output point defined by value of
   TSPECS(3).  Such output is given with KORD(1) = 2.
 TP     (<em>IVA,A,DA,DE,HC) Used for temporary storage.
 TP1    (</em>IVAA,DA,HC,IN,PR) Used for temporary storage.
 TP2    (<em>IVAA,DA,HC,PR) Used for temporary storage.
 TP3    (</em>IVAA) Used for temporary storage.
 TPD    (<em>IVABU) Used for temporary storage.
 TPP    (</em>IVACR) Used for temporary storage.  Usually same as TPS3.
 TPS1   (<em>IVAA,CR) Used for temporary storage.  (In </em>IVACR is the
   difference of order KQQ-2)
 TPS2   (<em>IVAA,CR) Used for temporary storage.  (In </em>IVACR is the
   difference of order KQQ-1)
 TPS3   (<em>IVACR) Contains the difference of order KQQ.  This is the
   last difference used in the corrector.
 TPS4   (</em>IVACR) Contains the difference of order KQQ+1.
 TPS5   (<em>IVACR) Temporary storage.
 TPS6   (</em>IVACR) Temporary storage.
 TPS7   (<em>IVACR) Temporary storage.
 TSAVE  (</em>IVAG) Value of TSPECS(1) before starting the search for a 0.
 TSPECS (formal <em>IVA,A,DB,DE,G)
   TSPECS(1) is the current value of the independent variable.
   TSPECS(2) is the current value of the step size.
   TSPECS(3) is the increment to use between output points that give
             output with KORD(1) = 2.
   TSPECS(4) is the "final" output point.
 V      (</em>IVAMC) Array used in computing integration coefficients.
 XI     (<em>IVASC) XI(K) = TSPECS(1) - value of TSPECS(1) K steps
   previous.
 W      (</em>IVAHC) Array used in computing integration coefficients.
 WDE    (formal, <em>IVADE)  Array used for working storage.  This storage
   is used to save derivative values when iterating to get started.  To
   be safe one should allow as much space as is allowed for differences
   in F.  In most cases the start will not require this much space
   however.  This array is also intended for the support of saving long
   past histories.
 Y      (formal, </em>IVA,A,CR,DA,DB,DE,G,IN,PR) Array containing the
   independent variable and all derivatives up to order one less than
   the order of the differential equation.  Also use to save these
   values at the beginning of the current step, the base values.
 YN     (formal, in *IVAPR)  Base values of y, these follow the
   current values of the dependent variable, y, in Y().</p>
<p>++S Default KDIM = 16
++  Default KDIM = 20
++  Default MAXORD = 2, MAXSTF = 1
++  Default INTEGO, VAREQ, OUTPUT, DUMP, GSTOP, EXTRAP
++  Default STIFF=.F., ARGM=.F., ERRSTO=.F.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-idimk"></span>integer</td>
  <td></td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>IDIMK</strong></td><td><blockquote>
<p>2015-03-15 DIVA  Krogh  Removed extra call divabu after noise test
2015-03-15 DIVA  Krogh  Forced restart needs more reduction in h.
2010-02-20 DIVA  Krogh  Fixed calling DIVAOP with array other than F.
2009-11-03 DIVA  Krogh  Added option 11, more variables initialized.
2009-10-30 DIVA  Krogh  Gave KSSTRT and ROBND initial values.
2009-10-30 DIVA  Krogh  Fixed reference to undefined location in F.
2009-10-21 DIVA  Krogh  Got rid of NaN in diag. print when LSC=3.
2009-10-15 DIVA  Krogh  A few changes on how noise is handled.
2002-11-12 DIVA  Krogh  Fixed problem integrating to final output pt
2002-08-29 DIVA  Krogh  Added test for invalid HMIN/HMAX.
2002-07-26 DIVA  Krogh  Added KOUTKO to fully support Option 10.
2002-05-14 DIVA  Krogh  Fix starting prob. for Option 18.
2002-05-13 DIVA  Krogh  Put exponent letter in  numbers missing them
2002-05-12 DIVA  Krogh  Added error message for bad option 5 usage.
2001-09-07 DIVA  Krogh  Changes to allow user tol on G-Stops.
2001-05-25 DIVA  Krogh  Minor change for making .f90 version.
2001-05-18 DIVA  Krogh  Less computing with no error test
2001-05-17 DIVA  Krogh  Fixed so with no error test can't start dump
2001-04-24 DIVA  Krogh  Inserted comments from ivacom.
2000-12-01 DIVA  Krogh  Removed (some of) unused C1, MAXSTF, METEXT.
1999-12-28 DIVA  Krogh  Saved S in DIVACR for output consistency.
1999-08-19 DIVA  Krogh  Removed superfluous test above label 3520.
1997-04-22 DIVA  Krogh  Got rid of assigned go to's. F=0 if diag.
1996-08-26 DIVA  Krogh  Initialize F to 0 if dumping solution.
1996-08-23 DIVA  Krogh  Print TN not TSPECS(1) in error messages.
1996-05-30 DIVA  Krogh  Changed DERIVS/OUTPUT to  DIVAF/DIVAO.
1996-04-27 DIVA  Krogh  Changes to use .C. and C%%.
1996-03-30 DIVA  Krogh  Added external statement.
1996-03-25 DIVA  Krogh  Introduced TEXT1 to comply with F77.
1996-02-27 DIVA  Krogh  Fixed so DUMP not affected by ignored eqs.
1995-12-18 DIVA  Krogh  Fixed so no solution dump on 0 length integ.
1995-11-09 DIVA  Krogh  Fixed so char. data at col. 72 is not ' '.
1995-06-19 DIVA  Krogh  Fixed prob. with discon. just after restart.
1995-05-09 DIVA  Krogh  Fixed G-Stop/discontinuity code interaction
1995-04-26 DIVA  Krogh  Use KQMAXS instead of KQMAXI when LDIS&gt;1000.
1995-04-26 DIVA  Krogh  Keep current KQL on discontinutiy.
1994-12-16 DIVA  Krogh  Fixed option 12 with K12 &lt; 0.
1994-11-11 DIVA  Krogh  Declared all vars.
1994-11-02 DIVA  Krogh  Changes to use M77CON
1994-09-08 DIVA  Krogh  Added CHGTYP code.
1994-07-11 DIVA  Krogh  Fix to get same state with/without var. eqs.
1994-03-07 DIVA  Krogh  Allow larger order in single precision.
1994-01-14 DIVA  Krogh  Minor change to allow changing TFINAL.
1993-04-27 DIVA  Krogh  Additions for Conversion to C.
1993-04-12 DIVA  Krogh  Converted to use slightly altered MESS.
1993-04-12 DIVA  Krogh  Fixed LSC so sol. saved when HMAX is small.
1992-10-13 DIVA  Krogh  Fixed G-Stop/discontinuity code interaction.
1992-09-21 DIVA  Krogh  Fixed bug in discontinuity code.
1992-09-09 DIVA  Krogh  Fixed bug - Var. Eqs. with discontinuities.
1992-08-07 DIVA  Krogh  Storage map printed only if option 10 .ne. 0
1992-07-16 DIVA  Krogh  Restored correct discontinuity code.
1992-06-16 DIVA  Krogh  Eliminate reuse of storage for option 12.
1992-04-08 DIVA  Krogh  Removed unused labels, 1020, 2120.
1992-03-30 DIVA  Krogh  Fixed bug in DIVAOP error message.
1992-03-12 DIVA  Krogh  Simplified DIVABU, more digits in B's.
1992-01-16 DIVA  Krogh  Fixed minor bug in error messages.
1991-12-03 DIVA  Krogh  Major change for improved error checks.
1991-06-17 DIVA  Krogh  Fixed bug in checking storage allocation.
1991-04-11 DIVA  Krogh  Fixed minor bug re. option 12 in DIVAOP.
1991-03-28 DIVA  Krogh  Removed check at label 650 for KORD2I&lt;0.
1991-02-08 DIVA  Krogh  Changed some floats to generics
1990-11-08 DIVA  Krogh  Fixed bug on TSPECS on discon.
1990-09-14 DIVA  Krogh  Fixed bug when discon. and sol. save.
1990-09-13 DIVA  Krogh  Increased dimension of BETA by 1.
1990-09-13 DIVA  Krogh  Added one more poss. on rel. error test.
1990-09-11 DIVA  Krogh  Recent change messed up getting dump output.
1990-06-05 DIVA  Krogh  Fixed bug in noise test, comments in IVACOM.
1990-05-08 DIVA  Krogh  Fixed new bug when TMARK hit in DIVAG.
1990-04-17 DIVA  Krogh  Fixed minor problem in DIVAIN error msg.
1990-04-10 DIVA  Krogh  Fixed interaction between discon. &amp; dump.
1990-03-23 DIVA  Krogh  Fixed bug on option "-2", see 1989-12-07.
1990-03-20 DIVA  Krogh  Fixed rarely occuring loop.
1990-01-29 DIVA  Krogh  Removed unneeded labels.
1989-12-14 DIVA  Krogh  Saved common block DIVAEV.
1989-12-07 DIVA  Krogh  Added option "2" to DIVAOP.
1989-11-09 DIVA  Krogh  Made GG a save var. in DIVAHC
1989-08-21 DIVA  Krogh  Fix out of bounds ref. to V in DIVABU
1989-07-26 DIVA  Krogh  Fix bug in initial dim. check
1989-07-21 DIVA  Krogh  Code for integrating discontinuities
1987-12-07 DIVA  Krogh  Initial code.</p>
</blockquote>
<p>--D replaces "?": ?IVA,?IVAA,?IVABU,?IVACO,?IVACR,?IVAEV,?IVAF,?IVAHC,
-- &amp; ?IVAG,?IVAIN,?IVAMC,?IVAO,?IVAOP,?IVAPR,?IVASC,?IVACE,?IVAIE,
-- &amp; ?IVAPE,?MESS</p>
<p>Note a "*" at the start of a name is used to indicate "D" for the
 double precision version and "S" for the single precision version.</p>
<p>When converting between precisions, don't forget to change the value
 of KDIM set in parameter statements in a variety of routines, and to
 adjust comments for the data statements associated with EIBND in
 <em>IVACR, and B in </em>IVAHC.</p>
<p>Entries
  <em>IVA    Main entry for starting the package.
  </em>IVAA   Main program inside the package, calls the other routines,
          and does checks for output, and noise.  Called by the user
          if reverse communication is used.
  <em>IVABU  Back ups the solution to the current base time, if a step
          that has been started must be taken over for some reason.
  </em>IVACO  Called by user to get certain information from the common
          blocks.
  <em>IVACR  Corrects the solution, estimates errors, and selects order.
  </em>IVADB  Subroutine to assist in debugging codes.  Called by user to
          get a formatted list of all the variables used in the
          integration.  Not required in usual case.
  <em>IVADE  Needed only for delay differential equations.  This is called
          by the user from the derivative subprogram.
  </em>IVAG   Required only if the user has G-Stops, i.e. places to call
          his output subroutine where certain functions have zeroes.
  <em>IVAHC  Compute coefficients that depend on the step size history.
  </em>IVAIN  Used to interpolate to arbitrary points.
  <em>IVAOP  Used to process user option requests.
  </em>IVAPR  Used to update the differences and to predict the solution
          at the end of the current step.</p>
<p>External Routines
  <em>1MACH  Not used in the Fortran 95 version.  ("</em>" is "D" for double
          and "R" for single precision.) This returns constants that
          depend on the floating point arithmetic.  Input arguments of
          1 to 4 give respectively:  underflow limit, overflow limit,
          smallest relative difference between two floating point
          numbers, and the largest relative difference between two
          floating point numbers.
 DERIVS (formal) Name of subroutine to be called for computing
  OPTCHK  Used in checking storage allocation.
  <em>MESS   Used to output error messages and diaganostic messages.
          (Just MESS if no floating point is output.)
  </em>ZERO   Called only if *IVAG is used.  Iterates to find zeros of
          arbitrary (continuous) functions.</p>
<p>Common blocks -- As a left over from the distant past, some variables
   are in common so that they would be saved.
  <em>IVAEV  Holds variables that depend on the environment.
  </em>IVAMC  The main common block for the package.
  *IVASC  The secondary common block for the package.  This contains
          variables that are required for doing interpolation and is
          separate to simplify saving the variables that are required
          when the solution is being dumped (saved).</p>
<p>Common variables and local variables
 ALPHA  (<em>IVAMC) Array with I-th entry = (current step size) / XI(I).
   Used in computing integration coefficients.
 B      (</em>IVAHC) Array used to get started on computing integration
   coefficients.  B(K) = 1. / (K<em>(K+1))
 BAKMIN (</em>IVADE) The largest delay at the initial point.
 BETA   (<em>IVAMC) Array with I-th entry = product (K=1,I-1) of
   (current (XI(K)) / XI(K) from previous step),  BETA(1)=1.  Used in
    updating the difference tables.
 C      (</em>IVAIN) Array used to hold integration/interpolation coeffs.
 C0     Parameter = 0. (in <em>IVAA,DE,CR,A,G,HC,IN,OP,PR)
 C1     Parameter = 1. (in </em>IVA,A,CR,DA,HC,IN,OP)
 C10    Parameter = 10. (in <em>IVAA,CR,OP)
 C1000  Parameter = 1000. (in </em>IVACR)
 C16    Parameter = 16. (in <em>IVAA,OP)
 C1M3   Parameter = .001 (in </em>IVAA)
 C1M5   Parameter = .00001 (in <em>IVAA)
 C1P125 Parameter = 1.125 (in </em>IVAA,HC,OP)
 C1P3   Parameter = 1.3 (in <em>IVAA)
 C1P4   Parameter = 1.4 (in </em>IVACR)
 C2     Parameter = 2. (in <em>IVAA,DE,BU,CR,IN,OP)
 C20    Parameter = 20. (in </em>IVACR)
 C2P5M3 Parameter = .0025 (in <em>IVAA)
 C4     Parameter = 4. (in </em>IVACR,OP)
 C40    Parameter = 40. (in <em>IVACR)
 C4096  Parameter = 4096. (in </em>IVAA)
 C6     Parameter = 6. (in <em>IVAA)
 C8M3   Parameter = .008 (in </em>IVAA)
 CM2    Parameter = -2. (in <em>IVACR)
 CM8    Parameter = -8. (in </em>IVACR)
 CMP5   Parameter = -.5 (in <em>IVACR)
 CMP75  Parameter = -.75 (in </em>IVAOP)
 CP0625 Parameter = .0625 (in <em>IVAA)
 CP1    Parameter = .1 (in </em>IVAA,CR,DA,HC)
 CP125  Parameter = .125 (in <em>IVACR)
 CP25   Parameter = .25 (in </em>IVAA,CR,DE,OP)
 CP3    Parameter = .3 (in <em>IVAA,OP)
 CP4    Parameter = .4 (in </em>IVAA)
 CP5    Parameter = .5 (in <em>IVAA,CR,DA,DE,HC,OP)
 CP5625 Parameter = .5625 (in </em>IVAHC)
 CP625  Parameter = .625 (in <em>IVAOP)
 CP75   Parameter = .75 (in </em>IVACR,OP)
 CP8    Parameter = .8 (in <em>IVACR)
 CP875  Parameter = .875 (in </em>IVAA, OP)
 CP9    Parameter = .9 (in <em>IVAOP)
 CP9375 Parameter = .9375 (in </em>IVACR)
 CQ3125 Parameter = .03125 (in <em>IVACR)
 CRBQI  Parameter = .421875 (in </em>IVAHC)  Initial val for computing RBQ.
 CSUM   (<em>IVAIN) Array used to contain partial sums of the integration
   coefficients.  This is used to corrrect for a difference table that
   has not yet been updated.
 D      (</em>IVAMC) Array to be used later to store coefficients for
   integrating stiff equations.
   derivatives.  Not used if option 13 is set.
 DISADJ (<em>IVAA) Value of stepsize when discontinuity is indicated.
 DNOISE (</em>IVAMC) Used in determining if noise is limiting the
   precision.  It is usually |highest difference used in correcting|
   of the equation with the largest error estimate.
 DS     (<em>IVAMC) Array to be used later to store coefficients for
   estimating errors when integrating stiff equations.
 DVC2   (</em>IVADB) Array used for output of variables HC to TOUT in
   common block <em>IVAMC.
 E      (</em>IVACR) (Estimated error) / (Requested accuracy)
 EAVE   (<em>IVAMC) This is a weighted average of past values of EIMAX.
   It is adjusted to account for expected changes due to step changes.
 EEPS10 (</em>IVAEV) = 10. * (machine epsilon).
 EEPS16 (<em>IVAEV) = 16. * (machine epsilon).
 EEPS2  (</em>IVAEV) =  2. * (machine epsilon).
 EEPT75 (<em>IVAEV) = (machine epsilon) </em><em> (.75)
 EI     (</em>IVACR) Estimate for what E would be if step size increased.
 EIBND  (<em>IVACR) Array containing limits on the estimated error with
   the stepsize increased.  This array tends to make the code a little
   more conservative on step size increases at low order.
 EIMAX  (</em>IVAMC) Estimate of (error estimate / error requested) if the
   step size should be increased.
 EIMIN  (<em>IVAMC) An error estimate is small enough to allow a step
   increase if the estimate of ((error with the step size increased) /
   (error requested)) is less than EIMIN.
 EIMINO (</em>IVAA) Set to C8M3 and never changed.  When step size is being
   reduced if EIMIN .le. EIMINO then the reduction factor is set to
   CP875.  This variable could be a parameter.
 EMAX   (<em>IVAMC) Largest value computed for (error estimate) / (error
   requested).
 EOVEP2 (</em>IVAEV) = EEPS2 * (largest floating point number).
 EPS    (<em>IVACR) Current absolute error tolerance.  Also used for
   temporary storage when computing the desired value of EPS.
 ERCOEF (</em>IVACR) (Error coefficient from formula) / EPS
 EREP   (<em>IVAMC) If EMAX &gt; EREP, a step is repeated.  Ordinarily
   this has the value .3.  This is set &lt; 0 if the error tolerance is
   specified improperly, and is set to a large value if the user
   requests complete control over the step size.  EREP is also set
   &lt; 0 after a user specified discontinuity.
 EROV10 (</em>IVAEV) = 10. / (largest floating point number).
 ETA    (<em>IVAIN) Array used in computing integration/interp. coeffs.
 EVC    (</em>IVADB) Array used for output of variables EEPS2 to EROV10 in
   common block <em>IVAEV.
 EXR    (</em>IVAA) Set to CP1 and never changed.  If it is estimated the
   the (error estimate) / (error requested) on the next step will be
   .ge. EXR then the step size is reduced.  Could be a parameter.
 F      (formal) Array used to store derivative values, the difference
   tables, error tolerance requests, and values used by some other
   options. (in <em>IVA,A,BU,CR,DA,DB,G,IN,PR)
 FDAT  (</em>IVAMC) Used to store data for error messages.  (Local array in
   <em>IVAIN.)
 FOPT  (formal) in </em>IVAOP.  Passed as place to save floating point data
   for options.  This package passes F in for FOPT when calling <em>IVAOP.
 G      (</em>IVAMC) Integration coefficients used for predicting solution.
   G(I, J) gives the I-th coefficient for integrating a J-th order
   differential equation.  G(1, 1) is equal to the step size.
 GAMMA  (<em>IVAIN) Array used in computing integration/interp. coeffs.
 GG     (</em>IVAHC) Array of length = max. differential equation order
   allowed by code - 1.  GG(K) = (HH<strong>(K+1)) / K!
 GNEW   (formal) in <em>IVAG.  Current value for vector function g, whose
   zeroes are to be found.
 GOINT  (</em>IVACR) Used for assigned go to used in computing integration
   coefficients.
 GOLD   (<em>IVAG) Previous value for element of G whose zero search is
   active.
 GS     (</em>IVAMC) Integration coefficients used in estimating errors.
 GT     (formal) in <em>IVAG.  Previous value of GNEW.
 HC     (</em>IVAMC) Ratio of (new step size) / (old step size)
 HDEC   (<em>IVAMC) Default value to use for HC when reducing the step
   size.  (Values closer to 1 may be used some of the time.)
 HH     Equivalenced to G(1,1) = current step size in </em>IVAA,CR,DA,G,HC.
 HI     (<em>IVAIN) Step length from the base value of the independent
   variable for the interpolation.
 HINC   (</em>IVAMC) Default value to use for HC when increasing the step
   size.  (Values closer to 1 may be used some of the time.)
 HINCC  (<em>IVAMC) Actual value used for default value of HC when
   increasing the step size.  Set to HINC after start is considered
   complete.  During the start HINCC is set to 1.125.
 HMAX   (</em>IVAMC) Largest value allowed for abs(step size).  Default
   value is a very large number.
 HMAXP9 (<em>IVAMC) .9 * HMAX.
 HMIN   (</em>IVAMC) Smallest value allowed for abs(step size).  Default
   value is 0.
 HNEW   (<em>IVADE) Value of step size when iterating at initial point
   for delay differential equations.
 I      Used for temporary storage. (</em>IVAA,BU,CR,DA,DE,G,IN,OP,PR)
 IA     (<em>IVAOP) absolute value of first integer stored for an option.
 ICF    (</em>IVAMC) Final index for current loop in <em>IVACR.  Required by
   option 18.
 ICI    (</em>IVAIN) Temporary index, = 0 for interpolation, 1 or 0 for
   differentiation, and d-1, d-2, ... 0 for integration, where d is the
   order of the differential equation.  Index of first location
   in C() used is ICI + an offset.
 ICS    (<em>IVAMC) Starting index for current loop in </em>IVACR.
 ID     (formal) Array use to contain integer data from common.  Values
   are returned in locations 1 to 5 as follows.
   1    KEMAX = Index of equation with largest error estimate
   2    KSTEP = Current step number
   3    NUMDT = Number of differences used for each equation
   4            Reserved for future use
   5            Reserved for future use
 IDAT   (<em>IVAMC) Used to store integer for error messages.  (Also used
   in </em>IVAA for temporary storage of KORD(2).  (Local array in <em>IVAIN.)
 IDE    (</em>IVADE - formal) Array used to contain past information so
   that delays can stretch back indefinitely.  If the first location is
   0, then any interpolations requested must be in the range of the
   current difference tables.  At present, only the value 0 is allowed
   in IDE(1).  This array is intended for the support of saving long
   past histories.  IDE(2) must contain the declared dimension of WDE.
 IDEF   (<em>IVADE -- formal) Flag giving indicaion of what is going on.
   = 0  User should compute derivatives and return to the main
        integrator.
   = 1  Code is computing additional values in order to get past data
        necessary for starting.  User should compute derivatives and
        call </em>IVADE.
   &lt; 0  Indicates an error condition.  If <em>IVADE is called without
        changing the value of IDEF, the integration is stopped and an
        error message printed.  Possible error flags are:
    -1  Difference tables do not span back far enough to compute the
        past values of Y needed.
    -2  There is not enough space in WDE to get the required starting
        values.
 IDIMF  (formal) Declared dimension of F().
 IDIMK  (formal) Declared dimension of KORD().
 IDIMT  (formal) Declared dimension of TSPECS().
 IDIMY  (formal) Declared dimension of Y().
 IDT    (</em>IVAIN) Used as a base index into the difference table.
 IFLAG  (formal in <em>IVAG) Used for communication with user.
   = 1  Continue as if </em>IVAG was not called.
   = 2  Check KORD(1) as one would do at start of OUTPUT if no G-Stops
        were present. (Exit if in DERIVS.)
   = 3  Return to the integrator.
   = 4  Compute G and return to <em>IVAG.
   = 5  A G-Stop has been found, and NSTOP gives its index.  (If NSTOP
        &lt; 0, the stop was an extrapolating stop.)
   = 6  Same as 5, but requested accuracy was not met.
   = 7  Same as 5, but there is a probable error in computing G.
   = 8  Fatal error of some type.  (An error message has been printed.)
 IG     (</em>IVAG)  IG = KORD(2) on the initial entry (0 for extrapolating
   G-Stops, and 1 for interpolating).
 IGFLG  (<em>IVAMC) Used primarily in </em>ivag, but also used in <em>iva to keep
   track of the state of GSTOP calculations.
   = -2 Extrapolatory G's initialized, but not the interpolatory.
   = -1 Interpolatory G's initialized, but not the extrapolatory.
   =  0 Set when integration is started or restarted, or option setting
        GSTOP is set.
   =  1 Iterating to find a GSTOP.
   =  2 User told that a GSTOP was found.
   =  3 Checking G's at point where a GSTOP was located.
   =  4 Checking G's at a T output point.
   =  5 Usual case, no sign change detected.
 IGSTOP (</em>IVAMC) IGSTOP(k) is set in <em>ivag to the index of the last G
   with a 0, where k is one for an interpolatory G-Stop, and k is two
   for an extrapolatory G-Stop.
 IGTYPE (</em>IVAMC) Array with two elements as for IGSTOP, but this saves
   a flag giving the nature of convergence to the stop.
   = 0  All known G-stops completely processed.
   = 4  Need to compute next value while iterating.
   = 5  Got good convergence.
   = 6  Got convergence, but not to desired accuracy.
   = 7  Problem in getting convergence.
   = 8  A fatal error of some type.
 IHI    (<em>IVA) Last location used by the current option.
 ILGREP (</em>IVAMC) Used when correction to keep track of equations that
   are to use a certain error tolerance.
 ILGROR (<em>IVACR) Index of last equation in the current group of
   equations grouped for selecting integration order.
 ILOW   (</em>IVA) First location used by the current option.
 INCOM  (<em>IVADE) Array equivalenced to LDT in the common block </em>IVASC.
   Used to simplify saving information in the common block.
 INCOP  (<em>IVAOP) Array containing data giving the amount of space in
   IOPT used for each of the options.
 INGS   Current index for G-stop being examined in DIVAG.
 INICAS (</em>IVADE) Used to track the initialization for a delay equation.
   = 1  Very beginning.
   = 2  Getting derivative at the very beginning.
   = 3  Getting derivatives at points prior to the initial point.
   = 4  Getting derivative at initial point after iteration is started.
 INTCHK (<em>IVA) Array passed to OPTCHK containing information on storage
   allocation.  See comments in OPTCHK for details.
 INTEG  (</em>IVAIN) Number of integrations being done. (&lt;0 for
   differentiations and =0 for interpolation.)  Also used as counter
   when computing integration coefficients.
        (<em>IVAPR) Number of integrations being done.
 INTEGS (</em>IVAPR) = -1 for equations that are not stiff, 0 for those
   that are stiff.
 INTEGZ (<em>IVAIN) min(INTEG, 0)
 INTERP (</em>IVAIN) added to the usual integration order to get the order
   to be used when interpolating: 3-KQMAXI, if HI=0; 1, if
   |HI| &gt; |XI(1)| and HI * XI(1) &lt; 0; 0, otherwise -- the usual case.
 IOP10  (<em>IVAMC) Number of times diagnostic output is to be given when
   leaving </em>ivacr (the corrector).
 IOP11  (<em>IVAMC) Gives current step number of the method.  Tells how
   many of certain coefficients must be computed. (Has nothing to do
   with options.) = min(max integ order + 1, KDIM).  Also set when
   starting to flag that certain memory locations must be set to 0.
 IOP12  (</em>IVAMC) Points to location in F() where user supplied values
   of HINC, HDEC, HMIN, and HMAX.  (0 if option 12 not used.)
 IOP13  (<em>IVAMC) If not zero, reverse communication will be used for
   getting the values of derivatives.  Associated with option 13.
 IOP14  (</em>IVAMC) If not zero, reverse communication will be used in
   place of calls to the output routine.  Associated with option 14.
 IOP15  (<em>IVAMC) If not zero, a return will be made to the user after
   the initialization.  Associated with option 15.  This might be used
   to overlay </em>iva, some of the user's code, and perhaps <em>ivaop.
 IOP16  (</em>IVAMC) Points to location in KORD() where information for
   specifying the error tolerance is specified.  See option 16.
 IOP17  (<em>IVAMC) Used in initialization for option 17, afterwards this
   cell is used by KEXIT which is equivalenced to IOP17.
 IOP18  (</em>IVAMC) Points to location in KORD() where information for
   specifying a grouping of equations for derivative evaluation is
   stored.  See option 18.
 IOP19  (<em>IVAMC) Points to location in KORD() where information for
   specifying a grouping of equations for integration order control
   is stored.  See option 19.
 IOP20  (</em>IVAMC) Used for option 20, gives first location in F where
   estimated errors are to be stored.  Expected to be useful in a
   program for solving boundary value problems using multiple shooting.
 IOP21  (<em>IVAMC) Was used for stiff equations option (never completely
   coded).  The optional code still uses this (don't activate it!).
   Now used to flag the location if F where the user has stored the
    tolerance to use in finding G-Stops.
 IOP21S (</em>IVAMC) Was used for stiff equations see above.
 IOP22  (<em>IVAMC) Set aside for possible option for stiff equations.
 IOP3   (</em>IVAMC) Value set by option 3.
   =  0 Interpolate to final point. (The default)
   =  1 Integrate to final point.
   = -1 Extrapolate to final point.
 IOP4   (<em>IVAMC) Value set by option 4.  The output routine is called
   with KORD(1) = 4, every IOP4 steps.  (Default value for IOP4 is a
   very large number.
 IOP5   (</em>IVAMC) Value provided by option 5, used to specify extra
   output points.
 IOP6   (<em>IVAMC) Value provided by option 6.  If nonzero, the output
   routine is called at the end of every step.  If &gt; 0, there are
   IOP6 interpolating G-Stops.
 IOP7   (</em>IVAMC) Value provided by option 7.  If &gt; 0, there are K7
   extrapolating G-Stops.
 IOP8   (<em>IVAMC) Value provided by option 8.  If nonzero, the output
   routine is called with KORD(1)=8 whenever the step size is changed.
 IOP9   (</em>IVAMC) Value provided by option 9.  Used to specify that the
   user wishes to save the solution.
 IOPIVA (<em>IVA) Used to save length of IOPT vector for error messages.
 IOPST  (</em>IVASC) Intended for possible use in stiff equations.
 IOPT   (formal <em>IVA and IVAOP) Used to specify options.
 IOPTC  (</em>IVAOP) In <em>IVAOP equivalenced so that IOPTC(3) is equivalent
   to IOP3.
 IOPTS  (</em>IVAOP) Array containing the current default values to be
   stored into IOPTC.
 IORD   (<em>IVACR) Index of first equation in the current group of
   equations grouped for selecting integration order.
 IOUTKO (</em>IVADC) Used in <em>IVADI to point to KORD to keep track of
   equation grouping for diagnostic output.
 ISVCOM (</em>IVADE) Used to save info. in the common block <em>IVASC.
 ITERS  (</em>IVADE) Counts iterations in starting delay differential
   equations.  Max. value for this is arbitrarily 100.
 ITOLEP (<em>IVAMC) Used for temporary storage, and for the index of a
   tolerance relative to the start of tolerances.
 IVC1   (</em>IVADB) Array used for output of variables IOPST to NUMDT in
   common block <em>IVASC.
 IVC2   (</em>IVADB) Array used for output of variables ICF to NY in
   common block <em>IVAMC.
 IWB    (</em>IVADE) Current base index for saving F values in WDE when
   starting delay differential equations.
 IY     (<em>IVAMC) Used for the current index to the Y() array.  (Local
   variable in </em>IVAIN used in computing IYI.)  Equivalenced to
   IZFLAG in <em>IVAG.
 IYI    (</em>IVAIN) Y(IYI) is currently being computed.
 IYN    (<em>IVAIN) Y(IYN) is base Y() corresponding to Y(IYI).
 IYNI   (</em>IVAIN) Used as base index for computing IYN as IY is for INI.
 IYO    (<em>IVADE) Points to first base value of Y for current
   interpolation when getting values for a delay differential equation.
 IZFLAG (</em>IVAG)  Equivalenced to IY.  Set to 0 initially, and later
   set to the value returned by <em>ZERO.
    = 0  Value set on entry at start of search.
    = 1  Compute next g again.
    = 2  Normal terminiation.
    = 3  Normal termination -- error criterion not satisfied.
    = 4  Apparent discontinuity -- no zero found.
    = 5  Couldn't find a sign change.
    = 6  </em>ZERO was called with a bad value in IZFLAG.
 J      For temporary storage. (In <em>IVA,A,BU,CR,DA,DB,DE,HC,IN,OP,PR)
 J1     (</em>IVAA &amp; DA) Used for temporary storage.
 J2     (<em>IVAA) Used for temporary storage.
 JL     (</em>IVA) Used for checking storage.
 JLGREP (<em>IVACR) Contents of first location of KORD (called LGROUP in
   </em>IVACR) for the current error tolerance rule.
 JLGROR (<em>IVACR) Contents of first location of KORD for the current
   integration order control.
 JLIM   (</em>IVA) Used for checking second item in KORD list for options
   16 and 19.
 K      For temporary storage.  (In <em>IVA,A,BU,CR,DA,DB,DE,HC,IN,OP,PR)
 KDIM   Parameter giving the largest number of differences supported.
        Used in all the routines.
 KEMAX  (</em>IVAMC) Index associated with equation giving the largest
   value for (estimated error) / (requested error).
 KEXIT  (<em>IVAMC) Equivalenced to IOP17 which is not used after
   initialization.  Defines actions when KORD2I = -7.  (Referenced in
   (</em>IVAA,DA,G).)
   =  1  Take the step over with reduced H.
   =  2  Take the step over.
   =  3  Do the end of step call to OUTPUT.
   =  4  Reset TMARK, then do same as for KEXIT = 2.
   =  5  Reset TMARK, then do same as for KEXIT = 3.
   =  6  Give the fatal error diagnostic.
 KFERR  (<em>IVA)  Temporary storage in checking for option 16.
 KGO    (</em>IVA)  Used to tell from whence a check is being done or an
   error message is being written.
   = 1 Checking an equation group for variational equations.
   = 2 Checking an equation group for diagnostic print.
   = 3 Checking an equation group for integration order control.
   = 4 Checking an equation group for error control.
   = 5 Checking an equation group for specifying ODE orders.
   = 6 Found a problem with output type for printing.
   = 7 Found a problem with an output group for printing.
   = 8 Found a problem with input NEQ.
   = 9 Order specified for the ODE's in the system is out of range.
   =10 Option 16 was not used (an error).
   =11 Error tolerance of 0 specified without proper flags.
 KIS    (<em>IVAMC) Used to check if it is time to dump the solution.
   The check involves incrementing KIS at the end of the step, and
   dumping the solution if KIS is 0.
   = -1  Set in </em>ivacr when it is time to dump solution
   =  0  When starting
   =  2  After being dumped.
   This is set to 1000 just after a user specified discontinuity, and
   counted up from that point.
 KMARK  (<em>IVAMC) Identifies the type of output associated with the next
   output point specified by TSPECS.
 KONV   (</em>IVADE) Counts iterations.  Test for convergence if KONV &gt; 1.
 KORD   (formal in <em>IVA,A,BU,CR,DA,DB,DE,G,IN,PR) KORD(1) is used to
   return flags for the user to test, and KORD(2) tells what routine
   the flag is associated with.  See KORD1I and KORD2I below and the
   write up for the program.  KORD(3) is used for communicating extra
   information to the user in some cases.  KORD(4) to KORD(NTE+3) are
   used for integration order for the equations, and the rest of KORD()
   is available for user options.
 KORD1I (</em>IVAMC) Helps in defining the state of the integrator.
   Frequently has the same value as KORD(1).  Meaning depends on the
   value of KORD(2), or the value about to be assigned to KORD(2).
   &lt;  0  Happens when preparing to give output with extrapolation.
   =  0  Happens when checking F at points for noise test.
   =  1  (KORD(2)=-1)  End of integration has been reached.
   =  1  (KORD(2)= 0)  Computing first predicted derivative.
   =  1  (KORD(2)= 1)  Output for initial point.
   =  2  (KORD(2)=-1)  Giving diagnostic for noise limiting precision.
   =  2  (KORD(2)= 0)  Computing corrected derivative.
   =  2  (KORD(2)= 1)  Output for TSPECS(3).
   =  3  (KORD(2)=-1)  Diagnostic for step size reduction too fast.
   =  3  (KORD(2)= 0)  Computing variational derivative.
   =  3  (KORD(2)= 1)  Output for TSPECS(4).
   =  4  (KORD(2)=-1)  Error, discontinuity.
   =  4  (KORD(2)= 1)  Output for certain number of steps.
   =  5  (KORD(2)= 0)  Get initial derivatives for stiff equations.
   =  5  (KORD(2)= 1)  Extra output from TSPECS.
   =  6  (KORD(2)= 1)  End of step output.
   =  7  (KORD(2)= 0)  Evaluate G before extrapolated output point.
   =  7  (KORD(2)= 1)  Evaluate G before extrapolated output point.
                       (Also used when checking for other G's after
                        finding one.)
   =  8  (KORD(2)= 1)  Tell user step size has changed.
   =  9  (KORD(2)= 1)  Request for user to save solution.
   = 11  (KORD(2)=-1)  Error, step size too small at end of start.
   = 12  (KORD(2)=-1)  Error, step size is too small.
   = 13  (KORD(2)=-1)  Error, output points specified badly.
   = 21  (KORD(2)=-1)  H too small to give reasonable change when added
                       to T.
   = 22  (KORD(2)=-1)  Error, bad tolerance.
   = 23  (KORD(2)=-1)  Set after message for a fatal error.
   = 24  Set on error message in <em>iva, along with KORD2I = -4.
   Also used as an index into MLOC in </em>IVAA when an error is being
   processsed, see MLOC below.
 KORD2I (<em>IVAMC) Helps in defining the state of the integrator.
   Frequently has the same value as KORD(2).
   = -3  Set in </em>ivag, to get a derivative evaluation.
   = -2  Set in <em>ivag, to get another entry to OUTPUT.
   = -1  Return to calling program, done, interrupt, or got an error.
   =  1  Calling OUTPUT or returning to user for OUTPUT type action.
   =  0  Calling DERIVS or returning to user for DERIVS type action.
   = -4  Error message in </em>iva and in <em>ivaop, along with KORD1I = 24.
   = -5  Starting
   = -6  Starting, getting the initial derivative value or derivatives
         for the noise test.
   = -7  Done some extrapolation, KEXIT defines the action to take.
         Set in </em>ivag to activate KEXIT action in <em>iva.
   = -8  Set when user has requested adjustment of the difference
         tables for a discontinutiy.
 KORDI  (</em>IVASC) Order of differential equation being integrated.  If
   all orders are the same, this set once at the beginning.
 KOUNT   (<em>IVADE) Count of number of points back from the initial point
   when solving a delay differential equation.
 KOUNTM  (</em>IVADE) Largest value currrently allowed for KOUNT.
 KOUNTX  (<em>IVADE) Largest value allowed for KOUNTM.
 KOUTKO  Used in DIVACR to track where output is wanted.
 KPRED  (</em>IVAMC) Value assigned to KORD1I when getting a predicted
   derivative.  (1 used now, 5 planned for use with stiff equations.)
 KQD    (<em>IVACR) = max(2, integration order)
 KQDCON (</em>IVAMC) Number of coefficients computed with constant step
   size for stiff equations.
 KQICON (<em>IVAMC) Number of coefficients computed with constant step
   size for nonstiff equations.
 KQL    (</em>IVACR) Integration order at start of (<em>IVACR)
 KQLORD (</em>IVACR) Saved value of KQL when equations are grouped for
   controlling the integration order.
 KQMAXD (<em>IVASC) Maximum integration order used for stiff equations.
 KQMAXI (</em>IVASC) Maximum integration order used for nonstiff equations.
 KQMAXS (<em>IVAMC) Maximum integration order for equations that have
   some limit on the error that can be committed.
 KQMXDS (</em>IVAMC) Used to save KQMAXD in case step is repeated and the
   solution must be dumped.
 KQMXI  (<em>IVAIN) Maximum integration order used for integration or
   interpolation, = KQMAXI+INTERP-1.
 KQMXS  (</em>IVAIN) Maximum step number, = max(KQMXI, KQMAXD).
 KQMXIL (<em>IVAMC) Value of KQMAXI the last time integration coefficients
   were computed.
 KQMXIP (</em>IVAMC) = KQMAXI + MAXINT, for computing integration coeffs.
 KQMXIS (<em>IVAMC) Used to save KQMAXI in case step is repeated and the
   solution must be dumped.
 KQN    (</em>IVACR) Value of integration order at end of <em>IVACR.
 KQQ    Used for the integration order for current equation.  (Values
   &lt; 0 are intended for stiff equations.)  (In </em>IVA,BU,DA,IN,PR)
 KSC    (<em>IVAMC) Number of steps that have been taken with a constant
   step size.
 KSOUT  (</em>IVAMC) When KSTEP reaches this value, the output routine is
   called with KORD(1) = 4.  The default value is a very large number.
 KSSTRT (<em>IVAMC) Set when ending one derivative per step to KSTEP + 2.
   Checked later in </em>IVAHC to decide whether to set the step changing
   factors to their nominal values.
 KSTEP  (<em>IVAMC) Number of steps taken since the start of integration.
 L      Used for temporary storage.  In </em>IVAIN, L is the initial value
   of LDT, except L=1 if LDT=-1, and MAXINT .ge. 0.  (Used in <em>IVAA,BU
   CR,DA,DB,IN,PR.)
 LAHAG  (</em>IVADB) Used to get proper offset into an diagnostic message.
 LAIAG  (<em>IVADB) Used to get proper offset into an diagnostic message.
 LDIS   (</em>IVAA) Count of steps since user flagged a discontinuity.
 LDT    (<em>IVASC) Used to keep track of state of difference table.
   = -5  Used only on first step to indicate that an extra iteration
         is desired to get a firm estimate on the error.
   = -4  Set on initialization before there is any difference table.
   = -3  Set just after predicting, interpolation is not allowed when
         this value is set.
   = -2  Set when difference table is to be updated to the end of the
         current step, but no interpolation is to be done.  (For
         dumping the solution.)
   =  0  Calculations for current step are complete, it is not o.k. to
         update the difference table.
   =  1  Difference table has been updated to the end of the current
         step, e.g. by doing an interpolation.
   =  2  Set when doing a special interpolation during computation of
         derivatives.  (For delay equations.)
 LEX    (</em>IVAMC) Indicates how to get values at next output point:
   = -1  Extrapolate
   =  0  Interpolate (The usual case.)
   =  1  Integrate to the output point, integration is not continued.
 LGO    (<em>IVAIN) Used as an an assigned go to.  Result is to add in
   extra correction term when LDT has been set to 2.
 LGROUP (formal) This is a part of KORD passed into </em>IVACR.  The first
   location is the start of the information on the grouping of
   equations for error control.
 LINC   (*IVAMC) Used to indicate state of step size selection.
   = -10 After computed derivatives at base time, after computing other
         extra derivatives for the noise test.
   = -9  After computed second extra derivative for noise test.
   = -8  After computed first extra derivative for noise test.
   = -7  Dumping the solution and then doing a user initiated restart,
         or getting ready to compute extra derivatives for the noise
         test.
   = -6  Dumping the solution before a restart.
   = -5  Set on the first step, and also set when dumping the solution
         after a discontinuity.
   = -4  Repeat step with no change in the step size.
   = -3  Set when the error tolerance is set improperly.
   = -2  User has complete control of selecting the step size.
   = -1  Step is being repeated.
   =  0  Step size is not to be increased on this step.
   = k&gt;0 Step size can be increased by HINCC</strong>k.
 LINCD  (<em>IVAMC) Value of smallest k for which HINCC</em><em>k .ge. 2.
   (=-2 if user is specifying all step size changes.)
 LINCQ  (</em>IVAMC) Value of smallest k for which HINCC<strong>k .ge. 4.
 LIOPT  (<em>IVAOP) Value of the last index in IOPT on the last call.
   Used so </em>IVA can print IOPT in error messages.
 LL     (<em>IVACR) Temporary variable used when equations are grouped
   for integration order control.
 LNOTM1 (</em>IVAIN) Logical variable = L .ne. -1.  If LNOTM1 is true,
   storage in Y() is different in some way lost to antiquity.  Such
   a case can only arise in the case of stiff equations.
 LOCF1  (<em>IVADB) Gives packed data needed for output of tables by the
   message processor MESS.  See comments there under METABL for defs.
 LOCF2  (</em>IVADB) As for LOCF1 above.
 LOCM   (<em>IVAA) Parameter = 32</em>256, used to unpack integers stored
   in MLOC for use in error message processing.
 LPRINT (formal, <em>IVADB) Defines how much printing is to be done in
   </em>IVADB.  Let |LPRINT| = 10<em>N1 + N2     (N1,N2 digits)
    N1=1   Do not print any variables external to the integrator.
    N1=2   Print  tspecs, current y, past y, current f, all pertinent
           contents of KORD, and TOL.
    N1=3   Above + difference tables up to highest difference used.
    N1=4   Same as N1=1 + all in storage allocated for differences.
    N2=1   Do not print any variables internal to the integrator.
    N2=2   Print all scalar variables in interpolation common block.
    N2=3   Above + all scalar variables in main integ. common block.
    N2=4   Same as N1=3 + all used in arrays XI,BETA,ALPHA, first
           column of G, GS,RBQ,SIGMA
    N2=5   Same as N1=4 + all used in arrays G,D,DS,V
 LSC    (</em>IVAMC) Indicates if starting or if noise may be present.
   =k&lt;0 -k steps have been taken for which noise appears to be limiting
        the precision.
   = 0  Usual case
   = 1  Doing 1 derivative per step after initial part of start.
   = 2  Used as flag that it is time to set LSC=0.
   = 3  Third step, hold the order constant.
   = 4  Second step, increase orders from 2 to 3.
   = 5  First step, third time through the first step (if required).
   = 6  First step, second time through.
   = 7  First step, first time through.
   = 8  Set on initialization.
 LTXT?? Names of this form are used in setting up data statements for
   error messages.  These names are generated automatically by PMESS,
   the program that makes up these messages.
 LX     (<em>IVAA) Used for temporary storage in computing TMARKA().
        ( formal </em>IVADE)  An integer array containing extra
   information, as follows.
  LX(1) Points to a location in Y beyond those already in use.  Values
        of Y requested are computed at TSPECS(1) - Y(LX(1)) and stored
        starting at Y(LX(1)+1).  If this index is 0, no more extra Y
        values are to be computed.
  LX(2) Index of the first equation for which the Y's above are to be
        computed.  Y(LX(1)+1) will correspond to this first equation
        index.
  LX(3) Index of the last equation for which the Y's above are to be
        computed.  Thus the Y's stored starting at Y(LX(1)+1) will
        require no more space than half the space ordinarily required
        for the array Y(), and may require significantly less.
  LX(4) Maximum number of times to integrate F to get Y.  This should
        be &gt; 0, and less than or equal to the order of the highest
        order differential equation.  (= 0 is allowed, but probably
        not what you want.  It would give a value only for F.)  Space
        must be set aside for all integrals of F, even if not all are
        requested.  For a first order system, all Y's are just the
        first integrals of the corresponding F's.  For higher order
        equations, the first Y associated with a given F is the d-th
        integral of the corresponding F, where d is the order of the
        equation, and the last Y corresponding to the F is the first
        integral of that F.
  LX(5) As for LX(4), but gives the index for the fewest number of
        times to integrate F.  Ordinarily this should be &gt; 0.  If 0 is
        requested, an estimate for the value of F at the delay point is
        computed.  This should not be 0 more than once, for equations
        covering the same index, since later such requests would write
        over the earlier results.
  LX(5i+k) , k = 1, 2, ... 5.  Treated as for the cases above.  If i
        different cases of delayed Y's are to be computed, then
        LX(5i+1) must be 0.
 LX2    (<em>IVADE) Value of LX(5i+2), when working on the i-th delay.
 MACT   Used in the programs which call the error message program.
   This array difines the actions to be taken by that program.  (In
   (</em>IVA,A,DA,DE,G,IN,OP)
 MACT0  (<em>IVADB) Used to call the message program, see MACT.
 MACT?  As for MACT, in (</em>IVA,CR,DB)
 MACTFV (<em>IVADB) As for MACT0.
 MAXDIF (</em>IVASC) Maximum differentiations required for stiff equations.
 MAXINT (<em>IVASC) Maximum integrations required.  (= max. order of
   differential equations if equations are not stiff.)
 MAXKQ  (</em>IVA, BU)e
 MAXKQD (<em>IVAMC) Largest integration order allowed for stiff equations.
 MAXKQI (</em>IVAMC) Largest integ. order allowed for nonstiff equations.
 ME???? Parameters defining constants used for interaction with the
   error message program MESS.  See comments there for definitions.
   (In <em>IVA,A,DA,DE,G,IN,OP)
 METHOD (</em>IVAMC) Defines kind of methods being used.
   = -1  Only stiff equations are being integrated.
   =  0  Only nonstiff equations are being integrated.
   =  1  Both kinds of methods are required.
 MLOC   (<em>IVA,A,DE) Contains locations in MTEXT for error messages.  In
   </em>IVAA this data is packed using MLOC??, see below.
 MLOC?? (<em>IVAA) Parameters constructed to aid in making up packed data
   for processing error messages.  Low two digits give the value of
   KORD1I to use for the error index and later processing, the next two
   give the error severity level, and the rest point to text used for
   the message.
 MODF2  (</em>IVADB) Used in constructing the same kind of packed data as
   described for LOCF1 above.
 MULTJ  Local to DIVAOP for calls not using F.
 MTEXT  (<em>IVA,A,CR,IN,OP) Text for error messages.
 MTXT?? (</em>IVA,A,CR,DA,DB,DE,G,IN,OP) Equivalenced into MTEXT.
 N      Used for temporary storage.  (In <em>IVAHC,IN,PR)
 NDTF   (</em>IVASC) Location in F() where difference table starts.
 NE     (<em>IVAMC) Number of equations in the first group.  (=NTE if
   option 18 is not used.)
 NEDDIG (</em>IVADB) Parameter = -MEDDIG.
 NEPTOL (<em>IVAMC) Used for temporary storage and to save the value of
   ITOLEP for error messages.
 NEQ    (formal) Total number of equations being integrated.
 NG     (</em>IVAMC) Used in <em>ivag for the number of g's in the current
   context.
 NGSTOP (</em>IVAG) Dimension 2 array equivalenced to IOP6, and IOP7.  To
   get the number of interpolating and extrapolating G-Stops.
 NGTOT  (<em>IVAMC) NGTOT(1) gives the number of interpolating G-Stops,
   and NGTOT(2) gives the number of extrapolating G-Stops.
 NKDKO  (</em>IVASC) If this is nonzero (option 17), it gives the location
   in KORD() where a vector defining the order of each equation is
   specified.
 NLX    (<em>IVADE) Temporary index used to keep track of interpolations
   being done to get Y() values for a delay differential equation.
 NOISEQ (</em>IVAMC) max(2, order of equation for which (error estimate)/
   (error requested) is a maximum).
 NOUTKO (<em>IVAMC) If nonzero, gives the index in KORD where information
   on what equations are to be included in the diagnostic output is
   given.   See option 10.
 NSTOP  (formal) In </em>IVAG.  Index of the G-stop, see IFLAG.
 NTE    (<em>IVASC) Total number of equations being integrated = NEQ.
 NTEXT  (formao </em>IVADB) Character variable containing heading text.
 NTOLF  (<em>IVAMC) First location in F() where tolerance specifying
   accuracy desired is stored.
 NUMDT  (</em>IVASC) Maximum allowed number of differences available for
   doing an integration.
 NXTCHK (<em>IVA) Equivalenced to INTCHK(1), which gives the next
   available location in INTCHK for storing data on storage allocation.
 NY     (</em>IVAMC) Total order of the system.
 NYNY   (<em>IVASC) Location in Y() where the base value for Y() is saved.
 NYNYO  (</em>IVADE) Equivalenced to the saved value from common of NYNY.
 OUTPUT (formal) Name of subroutine to be called for the output of
   data or for computing G-Stops.  Not used if option 14 is set.
 OVD10  (<em>IVAEV) (largest floating point number) / 10.
 OVTM75 (</em>IVAEV) (largest floating point number) </strong> (-.75)
 RBQ    (<em>IVAMC) Array containing data for the preliminary noise test.
 RD     (formal </em>IVACO) Array use to contain floating point data from
   common.  Values are returned in locations 1 to 3 as follows.
   1    EMAX =  Max. ratio of estimated error to requested error
   2            Reserved for future use
   3            Reserved for future use
 REF    (<em>IVACR) Array of length 3 used for translating error tolerance
   type into the factor used for exponential averaging for that type.
 RND    (</em>IVACR) Usually the current estimated error.  Used in deciding
   if noise is limiting precision.
 RNOISE (<em>IVACR) Value used in comparison with RBQ() for preliminary
   noise test.
 ROBND  (</em>IVAMC) Used to influence the selection of integration order.
   The larger ROBND, the harder it is to increase the order and the
   easier it is to decrease it.
 RVC2   (<em>IVADB) Array used for output of variables DNOISE to SNOISE in
   common block </em>IVAMC.  These are variables that don't require a great
   deal of precision.
 S      (<em>IVACR) Estimate of (step size) * eigenvalue of Jacobian.
 SIGMA  (</em>IVAMC) The k-th entry of this array contains a factor that
   gives the amount the k-th difference is expected to increase if the
   step size in increased.  These numbers get bigger it there is a past
   history of increasing the step size.
 SIGMAS (<em>IVAA) Saved value of SIGMA(k) from the last step, where k =
   integration order for equation with index KEMAX.
 SNOISE (</em>IVAMC) Value used in comparison with RBQ() on equation with
   largest value for (error estimate) / (error requested).
 T      (formal) in <em>IVAIN. T(1) contains the point to be interpolated
   to, and T(2) is used in a check that |HI| .le. |T(2)|.  When used by
   other routines in this package, TSPECS is passed in for T.
 TB      (</em>IVADE) Base time for current interpolation.
 TC      (<em>IVADE) Original value of TN when getting past Y's for a
   delay differential equation.
 TEMP   Used for temporary storage, in </em>IVAHC,PR
 TEMPA  (<em>IVACR) Array equivalenced to (TPS1,TPS2,TPS3,TPS4).
 TEMPAO (</em>IVACR) Array used to accumulate values in TEMPA.
 TG     (<em>IVAMC) TG(1) gives the last value of TSPECS(1) for which an
   interpolatory G-Stop has been computed.  TG(2) is defined similarly
   for extrapolatory G-Stops.
 TGSTOP (</em>IVAMC) TGSTOP(1) gives the value of TSPECS(1) where the last
   0 for an interpolatory G-Stop was found.  TGSTOP(2) is defined
   similarly for extrapolatory G-Stops.
 TMARK  (<em>IVAMC) Location of the next output point.
 TMARKA (</em>IVAA)  Array of length 2 equivalenced to TMARK (and TMARKX).
 TMARKX (<em>IVAMC) Location of the next output point to be found using
   integration or extrapolation.  This variable must follow immediately
   after TMARK in the common block.
 TN     (</em>IVASC) The value of TSPECS(1) at the conclusion of the last
   step.
 TNEQ   (<em>IVADB) Array of dimension 1 equivalenced to TN so that an
   array can be passed to </em>MESS.
 TOL    (formal) This is a part of F passed into <em>IVACR.  The first
   location is the start of the information on the tolerances for error
   control.
 TOLD   (</em>IVAG) Value of TSPECS(1) on one side of a zero.
 TOLG   (<em>IVAMC) Tolerance to pass to dzero when locating G-Stops.
 TOUT   (</em>IVAMC) Location of next output point defined by value of
   TSPECS(3).  Such output is given with KORD(1) = 2.
 TP     (<em>IVA,A,DA,DE,HC) Used for temporary storage.
 TP1    (</em>IVAA,DA,HC,IN,PR) Used for temporary storage.
 TP2    (<em>IVAA,DA,HC,PR) Used for temporary storage.
 TP3    (</em>IVAA) Used for temporary storage.
 TPD    (<em>IVABU) Used for temporary storage.
 TPP    (</em>IVACR) Used for temporary storage.  Usually same as TPS3.
 TPS1   (<em>IVAA,CR) Used for temporary storage.  (In </em>IVACR is the
   difference of order KQQ-2)
 TPS2   (<em>IVAA,CR) Used for temporary storage.  (In </em>IVACR is the
   difference of order KQQ-1)
 TPS3   (<em>IVACR) Contains the difference of order KQQ.  This is the
   last difference used in the corrector.
 TPS4   (</em>IVACR) Contains the difference of order KQQ+1.
 TPS5   (<em>IVACR) Temporary storage.
 TPS6   (</em>IVACR) Temporary storage.
 TPS7   (<em>IVACR) Temporary storage.
 TSAVE  (</em>IVAG) Value of TSPECS(1) before starting the search for a 0.
 TSPECS (formal <em>IVA,A,DB,DE,G)
   TSPECS(1) is the current value of the independent variable.
   TSPECS(2) is the current value of the step size.
   TSPECS(3) is the increment to use between output points that give
             output with KORD(1) = 2.
   TSPECS(4) is the "final" output point.
 V      (</em>IVAMC) Array used in computing integration coefficients.
 XI     (<em>IVASC) XI(K) = TSPECS(1) - value of TSPECS(1) K steps
   previous.
 W      (</em>IVAHC) Array used in computing integration coefficients.
 WDE    (formal, <em>IVADE)  Array used for working storage.  This storage
   is used to save derivative values when iterating to get started.  To
   be safe one should allow as much space as is allowed for differences
   in F.  In most cases the start will not require this much space
   however.  This array is also intended for the support of saving long
   past histories.
 Y      (formal, </em>IVA,A,CR,DA,DB,DE,G,IN,PR) Array containing the
   independent variable and all derivatives up to order one less than
   the order of the differential equation.  Also use to save these
   values at the beginning of the current step, the base values.
 YN     (formal, in *IVAPR)  Base values of y, these follow the
   current values of the dependent variable, y, in Y().</p>
<p>++S Default KDIM = 16
++  Default KDIM = 20
++  Default MAXORD = 2, MAXSTF = 1
++  Default INTEGO, VAREQ, OUTPUT, DUMP, GSTOP, EXTRAP
++  Default STIFF=.F., ARGM=.F., ERRSTO=.F.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iopt~2"></span>integer</td>
  <td></td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>IOPT</strong>(*)</td><td></td>
  
</tr>

</tbody>
</table>

    
    
    
    <br>
    
    
    <div class="panel panel-default">
      <div class="panel-heading">
  <h3 class="panel-title">Calls</h3>
      </div>
      <div class="panel-body">
  <div class="depgraph"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: proc~~diva~~CallsGraph Pages: 1 -->
<svg id="procdivaCallsGraph" width="430pt" height="236pt"
 viewBox="0.00 0.00 430.00 236.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="proc~~diva~~CallsGraph" class="graph" transform="scale(1 1) rotate(0) translate(4 232)">
<title>proc~~diva~~CallsGraph</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-232 426,-232 426,4 -4,4"/>
<!-- proc~diva -->
<g id="proc~~diva~~CallsGraph_node1" class="node">
<title>proc~diva</title>
<polygon fill="none" stroke="black" points="54,-165 0,-165 0,-141 54,-141 54,-165"/>
<text text-anchor="middle" x="27" y="-150.6" font-family="Helvetica,sans-Serif" font-size="10.50">DIVA</text>
</g>
<!-- proc~dmess -->
<g id="proc~~diva~~CallsGraph_node2" class="node">
<title>proc~dmess</title>
<g id="a_proc~~diva~~CallsGraph_node2"><a xlink:href=".././proc/dmess.html" xlink:title="DMESS">
<polygon fill="#d9534f" stroke="#d9534f" points="144.5,-228 90.5,-228 90.5,-204 144.5,-204 144.5,-228"/>
<text text-anchor="middle" x="117.5" y="-213.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">DMESS</text>
</a>
</g>
</g>
<!-- proc~diva&#45;&gt;proc~dmess -->
<g id="proc~~diva~~CallsGraph_edge1" class="edge">
<title>proc~diva&#45;&gt;proc~dmess</title>
<path fill="none" stroke="#000000" d="M45.06,-165.15C58.16,-174.47 76.45,-187.49 91.25,-198.02"/>
<polygon fill="#000000" stroke="#000000" points="89.31,-200.94 99.49,-203.89 93.37,-195.24 89.31,-200.94"/>
</g>
<!-- proc~mess -->
<g id="proc~~diva~~CallsGraph_node3" class="node">
<title>proc~mess</title>
<g id="a_proc~~diva~~CallsGraph_node3"><a xlink:href=".././proc/mess.html" xlink:title="MESS">
<polygon fill="#d9534f" stroke="#d9534f" points="236,-108 182,-108 182,-84 236,-84 236,-108"/>
<text text-anchor="middle" x="209" y="-93.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">MESS</text>
</a>
</g>
</g>
<!-- proc~diva&#45;&gt;proc~mess -->
<g id="proc~~diva~~CallsGraph_edge2" class="edge">
<title>proc~diva&#45;&gt;proc~mess</title>
<path fill="none" stroke="#000000" d="M41.7,-140.9C53.6,-131.12 71.75,-117.89 90,-111 116.25,-101.09 147.89,-97.47 171.79,-96.26"/>
<polygon fill="#000000" stroke="#000000" points="171.99,-99.76 181.85,-95.87 171.72,-92.76 171.99,-99.76"/>
</g>
<!-- proc~optchk -->
<g id="proc~~diva~~CallsGraph_node4" class="node">
<title>proc~optchk</title>
<g id="a_proc~~diva~~CallsGraph_node4"><a xlink:href=".././proc/optchk.html" xlink:title="OPTCHK">
<polygon fill="#d9534f" stroke="#d9534f" points="145,-144 90,-144 90,-120 145,-120 145,-144"/>
<text text-anchor="middle" x="117.5" y="-129.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">OPTCHK</text>
</a>
</g>
</g>
<!-- proc~diva&#45;&gt;proc~optchk -->
<g id="proc~~diva~~CallsGraph_edge3" class="edge">
<title>proc~diva&#45;&gt;proc~optchk</title>
<path fill="none" stroke="#000000" d="M54.07,-146.81C62.21,-144.88 71.34,-142.72 80.05,-140.65"/>
<polygon fill="#000000" stroke="#000000" points="81.08,-144 90,-138.29 79.46,-137.19 81.08,-144"/>
</g>
<!-- proc~divaop -->
<g id="proc~~diva~~CallsGraph_node5" class="node">
<title>proc~divaop</title>
<g id="a_proc~~diva~~CallsGraph_node5"><a xlink:href=".././proc/divaop.html" xlink:title="DIVAOP">
<polygon fill="#d9534f" stroke="#d9534f" points="144.5,-186 90.5,-186 90.5,-162 144.5,-162 144.5,-186"/>
<text text-anchor="middle" x="117.5" y="-171.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">DIVAOP</text>
</a>
</g>
</g>
<!-- proc~diva&#45;&gt;proc~divaop -->
<g id="proc~~diva~~CallsGraph_edge4" class="edge">
<title>proc~diva&#45;&gt;proc~divaop</title>
<path fill="none" stroke="#000000" d="M54.07,-159.19C62.37,-161.16 71.7,-163.37 80.57,-165.47"/>
<polygon fill="#000000" stroke="#000000" points="79.77,-168.88 90.31,-167.78 81.38,-162.07 79.77,-168.88"/>
</g>
<!-- proc~d1mach -->
<g id="proc~~diva~~CallsGraph_node10" class="node">
<title>proc~d1mach</title>
<g id="a_proc~~diva~~CallsGraph_node10"><a xlink:href=".././proc/d1mach.html" xlink:title="d1mach">
<polygon fill="#d94e8f" stroke="#d94e8f" points="237,-187 181,-187 181,-163 237,-163 237,-187"/>
<text text-anchor="middle" x="209" y="-172.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">d1mach</text>
</a>
</g>
</g>
<!-- proc~dmess&#45;&gt;proc~d1mach -->
<g id="proc~~diva~~CallsGraph_edge5" class="edge">
<title>proc~dmess&#45;&gt;proc~d1mach</title>
<path fill="none" stroke="#000000" d="M144.87,-203.92C153.44,-199.99 163.1,-195.57 172.24,-191.38"/>
<polygon fill="#000000" stroke="#000000" points="173.88,-194.48 181.51,-187.13 170.96,-188.12 173.88,-194.48"/>
</g>
<!-- proc~messfi -->
<g id="proc~~diva~~CallsGraph_node11" class="node">
<title>proc~messfi</title>
<g id="a_proc~~diva~~CallsGraph_node11"><a xlink:href=".././proc/messfi.html" xlink:title="MESSFI">
<polygon fill="#d9534f" stroke="#d9534f" points="422,-190 368,-190 368,-166 422,-166 422,-190"/>
<text text-anchor="middle" x="395" y="-175.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">MESSFI</text>
</a>
</g>
</g>
<!-- proc~dmess&#45;&gt;proc~messfi -->
<g id="proc~~diva~~CallsGraph_edge6" class="edge">
<title>proc~dmess&#45;&gt;proc~messfi</title>
<path fill="none" stroke="#000000" d="M144.92,-212.36C194.39,-205.53 301.08,-190.82 357.43,-183.04"/>
<polygon fill="#000000" stroke="#000000" points="358.24,-186.47 367.66,-181.63 357.28,-179.53 358.24,-186.47"/>
</g>
<!-- proc~messpr -->
<g id="proc~~diva~~CallsGraph_node6" class="node">
<title>proc~messpr</title>
<g id="a_proc~~diva~~CallsGraph_node6"><a xlink:href=".././proc/messpr.html" xlink:title="MESSPR">
<polygon fill="#d9534f" stroke="#d9534f" points="330,-150 275,-150 275,-126 330,-126 330,-150"/>
<text text-anchor="middle" x="302.5" y="-135.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">MESSPR</text>
</a>
</g>
</g>
<!-- proc~mess&#45;&gt;proc~messpr -->
<g id="proc~~diva~~CallsGraph_edge7" class="edge">
<title>proc~mess&#45;&gt;proc~messpr</title>
<path fill="none" stroke="#000000" d="M236.47,-108.15C245.67,-112.37 256.14,-117.18 265.95,-121.68"/>
<polygon fill="#000000" stroke="#000000" points="264.55,-124.89 275.09,-125.88 267.47,-118.53 264.55,-124.89"/>
</g>
<!-- proc~messfd -->
<g id="proc~~diva~~CallsGraph_node7" class="node">
<title>proc~messfd</title>
<g id="a_proc~~diva~~CallsGraph_node7"><a xlink:href=".././proc/messfd.html" xlink:title="MESSFD">
<polygon fill="#d9534f" stroke="#d9534f" points="330.5,-108 274.5,-108 274.5,-84 330.5,-84 330.5,-108"/>
<text text-anchor="middle" x="302.5" y="-93.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">MESSFD</text>
</a>
</g>
</g>
<!-- proc~mess&#45;&gt;proc~messfd -->
<g id="proc~~diva~~CallsGraph_edge8" class="edge">
<title>proc~mess&#45;&gt;proc~messfd</title>
<path fill="none" stroke="#000000" d="M236.47,-96C245.13,-96 254.93,-96 264.24,-96"/>
<polygon fill="#000000" stroke="#000000" points="264.46,-99.5 274.46,-96 264.46,-92.5 264.46,-99.5"/>
</g>
<!-- proc~messgs -->
<g id="proc~~diva~~CallsGraph_node8" class="node">
<title>proc~messgs</title>
<g id="a_proc~~diva~~CallsGraph_node8"><a xlink:href=".././proc/messgs.html" xlink:title="MESSGS">
<polygon fill="#d94e8f" stroke="#d94e8f" points="331,-66 274,-66 274,-42 331,-42 331,-66"/>
<text text-anchor="middle" x="302.5" y="-51.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">MESSGS</text>
</a>
</g>
</g>
<!-- proc~mess&#45;&gt;proc~messgs -->
<g id="proc~~diva~~CallsGraph_edge9" class="edge">
<title>proc~mess&#45;&gt;proc~messgs</title>
<path fill="none" stroke="#000000" d="M236.47,-83.85C245.67,-79.63 256.14,-74.82 265.95,-70.32"/>
<polygon fill="#000000" stroke="#000000" points="267.47,-73.47 275.09,-66.12 264.55,-67.11 267.47,-73.47"/>
</g>
<!-- proc~messmh -->
<g id="proc~~diva~~CallsGraph_node9" class="node">
<title>proc~messmh</title>
<g id="a_proc~~diva~~CallsGraph_node9"><a xlink:href=".././proc/messmh.html" xlink:title="MESSMH">
<polygon fill="#d9534f" stroke="#d9534f" points="332,-24 273,-24 273,0 332,0 332,-24"/>
<text text-anchor="middle" x="302.5" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">MESSMH</text>
</a>
</g>
</g>
<!-- proc~mess&#45;&gt;proc~messmh -->
<g id="proc~~diva~~CallsGraph_edge10" class="edge">
<title>proc~mess&#45;&gt;proc~messmh</title>
<path fill="none" stroke="#000000" d="M221.11,-83.85C233.32,-70.74 253.77,-49.54 273,-33 274,-32.14 275.02,-31.28 276.07,-30.43"/>
<polygon fill="#000000" stroke="#000000" points="278.55,-32.93 284.3,-24.03 274.25,-27.41 278.55,-32.93"/>
</g>
<!-- proc~mess&#45;&gt;proc~messfi -->
<g id="proc~~diva~~CallsGraph_edge11" class="edge">
<title>proc~mess&#45;&gt;proc~messfi</title>
<path fill="none" stroke="#000000" d="M218.24,-108C229,-122.64 249.29,-146.94 273,-159 299.2,-172.33 332.39,-176.8 357.38,-178.1"/>
<polygon fill="#000000" stroke="#000000" points="357.42,-181.6 367.55,-178.48 357.68,-174.61 357.42,-181.6"/>
</g>
<!-- proc~divaop&#45;&gt;proc~mess -->
<g id="proc~~diva~~CallsGraph_edge12" class="edge">
<title>proc~divaop&#45;&gt;proc~mess</title>
<path fill="none" stroke="#000000" d="M134.05,-161.95C137.68,-159.06 141.51,-155.96 145,-153 159.59,-140.64 175.55,-126.19 187.76,-114.93"/>
<polygon fill="#000000" stroke="#000000" points="190.23,-117.41 195.19,-108.04 185.48,-112.27 190.23,-117.41"/>
</g>
<!-- proc~divaop&#45;&gt;proc~d1mach -->
<g id="proc~~diva~~CallsGraph_edge13" class="edge">
<title>proc~divaop&#45;&gt;proc~d1mach</title>
<path fill="none" stroke="#000000" d="M144.87,-174.29C152.93,-174.38 161.96,-174.49 170.61,-174.58"/>
<polygon fill="#000000" stroke="#000000" points="170.85,-178.09 180.89,-174.7 170.93,-171.09 170.85,-178.09"/>
</g>
<!-- proc~messfd&#45;&gt;proc~messfi -->
<g id="proc~~diva~~CallsGraph_edge14" class="edge">
<title>proc~messfd&#45;&gt;proc~messfi</title>
<path fill="none" stroke="#000000" d="M320.68,-108.05C324.49,-110.89 328.45,-113.97 332,-117 347.27,-130.02 363.39,-145.96 375.37,-158.28"/>
<polygon fill="#000000" stroke="#000000" points="373.13,-161.01 382.59,-165.79 378.18,-156.15 373.13,-161.01"/>
</g>
</g>
</svg>
</div><div><a type="button" class="graph-help" data-toggle="modal" href="#graph-help-text">Help</a></div><div class="modal fade" id="graph-help-text" tabindex="-1" role="dialog"><div class="modal-dialog modal-lg" role="document"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><h4 class="modal-title" id="-graph-help-label">Graph Key</h4></div><div class="modal-body">
    <p>Nodes of different colours represent the following: </p>
    <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: Graph Key Pages: 1 -->
<svg width="597pt" height="32pt"
 viewBox="0.00 0.00 596.50 32.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 28)">
<title>Graph Key</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-28 592.5,-28 592.5,4 -4,4"/>
<!-- Subroutine -->
<g id="node1" class="node">
<title>Subroutine</title>
<polygon fill="#d9534f" stroke="#d9534f" points="70,-24 0,-24 0,0 70,0 70,-24"/>
<text text-anchor="middle" x="35" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Subroutine</text>
</g>
<!-- Function -->
<g id="node2" class="node">
<title>Function</title>
<polygon fill="#d94e8f" stroke="#d94e8f" points="146,-24 88,-24 88,0 146,0 146,-24"/>
<text text-anchor="middle" x="117" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Function</text>
</g>
<!-- Interface -->
<g id="node3" class="node">
<title>Interface</title>
<polygon fill="#a7506f" stroke="#a7506f" points="225.5,-24 164.5,-24 164.5,0 225.5,0 225.5,-24"/>
<text text-anchor="middle" x="195" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Interface</text>
</g>
<!-- Unknown Procedure Type -->
<g id="node4" class="node">
<title>Unknown Procedure Type</title>
<polygon fill="#777777" stroke="#777777" points="388.5,-24 243.5,-24 243.5,0 388.5,0 388.5,-24"/>
<text text-anchor="middle" x="316" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Unknown Procedure Type</text>
</g>
<!-- Program -->
<g id="node5" class="node">
<title>Program</title>
<polygon fill="#f0ad4e" stroke="#f0ad4e" points="465,-24 407,-24 407,0 465,0 465,-24"/>
<text text-anchor="middle" x="436" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Program</text>
</g>
<!-- This Page&#39;s Entity -->
<g id="node6" class="node">
<title>This Page&#39;s Entity</title>
<polygon fill="none" stroke="black" points="588.5,-24 483.5,-24 483.5,0 588.5,0 588.5,-24"/>
<text text-anchor="middle" x="536" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50">This Page&#39;s Entity</text>
</g>
</g>
</svg>

    
    <p>Solid arrows point from a procedure to one which it calls. Dashed 
    arrows point from an interface to procedures which implement that interface.
    This could include the module procedures in a generic interface or the
    implementation in a submodule of an interface in a parent module.
    </p>
    </div></div></div></div>
      </div>
    </div>
     
     
    <div class="panel panel-default">
      <div class="panel-heading">
  <h3 class="panel-title">Called by</h3>
      </div>
      <div class="panel-body">
  <div class="depgraph"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: proc~~diva~~CalledByGraph Pages: 1 -->
<svg id="procdivaCalledByGraph" width="161pt" height="116pt"
 viewBox="0.00 0.00 161.00 116.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="proc~~diva~~CalledByGraph" class="graph" transform="scale(1 1) rotate(0) translate(4 112)">
<title>proc~~diva~~CalledByGraph</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-112 157,-112 157,4 -4,4"/>
<!-- proc~diva -->
<g id="proc~~diva~~CalledByGraph_node1" class="node">
<title>proc~diva</title>
<polygon fill="none" stroke="black" points="153,-66 99,-66 99,-42 153,-42 153,-66"/>
<text text-anchor="middle" x="126" y="-51.6" font-family="Helvetica,sans-Serif" font-size="10.50">DIVA</text>
</g>
<!-- program~drdiva -->
<g id="proc~~diva~~CalledByGraph_node2" class="node">
<title>program~drdiva</title>
<g id="a_proc~~diva~~CalledByGraph_node2"><a xlink:href=".././program/drdiva.html" xlink:title="DRDIVA">
<polygon fill="#f0ad4e" stroke="#f0ad4e" points="58.5,-108 4.5,-108 4.5,-84 58.5,-84 58.5,-108"/>
<text text-anchor="middle" x="31.5" y="-93.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">DRDIVA</text>
</a>
</g>
</g>
<!-- program~drdiva&#45;&gt;proc~diva -->
<g id="proc~~diva~~CalledByGraph_edge1" class="edge">
<title>program~drdiva&#45;&gt;proc~diva</title>
<path fill="none" stroke="#000000" d="M58.76,-84.08C68.41,-79.69 79.5,-74.66 89.81,-69.98"/>
<polygon fill="#000000" stroke="#000000" points="91.34,-73.13 99,-65.81 88.44,-66.76 91.34,-73.13"/>
</g>
<!-- program~drdivx -->
<g id="proc~~diva~~CalledByGraph_node3" class="node">
<title>program~drdivx</title>
<g id="a_proc~~diva~~CalledByGraph_node3"><a xlink:href=".././program/drdivx.html" xlink:title="DRDIVX">
<polygon fill="#f0ad4e" stroke="#f0ad4e" points="59,-66 4,-66 4,-42 59,-42 59,-66"/>
<text text-anchor="middle" x="31.5" y="-51.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">DRDIVX</text>
</a>
</g>
</g>
<!-- program~drdivx&#45;&gt;proc~diva -->
<g id="proc~~diva~~CalledByGraph_edge2" class="edge">
<title>program~drdivx&#45;&gt;proc~diva</title>
<path fill="none" stroke="#000000" d="M59.25,-54C68.42,-54 78.84,-54 88.64,-54"/>
<polygon fill="#000000" stroke="#000000" points="88.94,-57.5 98.94,-54 88.94,-50.5 88.94,-57.5"/>
</g>
<!-- program~drdivdb -->
<g id="proc~~diva~~CalledByGraph_node4" class="node">
<title>program~drdivdb</title>
<g id="a_proc~~diva~~CalledByGraph_node4"><a xlink:href=".././program/drdivdb.html" xlink:title="DRDIVDB">
<polygon fill="#f0ad4e" stroke="#f0ad4e" points="63,-24 0,-24 0,0 63,0 63,-24"/>
<text text-anchor="middle" x="31.5" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">DRDIVDB</text>
</a>
</g>
</g>
<!-- program~drdivdb&#45;&gt;proc~diva -->
<g id="proc~~diva~~CalledByGraph_edge3" class="edge">
<title>program~drdivdb&#45;&gt;proc~diva</title>
<path fill="none" stroke="#000000" d="M59.25,-24.15C68.72,-28.44 79.51,-33.35 89.58,-37.92"/>
<polygon fill="#000000" stroke="#000000" points="88.39,-41.22 98.94,-42.17 91.28,-34.85 88.39,-41.22"/>
</g>
</g>
</svg>
</div><div><a type="button" class="graph-help" data-toggle="modal" href="#graph-help-text">Help</a></div><div class="modal fade" id="graph-help-text" tabindex="-1" role="dialog"><div class="modal-dialog modal-lg" role="document"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><h4 class="modal-title" id="-graph-help-label">Graph Key</h4></div><div class="modal-body">
    <p>Nodes of different colours represent the following: </p>
    <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: Graph Key Pages: 1 -->
<svg width="597pt" height="32pt"
 viewBox="0.00 0.00 596.50 32.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 28)">
<title>Graph Key</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-28 592.5,-28 592.5,4 -4,4"/>
<!-- Subroutine -->
<g id="node1" class="node">
<title>Subroutine</title>
<polygon fill="#d9534f" stroke="#d9534f" points="70,-24 0,-24 0,0 70,0 70,-24"/>
<text text-anchor="middle" x="35" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Subroutine</text>
</g>
<!-- Function -->
<g id="node2" class="node">
<title>Function</title>
<polygon fill="#d94e8f" stroke="#d94e8f" points="146,-24 88,-24 88,0 146,0 146,-24"/>
<text text-anchor="middle" x="117" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Function</text>
</g>
<!-- Interface -->
<g id="node3" class="node">
<title>Interface</title>
<polygon fill="#a7506f" stroke="#a7506f" points="225.5,-24 164.5,-24 164.5,0 225.5,0 225.5,-24"/>
<text text-anchor="middle" x="195" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Interface</text>
</g>
<!-- Unknown Procedure Type -->
<g id="node4" class="node">
<title>Unknown Procedure Type</title>
<polygon fill="#777777" stroke="#777777" points="388.5,-24 243.5,-24 243.5,0 388.5,0 388.5,-24"/>
<text text-anchor="middle" x="316" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Unknown Procedure Type</text>
</g>
<!-- Program -->
<g id="node5" class="node">
<title>Program</title>
<polygon fill="#f0ad4e" stroke="#f0ad4e" points="465,-24 407,-24 407,0 465,0 465,-24"/>
<text text-anchor="middle" x="436" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Program</text>
</g>
<!-- This Page&#39;s Entity -->
<g id="node6" class="node">
<title>This Page&#39;s Entity</title>
<polygon fill="none" stroke="black" points="588.5,-24 483.5,-24 483.5,0 588.5,0 588.5,-24"/>
<text text-anchor="middle" x="536" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50">This Page&#39;s Entity</text>
</g>
</g>
</svg>

    
    <p>Solid arrows point from a procedure to one which it calls. Dashed 
    arrows point from an interface to procedures which implement that interface.
    This could include the module procedures in a generic interface or the
    implementation in a submodule of an interface in a parent module.
    </p>
    </div></div></div></div>
      </div>
    </div>
     
    <br>

    <section class="visible-xs visible-sm hidden-md">
      
<h3>Contents</h3>
 


<div class="panel panel-primary">
  <div class="panel-heading
  text-left"><h3 class="panel-title"><a data-toggle="collapse"
  href="#common-1">Common Blocks</a></h3></div>
  <div id="common-1" class="panel-collapse collapse">
    <div class="list-group">
      
      <a class="list-group-item" href="../proc/diva.html#common-divaev~3">DIVAEV</a>
      
      <a class="list-group-item" href="../proc/diva.html#common-divasc~3">DIVASC</a>
      
      <a class="list-group-item" href="../proc/diva.html#common-divamc~3">DIVAMC</a>
      
    </div>
  </div>
</div>






















    </section>
    <br class="visible-xs visible-sm hidden-md">

    
    <section>
      <h2>Common Blocks</h2>
      
      
<div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="common-divaev~3"></span><h3>
      <a data-toggle="popover" data-html="true" tabindex="0" 
     data-trigger="focus"
   data-content="<h4>Used Elsewhere:</h4><a href='../proc/divadb.html#common-divaev'>DIVADB</a> (subroutine)<br><a href='../proc/divag.html#common-divaev~2'>DIVAG</a> (subroutine)<br><a href='../proc/divaa.html#common-divaev~4'>DIVAA</a> (subroutine)<br><a href='../proc/divacr.html#common-divaev~5'>DIVACR</a> (subroutine)<br><a href='../proc/divahc.html#common-divaev~6'>DIVAHC</a> (subroutine)<br><a href='../proc/divaop.html#common-divaev~7'>DIVAOP</a> (subroutine)<br><a href='../proc/divapr.html#common-divaev~8'>DIVAPR</a> (subroutine)<br>">common /DIVAEV/</a>
      
  </h3></div>
  <div class="panel-body">
    
    
    
    
<table class="table table-striped varlist">
<thead><tr><th>Type</th>

<th>Attributes</th><th></th><th>Name</th><th></th><th>Initial</th><th></th></thead>



<tbody>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-eeps2~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>EEPS2</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-eept75~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>EEPT75</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-eovep2~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>EOVEP2</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-ovtm75~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>OVTM75</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-ovd10~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>OVD10</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-eeps10~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>EEPS10</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-eeps16~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>EEPS16</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-erov10~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>EROV10</strong></td><td></td><td></td><td></td>
  
</tr>

</tbody>
</table>

    
</div>
</div>

      
      
<div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="common-divasc~3"></span><h3>
      <a data-toggle="popover" data-html="true" tabindex="0" 
     data-trigger="focus"
   data-content="<h4>Used Elsewhere:</h4><a href='../proc/divadb.html#common-divasc'>DIVADB</a> (subroutine)<br><a href='../proc/divag.html#common-divasc~2'>DIVAG</a> (subroutine)<br><a href='../proc/divaa.html#common-divasc~4'>DIVAA</a> (subroutine)<br><a href='../proc/divabu.html#common-divasc~5'>DIVABU</a> (subroutine)<br><a href='../proc/divaco.html#common-divasc~6'>DIVACO</a> (subroutine)<br><a href='../proc/divacr.html#common-divasc~7'>DIVACR</a> (subroutine)<br><a href='../proc/divahc.html#common-divasc~8'>DIVAHC</a> (subroutine)<br><a href='../proc/divain.html#common-divasc~9'>DIVAIN</a> (subroutine)<br><a href='../proc/divaop.html#common-divasc~10'>DIVAOP</a> (subroutine)<br><a href='../proc/divapr.html#common-divasc~11'>DIVAPR</a> (subroutine)<br>">common /DIVASC/</a>
      
  </h3></div>
  <div class="panel-body">
    
    
    
    
<table class="table table-striped varlist">
<thead><tr><th>Type</th>

<th>Attributes</th><th></th><th>Name</th><th></th><th>Initial</th><th></th></thead>



<tbody>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-tn~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>TN</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-xi~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>XI</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iopst~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOPST</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-kordi~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KORDI</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-kqmaxd~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KQMAXD</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-kqmaxi~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KQMAXI</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-ldt~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>LDT</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-maxdif~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>MAXDIF</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-maxint~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>MAXINT</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-nkdko~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>NKDKO</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-nte~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>NTE</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-nyny~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>NYNY</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-ndtf~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>NDTF</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-numdt~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>NUMDT</strong></td><td></td><td></td><td></td>
  
</tr>

</tbody>
</table>

    
</div>
</div>

      
      
<div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="common-divamc~3"></span><h3>
      <a data-toggle="popover" data-html="true" tabindex="0" 
     data-trigger="focus"
   data-content="<h4>Used Elsewhere:</h4><a href='../proc/divadb.html#common-divamc'>DIVADB</a> (subroutine)<br><a href='../proc/divag.html#common-divamc~2'>DIVAG</a> (subroutine)<br><a href='../proc/divaa.html#common-divamc~4'>DIVAA</a> (subroutine)<br><a href='../proc/divabu.html#common-divamc~5'>DIVABU</a> (subroutine)<br><a href='../proc/divaco.html#common-divamc~6'>DIVACO</a> (subroutine)<br><a href='../proc/divacr.html#common-divamc~7'>DIVACR</a> (subroutine)<br><a href='../proc/divahc.html#common-divamc~8'>DIVAHC</a> (subroutine)<br><a href='../proc/divaop.html#common-divamc~9'>DIVAOP</a> (subroutine)<br><a href='../proc/divapr.html#common-divamc~10'>DIVAPR</a> (subroutine)<br>">common /DIVAMC/</a>
      
  </h3></div>
  <div class="panel-body">
    
    
    
    
<table class="table table-striped varlist">
<thead><tr><th>Type</th>

<th>Attributes</th><th></th><th>Name</th><th></th><th>Initial</th><th></th></thead>



<tbody>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-tg~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>TG</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-tgstop~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>TGSTOP</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-tmark~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>TMARK</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-tmarkx~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>TMARKX</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-tout~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>TOUT</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-tolg~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>TOLG</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-hc~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>HC</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-hdec~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>HDEC</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-hinc~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>HINC</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-hincc~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>HINCC</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-hmax~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>HMAX</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-hmaxp9~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>HMAXP9</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-hmin~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>HMIN</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-alpha~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>ALPHA</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-beta~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>BETA</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-d~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>D</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-g~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>G</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-v~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>V</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-ds~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>DS</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-gs~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>GS</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-sigma~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>SIGMA</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-rbq~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>RBQ</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-dnoise~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>DNOISE</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-eave~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>EAVE</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-eimax~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>EIMAX</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-eimin~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>EIMIN</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-emax~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>EMAX</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-erep~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>EREP</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-robnd~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>ROBND</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-snoise~3"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>SNOISE</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-fdat~4"></span>real</td>
  
  
  <td></td><td>::</td>
  <td><strong>FDAT</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-icf~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>ICF</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-ics~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>ICS</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-igflg~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IGFLG</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-igtype~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IGTYPE</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-igstop~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IGSTOP</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-ilgrep~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>ILGREP</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-ings~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>INGS</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop3~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP3</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop4~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP4</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop5~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP5</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop6~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP6</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop7~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP7</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop8~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP8</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop9~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP9</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop10~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP10</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop11~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP11</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop12~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP12</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop13~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP13</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop14~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP14</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop15~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP15</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop16~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP16</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop17~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP17</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop18~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP18</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop19~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP19</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop20~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP20</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop21~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP21</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop22~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP22</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iop21s~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IOP21S</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-itolep~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>ITOLEP</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-iy~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IY</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-kemax~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KEMAX</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-kis~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KIS</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-kmark~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KMARK</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-kord1i~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KORD1I</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-kord2i~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KORD2I</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-kpred~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KPRED</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-kqdcon~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KQDCON</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-kqicon~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KQICON</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-kqmaxs~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KQMAXS</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-kqmxds~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KQMXDS</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-kqmxil~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KQMXIL</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-kqmxip~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KQMXIP</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-kqmxis~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KQMXIS</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-ksc~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KSC</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-ksout~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KSOUT</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-ksstrt~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KSSTRT</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-kstep~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>KSTEP</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-lex~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>LEX</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-linc~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>LINC</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-lincd~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>LINCD</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-lincq~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>LINCQ</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-lsc~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>LSC</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-maxkqd~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>MAXKQD</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-maxkqi~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>MAXKQI</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-method~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>METHOD</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-ne~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>NE</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-neptol~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>NEPTOL</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-ng~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>NG</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-ngtot~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>NGTOT</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-noiseq~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>NOISEQ</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-noutko~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>NOUTKO</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-ntolf~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>NTOLF</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-ny~3"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>NY</strong></td><td></td><td></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-idat~6"></span>integer</td>
  
  
  <td></td><td>::</td>
  <td><strong>IDAT</strong></td><td></td><td></td><td></td>
  
</tr>

</tbody>
</table>

    
</div>
</div>

      
    </section>
    <br>
    <script>
      $(function () {
      $('[data-toggle="popover"]').popover()
      })
    </script>
    

    
    
    
    
    

    
    
    
    
    


    
    
    
    
    </div>
  </div>


    <hr>    
    </div> <!-- /container -->
    <footer>
      <div class="container">
      <div class="row">
        <div class="col-xs-6 col-md-4"><p>&copy; 2021 
                                          </p></div>
        <div class="col-xs-6 col-md-4 col-md-push-4">
          <p class="text-right">
            Documentation generated by 
            <a href="https://github.com/cmacmackin/ford">FORD</a>
            
          </p>
        </div>
        <div class="col-xs-12 col-md-4 col-md-pull-4"><p class="text-center"> diva was developed by Jacob Williams</p></div>
      </div>
      <br>
      </div> <!-- /container -->    
    </footer>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
<!--
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
-->
    <script src="../js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../js/ie10-viewport-bug-workaround.js"></script>

    <!-- MathJax JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
        jax: ['input/TeX','input/MathML','output/HTML-CSS'],
        extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
      });
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    
    <script src="../tipuesearch/tipuesearch_content.js"></script>
    <script src="../tipuesearch/tipuesearch_set.js"></script>
    <script src="../tipuesearch/tipuesearch.js"></script>
    
    
  </body>
</html>